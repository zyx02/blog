<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSP-S2021游记]]></title>
    <url>%2Fblog%2F2021%2F10%2F23%2FCSP-S2021%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[$Day-7$停课了，好耶！可以颓七天了 今天打$lmki$神仙出的模拟赛，被其他学校神仙暴虐/kk $100+40+40+0$我是什么fw $t1$博弈论，还是挺好看出结论的。 $t2$有点懵，随便打了一个搜索和一个部分分。考完后才知道这是$lmki$自己出的题目，正解是$dp$+树状数组优化，还用了2种方法解释/se（lmki真是tql!!!) $t3$带修莫队，没学过/kk $t4$期望，。。。。 $Day-6$~$Day-5$改题，学莫队 $Day-4$模拟赛。 $100+20+100+0$ $rk2$ $Day-3$改题，刷题 $Day-2$模拟赛 $70+10+40+20$ $rk5$ $t1$数组开小$100-&gt;70$ $t2$忘记初始白色判断$100-&gt;10$ $t3$重边忘了取min$60-&gt;40$ 三道题挂了$140$我是什么垃圾 $Day-1$最后一天了，不想打题，跟机房神仙打了一上午雀魂 下午继续颓废 晚上$phigros$更新了！迅速推完第七章 感觉明天要挂/kk 考前$lmki$奶了一手四题思维题，但愿不是 $Day-0$早上睡到11点才醒，晚上颓太晚了/baojin 整个人还有点困，下午真的要无了 今年仍然在泉州一中考，虽然每年都来但是每一次都被震撼到（ $14:29$ 草，好紧张 $14:30$开题 先看了一下编译选项，好耶，是$-O2$ 第一题，廊桥分配，第一眼感觉是贪心？ 第二题，括号序列，字符串？果断放弃 第三题，回文，嗯。。 第四题，交通规划，看不懂。。。 开始回去打第一题，一直在$set$和手打平衡树之间纠结，最后还是选择了$set$ 先按照自己的思路写了一个，跑了第一个样例第二个样例都过了，第三个样例错了，顿时慌了。 开始看代码，发现代码好像没错，难道是思路错了？ 又仔细想了一遍，构造出了几个可以hack的数据，修正了一下自己的思路，好耶过了 然后自己造了一个大数据，居然跑这么久？ 后面才发现 1lower_bound(s.begin(), s.end(), val); 比 1s.lower_bound(val); 慢得多，改成后者就跑的飞快了（我是sb 第二题，想了一些性质，发现根本没用，看到爆搜才15分果断开下一题 第三题打了一个40分的暴力，然后就不会了。 再看一遍第四题，$k=2$部分分好像好做？码了一下最后还是放弃了。 看了一下时间还有$1.5h$，就想把$t2$爆搜打一下，结果发现自己连暴力都不会了，草。 无所事事ing…. $t2$和$t4$反复横跳ing…. 最后二十分钟了，两题暴力都没打出来，我是什么fw 又去检查了一遍$t1$和$t3$，不管了，等死了。 出来跟神仙们讨论了一下，$t1$应该思路是正确的，那就放心了（ 回家。 如果能进$NOIP$就再好不过了。 又要回去肝文化课了（大哭]]></content>
      <tags>
        <tag>游记</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解]ZJOI2012灾难]]></title>
    <url>%2Fblog%2F2021%2F08%2F28%2F%E9%A2%98%E8%A7%A3-ZJOI2012%E7%81%BE%E9%9A%BE%2F</url>
    <content type="text"><![CDATA[题目描述洛谷 题解题目中有多个生产者，考虑建一个虚点连向所有的生产者，这样保证了图连通。显然我们要按照拓扑序处理每个节点。 一个生物死亡只有当且仅当所有指向它的生物死亡，如果它的入度为$1$比较好处理，但如果大于$1$呢？ 让捕食者向被捕食者再建一条边，当遍历到一个捕食者有多条连向它的被捕食者的边时，我们可以让这个捕食者直接向它的所有被捕食者的最近公共祖先连一条边。因为它们的最近公共祖先死亡了它们会全部死亡，所以连向被捕食者的所有边与连向它们最近公共祖先的边是等价的，这样我们就保证了图成为一棵树。 如图 观察发现小强向牛和羊都有连边，牛和羊的最近公共祖先是草，这表明草死亡了牛和羊都会死亡，所以小强也会死亡。所以可以直接让小强向草连一条边。 最后只需要统计每个节点的子树大小，减去自己的$1$即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 70010;int read()&#123; int sum = 0 , f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * f;&#125;int n , cnt , head[MAXN];int deg[MAXN] , f[30][MAXN] , depth[MAXN];int tcnt , thead[MAXN];struct G&#123; int To , Nxt;&#125;edge[MAXN * 100] , Tree[MAXN];void add(int From , int To)&#123; edge[++ cnt].Nxt = head[From]; edge[cnt].To = To; head[From] = cnt;&#125;void addTree(int From , int To)&#123; Tree[++ tcnt].Nxt = thead[From]; Tree[tcnt].To = To; thead[From] = tcnt;&#125;int Lca(int x , int y)&#123; if(depth[x] &lt; depth[y]) swap(x , y); for(int j = 20; j &gt;= 0; j --) if(depth[f[j][x]] &gt;= depth[y]) x = f[j][x]; if(x == y) return x; for(int j = 20; j &gt;= 0; j --) if(f[j][x] != f[j][y]) x = f[j][x] , y = f[j][y]; return f[0][x]; &#125;void Work(int k)&#123; for(int j = 1; j &lt;= 20; j ++) f[j][k] = f[j - 1][f[j - 1][k]];&#125;bool vis[MAXN];int q[MAXN] , fa[MAXN];void Toopsort()&#123; int Head = 1 , tail = 1; q[tail] = 0; depth[0] = 0; while(Head &lt;= tail) &#123; int k = q[Head]; vis[k] = 1; Head ++; for(int i = head[k]; i != -1; i = edge[i].Nxt) &#123; int v = edge[i].To; if(vis[v] or deg[v] == 0) continue; if(fa[v] == -1) fa[v] = k; else fa[v] = Lca(fa[v] , k); deg[v] --; if(deg[v] == 0) &#123; f[0][v] = fa[v]; depth[v] = depth[fa[v]] + 1; Work(v); addTree(fa[v] , v); q[++ tail] = v; &#125; &#125; &#125;&#125;int Size[MAXN];void Dfs(int k)&#123; Size[k] = 1; for(int i = thead[k]; i != -1; i = Tree[i].Nxt) &#123; int v = Tree[i].To; Dfs(v); Size[k] += Size[v]; &#125;&#125;int main()&#123;// freopen("catas_catas9.in" , "r" , stdin);// freopen("catas_catas9.out" , "w" , stdout); n = read(); memset(head , -1 , sizeof(head)); memset(fa , -1 , sizeof(fa)); memset(thead , -1 , sizeof(thead)); for(int i = 1; i &lt;= n; i ++) &#123; int x = read(); while(x != 0) &#123; deg[i] ++; add(i , x); add(x , i); x = read(); &#125; if(deg[i] == 0) deg[i] ++ , add(0 , i); &#125; Toopsort(); Dfs(0); for(int i = 1; i &lt;= n; i ++) &#123;// if(Size[i] == 0) cout &lt;&lt; i &lt;&lt; endl; printf("%d\n" , Size[i] - 1); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>LCA,最近公共祖先</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解]vistifj]]></title>
    <url>%2Fblog%2F2021%2F08%2F28%2F%E9%A2%98%E8%A7%A3-vistifj%2F</url>
    <content type="text"><![CDATA[题目描述 题解一种显然的做法是$dfs$枚举所有路线，但这样时间复杂度爆炸。注意到$n&lt;=100$，考虑记忆化，记录$dp[i][j][3]$表示到坐标$(i,j)$走了$s$ $mod$ $3$所需的最小花费。 一个小优化是将$dfs$改为像$bfs$的搜索，优先拓展花费小的状态。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std; inline int read()&#123; int sum = 0 , f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * f;&#125; long long n , t ;long long ans = INT_MAX ;long long dp[110][110][3] , v[110][110], minx = INT_MAX;const int dx[] = &#123;1, -1, 0, 0&#125;, dy[] = &#123;0, 0, 1, -1&#125;;bool vis[110][110]; inline long long Min(long long a , long long b)&#123; return a &lt; b? a : b;&#125; struct node&#123; int x , y; long long tot; int s; bool operator &lt;(const node &amp;x) const &#123;return x.tot &lt; tot;&#125;&#125;; inline void bfs()&#123; priority_queue&lt;node&gt; q; q.push((node)&#123;1 , 1 , 0&#125;); while(!q.empty()) &#123; node k = q.top(); q.pop(); if(k.tot &gt;= dp[k.x][k.y][k.s % 3]) continue; dp[k.x][k.y][k.s % 3] = k.tot; if(k.tot &gt;= ans) continue; if(k.x == n and k.y == n) &#123; ans = k.tot; continue; &#125; for(int i = 0; i &lt; 4; i ++) &#123; int xx = k.x + dx[i] , yy = k.y + dy[i] , ss = k.s + 1; if(xx &lt; 1 or xx &gt; n or yy &lt; 1 or yy &gt; n) continue; q.push(node&#123;xx , yy , k.tot + t + (ss % 3 == 0) * v[xx][yy] , ss&#125;); &#125; &#125;&#125; int main()&#123; n = read() , t = read(); for(register int i = 1; i &lt;= n; i ++) for(register int j = 1; j &lt;= n; j ++) v[i][j] = read(); for(register int i = 1; i &lt;= n; i ++) for(register int j = 1; j &lt;= n; j ++) for(register int k = 0; k &lt; 3; k ++) dp[i][j][k] = INT_MAX; bfs(); printf("%d\n" , ans); return 0;&#125;]]></content>
      <tags>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解]cqoi2017老C的任务]]></title>
    <url>%2Fblog%2F2021%2F08%2F27%2F%E9%A2%98%E8%A7%A3-cqoi2017%E8%80%81C%E7%9A%84%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[题目描述洛谷 题解由于题目不强制在线，我们可以将所有询问离线解决。 思考如果只有一个询问如何解决？显然可以用二维前缀和搞定。 对于每个询问，我们只需要求出四个点的答案，假设对角坐标（左下和右上）为$(a,b),(c,d)$，我们只需要求出$(a-1,b-1),(c,b-1),(a-1,d),(c,d)$左下方的所有基站功率之和即可。 $n&lt;=10^5$，直接$O(n^2)$暴力显然不可取。 假设我们目前求的点为$(x,y)$，需要统计的即所有满足$x_i&lt;=x,y_i&lt;=y$的基站权值之和。 （坐标数值较大，需要先进行离散化。） 可以先将基站的点和每个询问要求的点合在一起。维护一个一维的树状数组$t$，统计横坐标为$x$的基站功率和，按$y$从小到大先排序一遍，然后进行遍历，当遍历到基站时$i$时，对$x_i$进行单点加;当遍历到询问点$j$时，统计$1$~$x_j$区间和即可（此处$1,x_i,x_j$均为离散化后的横坐标），这样保证了两个条件（$x&lt;=x_j,y&lt;=y_j$） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int sum = 0 , f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * f;&#125;int n , m , cnt , len;long long ans[100010];struct Node&#123; int x , y; int rk ; long long power; bool p;&#125;a[500010];long long tree[100010];int b[500010];bool cmp(Node a , Node b)&#123; if(a.y == b.y) &#123; if(a.x == b.x) return a.p &gt; b.p; return a.x &lt; b.x; &#125; return a.y &lt; b.y;&#125;int lowbit(int x)&#123; return x &amp; -x;&#125;void add(int pos , int w)&#123; while(pos &lt;= len) tree[pos] += w , pos += lowbit(pos);&#125;long long query(int pos)&#123; long long sum = 0; while(pos) sum += tree[pos] , pos -= lowbit(pos); return sum;&#125;int main()&#123; n = read() , m = read(); for(int i = 1; i &lt;= n; i ++) &#123; a[++ cnt].x = read() , a[cnt].y = read() , a[cnt].power = read(); b[cnt] = a[cnt].x; a[cnt].p = 1; &#125; for(int i = 1; i &lt;= m; i ++) &#123; int A = read() , B = read() , c = read() , d = read(); a[++ cnt].x = A - 1 , a[cnt].y = B - 1 , a[cnt].rk = i; b[cnt] = a[cnt].x; a[++ cnt].x = c , a[cnt].y = B - 1 , a[cnt].rk = -i; b[cnt] = a[cnt].x; a[++ cnt].x = A - 1 , a[cnt].y = d , a[cnt].rk = -i; b[cnt] = a[cnt].x; a[++ cnt].x = c , a[cnt].y = d , a[cnt].rk = i; b[cnt] = a[cnt].x; &#125; sort(b + 1 , b + cnt + 1); len = unique(b + 1 , b + cnt + 1) - b - 1; for(int i = 1; i &lt;= cnt; i ++) a[i].x = lower_bound(b + 1 , b + len + 1 , a[i].x) - b; sort(a + 1 , a + cnt + 1 , cmp); for(int i = 1; i &lt;= cnt; i ++) &#123; if(a[i].p) &#123; add(a[i].x , a[i].power); &#125; else &#123; int k = abs(a[i].rk); if(a[i].rk &lt; 0) ans[k] -= query(a[i].x); else ans[k] += query(a[i].x); &#125; &#125; for(int i = 1; i &lt;= m; i ++) printf("%lld\n" , ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>二维偏序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解？]NOIP2014飞扬的小鸟]]></title>
    <url>%2Fblog%2F2021%2F08%2F27%2F%E9%A2%98%E8%A7%A3%EF%BC%9F-NOIP2014%E9%A3%9E%E6%89%AC%E7%9A%84%E5%B0%8F%E9%B8%9F%2F</url>
    <content type="text"><![CDATA[题目描述洛谷 题解？dp方程还是比较好推的吧……但是有一些细节需要注意。 这是我一开始80分的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int sum = 0 , f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * f;&#125;int n , m , k;int x[10010] , y[10010];int dp[10010][1010];int l[10010] , h[10010];int main()&#123; n = read() , m = read() , k = read(); for(int i = 1; i &lt;= n; i ++) x[i] = read() , y[i] = read(); for(int i = 0; i &lt;= n; i ++) for(int j = 0; j &lt;= m; j ++) dp[i][j] = 2e9; for(int i = 1; i &lt;= k; i ++) &#123; int p = read(); l[p] = read() , h[p] = read(); &#125; for(int i = 0; i &lt;= n; i ++) &#123; if(!h[i]) h[i] = m + 1; &#125; for(int i = l[0] + 1; i &lt; h[0]; i ++) dp[0][i] = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = l[i] + 1; j &lt; h[i]; j ++) &#123; if(j == m) for(int q = x[i]; q &gt;= 0; q --) dp[i][j] = min(dp[i][j] , min(dp[i - 1][m - q] , dp[i][m - q]) + 1); if(j &gt; x[i]) dp[i][j] = min(dp[i][j] , min(dp[i - 1][j - x[i]] , dp[i][j - x[i]]) + 1); if(j + y[i] &lt;= m) dp[i][j] = min(dp[i][j] , dp[i - 1][j + y[i]]); &#125; &#125; int ans = 2e9; for(int i = l[n] + 1; i &lt; h[n]; i ++) ans = min(ans , dp[n][i]); if(ans &lt; 2e9) &#123; printf("1\n%d\n" , ans); &#125; else &#123; printf("0\n"); for(int i = n - 1; i &gt;= 0; i --) &#123; for(int j = l[i] + 1; j &lt; h[i]; j ++) ans = min(ans , dp[i][j]); if(ans &lt; 2e9) &#123; int tot = 0; for(int kk = 0; kk &lt;= i; kk ++) if(h[kk] &lt;= m) tot ++; printf("%d\n" , tot); return 0; &#125; &#125; &#125; return 0;&#125; 80分的原因主要是在转移时出现错误，在洛谷这篇讨论中有详细的解答 链接 主要是由于我在转移的时候只考虑在管道间的高度，这样会导致忽略了一些中间的情况，如下面这组样例 1234563 1000 22 12 12 11 1 102 980 990 在第二个管道转移时由于我只枚举了$980$~$990$,导致$980$之前$dp$值全为inf，无法转移，但事实上小鸟可以多次跳跃，前面的值同样可以用来转移。 解决方法是先将高度全部枚举一遍，最后再把$0$~$l$和$h$~$m$的值赋为inf 果然我还是太菜了啊…… Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int sum = 0 , f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * f;&#125;int n , m , k;int x[10010] , y[10010];int dp[10010][2010];int l[10010] , h[10010];int main()&#123; n = read() , m = read() , k = read(); for(int i = 1; i &lt;= n; i ++) x[i] = read() , y[i] = read(); for(int i = 0; i &lt;= n; i ++) for(int j = 0; j &lt;= 2 * m; j ++) dp[i][j] = 2e9; for(int i = 1; i &lt;= k; i ++) &#123; int p = read(); l[p] = read() , h[p] = read(); &#125; for(int i = 0; i &lt;= n; i ++) &#123; if(!h[i]) h[i] = m + 1; &#125; for(int i = l[0] + 1; i &lt; h[0]; i ++) dp[0][i] = 0; for(int i = 1; i &lt;= n; i ++) &#123; for(int j = x[i] + 1; j &lt;= x[i] + m; j ++) &#123; dp[i][j] = min(dp[i][j] , min(dp[i - 1][j - x[i]] , dp[i][j - x[i]]) + 1); &#125; for(int j = m + 1; j &lt;= x[i] + m; j ++) dp[i][m] = min(dp[i][m] , dp[i][j]); for(int j = l[i] + 1; j &lt; h[i]; j ++) if(j + y[i] &lt;= m) dp[i][j] = min(dp[i - 1][j + y[i]] , dp[i][j]); for(int j = 0; j &lt;= l[i]; j ++) dp[i][j] = 2e9; for(int j = h[i]; j &lt;= m; j ++) dp[i][j] = 2e9; &#125; int ans = 2e9; for(int i = l[n] + 1; i &lt; h[n]; i ++) ans = min(ans , dp[n][i]); if(ans &lt; 2e9) &#123; printf("1\n%d\n" , ans); &#125; else &#123; printf("0\n"); for(int i = n - 1; i &gt;= 0; i --) &#123; for(int j = l[i] + 1; j &lt; h[i]; j ++) ans = min(ans , dp[i][j]); if(ans &lt; 2e9) &#123; int tot = 0; for(int kk = 0; kk &lt;= i; kk ++) if(h[kk] &lt;= m) tot ++; printf("%d\n" , tot); return 0; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解]CF383C Propagating tree]]></title>
    <url>%2Fblog%2F2021%2F08%2F27%2F%E9%A2%98%E8%A7%A3-CF383C-Propagating-tree%2F</url>
    <content type="text"><![CDATA[题目描述洛谷 CF 题解题目要求对给定的$u$节点的子树进行操作，使其$0$级节点加上$val$，$1$级节点减去$val$，$2$级节点加上$val$，以此类推。 由于对子树进行操作，考虑节点的$dfs$序，计算每个节点第一次被访问和回溯时的时间戳，则它的子树$dfs$序都在这段区间内，由此将树上修改转化为区间修改。 观察到一个节点加上或减去$val$与其深度的奇偶性有关，假定根节点深度为$1$。我们在以深度为奇数的节点的子树修改时令整个区间加上$val$，深度为偶数的节点的子树修改时令整个区间加上$-val$，输出时奇数深度的节点加上修改的值，偶数深度的节点减去修改的值即可解决。 由于题目要求区间修改单点查询，可以用树状数组解决。注意初始值不受影响。所以不需要进行初始化(注释部分)，在输出时加上初始值即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2e5 + 10;int read()&#123; int sum = 0 , f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * f;&#125;int n , m;int Black[MAXN] , White[MAXN] , ti;int head[MAXN] , cnt , val[MAXN] , depth[MAXN];int tree[MAXN] , id[MAXN];struct G&#123; int To , Nxt;&#125;edge[MAXN &lt;&lt; 1];void add(int From , int To)&#123; edge[++ cnt].Nxt = head[From]; edge[cnt].To = To; head[From] = cnt;&#125;void dfs(int k , int fa)&#123; depth[k] = depth[fa] + 1; Black[k] = ++ ti; id[ti] = k; for(int i = head[k]; i; i = edge[i].Nxt) &#123; int v = edge[i].To; if(v == fa) continue; dfs(v , k); &#125; White[k] = ti;&#125;int lowbit(int x)&#123; return x &amp; -x;&#125; void Add(int pos, int w)&#123; while(pos &lt;= n) tree[pos] += w , pos += lowbit(pos);&#125;int query(int pos)&#123; int sum = 0; while(pos) sum += tree[pos] , pos -= lowbit(pos); return sum;&#125;int main()&#123; n = read() , m = read(); for(int i = 1; i &lt;= n; i ++) val[i] = read(); for(int i = 1; i &lt; n; i ++) &#123; int u = read() , v = read(); add(u , v) , add(v , u); &#125; dfs(1 , 0);// for(int i = 2; i &lt;= n; i ++)// &#123;// Add(i , val[id[i]] - val[id[i - 1]]);// &#125; while(m --) &#123; int op = read(); if(op == 1) &#123; int x = read() , val = read(); if(depth[x] % 2 == 1) Add(Black[x] , val) , Add(White[x] + 1 , -val); else Add(Black[x] , -val) , Add(White[x] + 1 , val); &#125; else &#123; int x = read(); int s = query(Black[x]); if(depth[x] % 2 == 1) printf("%d\n" , val[x] + s); else printf("%d\n" , val[x] - s); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解]CF484E Sign on Fence]]></title>
    <url>%2Fblog%2F2021%2F08%2F25%2F%E9%A2%98%E8%A7%A3-CF484E-Sign-on-Fence%2F</url>
    <content type="text"><![CDATA[题目描述洛谷 CF 题解看到题目问的是最小值的最大值，显然可以二分求解 给出的高度在$10^9$范围内，需要先对高度进行离散化 假如我们二分出了一个$mid$，怎么判断它是否合法？可以这么解决，将所有数大于等于$mid$的数赋为$1$，其余赋为$0$，那么就是判断$[l,r]$之间是否存在一个长度大于等于$k$的连续的$1$ 可以对所有高度建一棵线段树，维护区间内最长$1$的长度，从左和从右开始最长$1$的长度，但是这样空间复杂度爆炸。我们可以使用主席树来维护。 可以按高度从大到小建树，保证大于等于它的数的位置都赋值了 初始时要建树计算一下区间长度，否则在pushup时判断时会出错12if(tree[ls(k)].lmax &#x3D;&#x3D; tree[ls(k)].len) ···if(tree[rs(k)].rmax &#x3D;&#x3D; tree[rs(k)].len) ··· Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;#define ls(k) tree[k].ls#define rs(k) tree[k].rsusing namespace std;const int MAXN = 1e5 + 10;int read()&#123; int sum = 0 , f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * f;&#125;int n , m , cnt , len;int a[MAXN] , b[MAXN] , root[MAXN] , numroot[MAXN];struct hjtTree&#123; int ls , rs , val , lmax , rmax , len;&#125;tree[MAXN * 40];void pushup(int k)&#123; tree[k].val = max(tree[ls(k)].val , tree[rs(k)].val); tree[k].val = max(tree[ls(k)].rmax + tree[rs(k)].lmax , tree[k].val); if(tree[ls(k)].lmax == tree[ls(k)].len) tree[k].lmax = tree[ls(k)].lmax + tree[rs(k)].lmax; else tree[k].lmax = tree[ls(k)].lmax; if(tree[rs(k)].rmax == tree[rs(k)].len) tree[k].rmax = tree[rs(k)].rmax + tree[ls(k)].rmax; else tree[k].rmax = tree[rs(k)].rmax;&#125;void update(int l , int r , int pre , int &amp;now , int pos)&#123; tree[++ cnt] = tree[pre]; now = cnt; tree[now].len = r - l + 1; if(l == r) &#123; tree[now].lmax = tree[now].rmax = tree[now].val = tree[now].len = 1; return; &#125; int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) update(l , mid , ls(pre) , ls(now) , pos); else update(mid + 1 , r , rs(pre) , rs(now) , pos); pushup(now);&#125;int query(int l , int r , int now , int sl , int sr)&#123; if(l &gt;= sl and r &lt;= sr) return tree[now].val; int mid = (l + r) &gt;&gt; 1 , s = 0; if(sl &lt;= mid) s = max(s , query(l , mid , ls(now) , sl , sr)); if(sr &gt; mid) s = max(s , query(mid + 1 , r , rs(now) , sl , sr)); if(sl &lt;= mid and sr &gt; mid) &#123; int s1 = min(tree[ls(now)].rmax , mid - sl + 1); int s2 = min(tree[rs(now)].lmax , sr - mid); s = max(s , s1 + s2); &#125; return s;&#125;void build(int l , int r , int &amp;now)&#123; now = ++ cnt; tree[now].len = r - l + 1; if(l == r) return; int mid = (l + r) &gt;&gt; 1; build(l , mid , ls(now)); build(mid + 1 , r , rs(now));&#125;vector&lt;int&gt; id[MAXN];int solve(int l , int r , int k)&#123; int sl = 1 , sr = len , ans = 0; while(sl &lt;= sr) &#123; int mid = (sl + sr) &gt;&gt; 1; if(query(1 , n , numroot[mid] , l , r) &gt;= k) ans = mid , sl = mid + 1; else sr = mid - 1; &#125; return b[ans];&#125;int main()&#123; n = read(); for(int i = 1; i &lt;= n; i ++) a[i] = b[i] = read(); sort(b + 1 , b + n + 1); len = unique(b + 1 , b + n + 1) - b - 1; for(int i = 1; i &lt;= n; i ++) &#123; a[i] = lower_bound(b + 1 , b + len + 1 , a[i]) - b; id[a[i]].push_back(i); &#125; build(1 , n , root[0]); int node = 0; for(int i = len; i &gt;= 1; i --) &#123; int siz = id[i].size(); for(int j = 0; j &lt; siz; j ++) &#123; node ++; update(1 , n , root[node - 1] , root[node] , id[i][j]); &#125; numroot[i] = root[node]; &#125; m = read(); while(m --) &#123; int l = read() , r = read() , k = read(); printf("%d\n" , solve(l , r , k)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解]1912异象石]]></title>
    <url>%2Fblog%2F2021%2F08%2F25%2F%E9%A2%98%E8%A7%A3-1912%E5%BC%82%E8%B1%A1%E7%9F%B3%2F</url>
    <content type="text"><![CDATA[题目描述 题解首先考虑如何求树上的任意个点连通的边集的总长度的最小值 可以对树上的点进行一次$dfs$求出它们的$dfs$序，将所求点按$dfs$序排序后相邻两点（包括头尾）的距离之和即为使这些点连通的边集的总长度的最小值的两倍 如图（蓝色为各点$dfs$序） 假设我们要让$1,2,3,5$连通 按$dfs$序排序后得到$1,3,5,2$ $dis(1,3)+dis(3,5)+dis(5,2)+dis(2,1)=5+15+11+1$ 观察发现每条边都被计算两次，所以结果是答案的$2$倍 有了以上结论后，我们可以得出一个算法，使用平衡树或$set$维护所有异象石的$dfs$序，每次插入一个新的异象石$k$时，查找到它在已有异象石中的前驱和后继，假设为$i,j$，更新$ans$，令其减去$dis(i,j)$并加上$dis(i,k)+dis(k,j)$。同理，删除操作则令$ans$加上$dis(i,j)$减去$dis(i,k)+dis(k,j)$ 注意特判边界 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include &lt;bits/stdc++.h&gt;using namespace std; const int MAXN = 1e5 + 10; int read()&#123; int sum = 0, f = 1; char c = getchar(); while (c &lt; '0' or c &gt; '9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0' and c &lt;= '9') &#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * f;&#125; int n, m, cnt, head[MAXN];int dfn[MAXN];long long dist[MAXN], tot, f[30][MAXN], depth[MAXN];struct G&#123; int To, Nxt, Dis;&#125; edge[MAXN &lt;&lt; 1]; void add(int From, int To, int Dis)&#123; edge[++cnt].Dis = Dis; edge[cnt].Nxt = head[From]; edge[cnt].To = To; head[From] = cnt;&#125; void dfs(int k, int fa)&#123; tot++; dfn[k] = tot; f[0][k] = fa; depth[k] = depth[fa] + 1; for (int i = head[k]; i; i = edge[i].Nxt) &#123; int v = edge[i].To; if (v == fa) continue; dist[v] = dist[k] + edge[i].Dis; dfs(v, k); &#125;&#125; void prework()&#123; for (int j = 1; j &lt;= 20; j++) for (int i = 1; i &lt;= n; i++) f[j][i] = f[j - 1][f[j - 1][i]];&#125; int Lca(int x, int y)&#123; if (depth[x] &lt; depth[y]) swap(x, y); for (int j = 20; j &gt;= 0; j--) if (depth[f[j][x]] &gt;= depth[y]) x = f[j][x]; if (x == y) return x; for (int j = 20; j &gt;= 0; j--) if (f[j][x] != f[j][y]) x = f[j][x], y = f[j][y]; return f[0][x];&#125; set&lt;int&gt; s;int id[MAXN];char ch;long long ans; long long calc(int x, int y)&#123; int t = Lca(x, y); return dist[x] + dist[y] - 2 * dist[t];&#125; int main()&#123; n = read(); for (int i = 1; i &lt; n; i++) &#123; int x = read(), y = read(), z = read(); add(x, y, z), add(y, x, z); &#125; dfs(1, 0); for (int i = 1; i &lt;= n; i++) id[dfn[i]] = i; prework(); m = read(); while (m--) &#123; scanf(" "); scanf("%c", &amp;ch); if (ch == '+') &#123; int x = read(); if (s.empty()) &#123; s.insert(dfn[x]); continue; &#125; set&lt;int&gt;::iterator it = s.lower_bound(dfn[x]); if (it == s.begin()) &#123; int y = *it; set&lt;int&gt;::iterator it1 = --s.end(); int z = *it1; ans += (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z])); &#125; else &#123; if (it == s.end()) &#123; it--; int y = *it; int z = *s.begin(); ans += (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z])); &#125; else &#123; int y = *it; if (it != s.begin()) it--; int z = *it; ans += (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z])); &#125; &#125; s.insert(dfn[x]); &#125; if (ch == '-') &#123; int x = read(); if (s.size() == 1) &#123; s.erase(dfn[x]); continue; &#125; set&lt;int&gt;::iterator it = s.find(dfn[x]); if (it == s.begin()) &#123; it++; int y = *it; set&lt;int&gt;::iterator it1 = --s.end(); int z = *it1; ans -= (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z])); &#125; else &#123; set&lt;int&gt;::iterator End = s.end(); End--; if (it == End) &#123; if (it != s.begin()) it--; int y = *it; int z = *s.begin(); ans -= (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z])); &#125; else &#123; it++; int y = *it; it--, it--; int z = *it; ans -= (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z])); &#125; &#125; s.erase(dfn[x]); &#125; if (ch == '?') &#123; printf("%lld\n", ans / 2); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>set</tag>
        <tag>LCA,最近公共祖先</tag>
        <tag>dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[题解]1037道路重建]]></title>
    <url>%2Fblog%2F2021%2F08%2F25%2F%E9%A2%98%E8%A7%A3-1037%E9%81%93%E8%B7%AF%E9%87%8D%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[题目描述 题解记$dp[i][j]$表示在以$i$为根的子树中保留$j$个牛棚需要摧毁的最小道路数，显然$dp[i][1]$等于与$i$相连的道路数。 对于所有的$v \in son_{i}$,我们可以枚举在$v$的子树中保留的牛棚树进行转移。方程: $dp_{k,j} = min(dp[k][j - l] + dp[v][l] - 2)$ $(1&lt;=j&lt;=p,1&lt;=l&lt;j)$ 注意转移中的$-2$,这是由于在$dp[k][j-l]和dp[v][l]$中，$k与v$的连边都被计算了一次，实际上这条边需要保留 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;using namespace std;int read()&#123; int sum = 0 , f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = sum * 10 + c - '0'; c = getchar(); &#125; return sum * f;&#125;int n , p;int Size[160] , Son[160][160] , tot[160];int dp[160][160];int dfs(int k)&#123; tot[k] = 1; for(int i = 1; i &lt;= Size[k]; i ++) &#123; tot[k] += dfs(Son[k][i]); &#125; return tot[k];&#125;void Dfs(int k , int fa)&#123; if(Son[k][1] == 0) &#123; return; &#125; for(int i = 1; i &lt;= Size[k]; i ++) &#123; int v = Son[k][i]; if(v == fa) continue; Dfs(v , k); for(int j = p; j &gt;= 1; j --) &#123; for(int l = 1; l &lt; j; l ++) &#123; dp[k][j] = min(dp[k][j] , dp[k][j - l] + dp[v][l] - 2); &#125; &#125; &#125;&#125; int main()&#123; n = read() , p = read(); for(int i = 1; i &lt; n; i ++) &#123; int u = read() , v = read(); Son[u][++ Size[u]] = v; Son[v][++ Size[v]] = u; &#125; memset(dp , 0x3f , sizeof(dp)); for(int i = 1; i &lt;= n; i ++) dp[i][1] = Size[i]; Dfs(1 , 0); int ans = INT_MAX; for(int i = 1; i &lt;= n; i ++) ans = min(ans , dp[i][p]); printf("%d\n" , ans); return 0;&#125;]]></content>
      <tags>
        <tag>背包</tag>
        <tag>树形动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P1005Divisible]]></title>
    <url>%2Fblog%2F2021%2F08%2F25%2F%E9%A2%98%E8%A7%A3P1005Divisible%2F</url>
    <content type="text"><![CDATA[题目大意设$F[i]$为斐波那契数列的第$i$项，其中$F[1]=1,F[2]=1$。 给定$a,b$，判断$F[a]$能否整除$F[b]$,如果能输出1，否则输出0 思路先说结论，若$n|m$,则$F[n]|F[m]$。 证明： 首先 $F[n] = F[n-1]+F[n-2]$ $F[n] = 2F[n-2]+F[n-3]$ $F[n] = 3F[n-3] + 2F[n-4]$ …… $F[n] = F[m]F[n-m+1]+F[m-1][n-m]$ 先证$gcd(F[n],F[m])=F[gcd(n,m)]$ $gcd(F[n],F[m])$ = $gcd(F[m]F[n-m+1]+F[m-1]F[n-m],F[m])$ = $gcd(F[n-m],F[m])$ 一直递推下去可以得到$gcd(F[n],F[m])=F[gcd(n,m)]$ 再回到本题 若$F[n]|F[m]$,有$gcd(F[n],F[m])=F[n]$ 所以$gcd(n,m)=n$ 所以$n|m$]]></content>
      <tags>
        <tag>数学</tag>
        <tag>斐波那契</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群机器人食用指北]]></title>
    <url>%2Fblog%2F2020%2F02%2F09%2F%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97%2F</url>
    <content type="text"><![CDATA[Last updated:2020/04/101 萌化自定义插件简介：自动回复+一系列的拓展功能 命令： 1 翻译(语种) xxx 例：翻译英语你好 2 群号 返回群号 3 我 返回自己的QQ名 4 聊天系统（已禁用） 5 随机图片 返回一张图片 6 以图搜图 调用saucenaoAPI,返回与图片相似度&gt;=60%的图片 7 以图搜番 调用What a animeAPI,返回图片中的番剧 2 哔哩哔哩-up直播推送/视频下载/动漫聚合简介：哔哩哔哩助手 命令： 订阅列表 - 查看你订阅的up 订阅＋UID/名称 - UP新视频与直播推送 取消订阅＋UID/名称 - 取消订阅，机器人不再提醒 群订阅列表 - 查看本群订阅的订阅的up 群订阅＋UID/名称 - UP新视频与直播推送，机器人会在群内提醒 群取消订阅＋UID/名称 - 取消订阅，机器人不再提醒 新番 - 查看今天更新的新番 番剧列表 - 查看目前B站在连载的动画(此功能强制私聊回复) 追番列表 - 查看你订阅的番剧和番剧ID 追番＋番剧ID/名称 - 更新前一段时间，机器人会私聊提醒 取消追番＋番剧ID/名称 - 取消订阅，机器人不再提醒 群追番列表 - 查看本群订阅的番剧和番剧ID 群追番＋番剧ID/名称 - 更新前一段时间，机器人会在群内提醒 群取消追番＋番剧ID/名称 - 取消订阅，机器人不再提醒 av＋B站AV号- 查获取视频封面和相关信息 online - 看看大家大家都在看啥 追番转移＋自己的哔哩哔哩uid/自己的哔哩哔哩昵称 - 转移自己哔哩哔哩的追番列表到机器人 随便看看 - 看看我们推荐了啥~ 3 少看点二次元吧简介：一款ACG插件 命令： 1 番剧搜索+番剧名称 例：番剧搜索 某科学的超电磁炮（没给链接时多试几次） 2 搜索图片+图片 返回原图地址 3 搜索番剧+图片 返回图片中番剧 4 随机图片（需pro版） 5 b站排行榜 6 AV/BV自动解析 4 爱音乐简介：返回音乐 命令： 1 我想听XX/来首XX/点歌XX 5 小i机器人简介：小i机器人 命令： @聊天 6 百科搜索简介：百科 命令： 1 萌娘百科 XX 7百度百科简介：百度百科 命令： 1 百科 XX 8撤回查看简介：防撤回 命令： 1 查看撤回+X，查看从这条信息往上数的第X条信息，机器人信息不计入条数（需管理员权限） 9狼人杀简介：狼人杀（仅能开启一个群） 命令： 1 狼人杀加入 2 狼人杀退出 10Lxnet复读机简介：复读（随机复读，3条信息复读） 命令： 无 11文字象棋简介：象棋 命令： 象棋 返回帮助 12文字五子棋简介：五子棋 命令： 五子棋 返回帮助 13b站查询简介：查询b站个人信息 命令： 查询用户+用户名/UID 勋章包裹+用户名/UID 14FJT / CTNET 运势简介：仿照洛谷的运势系统 命令： @机器人+/运势 15简单的多功能骰子简介：多功能骰子 命令： .帮助 返回帮助 16Mr.five斗地主简介：斗地主 命令 命令列表 返回所有命令]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019CSP-J游记]]></title>
    <url>%2Fblog%2F2019%2F12%2F13%2F2019CSP-J%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[$Day-6$听说今年不能去福州玩狼人杀比赛了，在本市考，有点难受 机房颓颓颓，日常被神仙们虐 $Day-5$下午去东海一中参加模拟赛（密码是怀念NOIP），$t1t2$有点太水了，秒切。$t3t4$拿暴力分滚粗。 考场出来听一堆人讨论$t3t4$正解，心里慌得一匹。才发现$t3$正解就是在暴力（差分）的基础上加上一个离散化。。。我$dzm$了，$t4$正解线段树+$dp$?什么神仙操作。。。 最后$100+100+50+70=320$自闭了/kk $Day-4$~$Day-1$日常改题，颓废，被神仙们吊打，不用上文化课的感觉真好。 这几天晚上都在公安局吃饭，没想到牢饭公安局的饭还是挺好吃的。 吃完饭在小七的操场散散步，才发现小七竟有如此美丽的景色。傍晚的微风吹拂在脸颊上，望着操场上挥洒汗水的跑步者，与周围的好友开几个玩笑，一天的疲惫也随之而去。 以上均为想象 吃完饭偶尔去嘲讽一下还在上课的同学，真是快乐。 $Day0$明天就是$CSP$了，按照以往的惯例都会由初三大佬来给我这种蒟蒻分享心得，但是今年由于某些不可抗力因素比如wxn，导致初三参赛人数较少。所以今年就由我们这届来分享心得 传送门:蒟蒻的总结报告 | 在hexo博客上查看 讲的好紧张啊，感觉是讲的最烂的一个了/kk。 $Day1$今天就是$CSP$了！ 早上起来打了道大模拟，感觉良好（然后下午就爆零了） 来到一中，日常膜神仙。 进考场，打开一看——一脸懵逼 感觉$t1$越来越水了，秒切。到$9012$是不是$t1$出个输出$Hello,world!$? $t2$第一眼看跟海港貌似有点类似，于是开始打队列。结果发现审错题意了，推到重来，这次用了个手工队。一直怕时间复杂度是$O(N^2)$结果想想发现其实是$O(45N)$的。。。害我担心了这么久。 手打队列完，小数据都过了，到了大数据，答案不一样？！内心直接崩掉。 于是开始乱搞，吧手工队换成$stl$就过了？$stl$好啊！ 有了去年的经验，今年先开$t4$，考场发现了一个奇偶性质但是不知道怎么用，难受。只能拿$40$部分分滚粗。 $t3$一脸懵逼，$10$分特判滚粗。 预估$100+100+10+40=250$自闭了/kk 出考场后发现$t3t4$都是原题？？？（$CCF$是懒得出题了） $t3$是多次的完全背包，$t4$是根据奇偶性广搜，当场自闭。 $Few$ $Days$ $Later$在各个$OJ$上自测了,基本上都是在$250-260$之间，看来$250$实锤了。 $Day N$出成绩了，果然$100+100+10+40=250$，自闭/kk 分数线是$210$，终于拿了一次省一了(虽然现在好像叫评级？） 希望明年能取得更好的成绩吧 $the$ $end.$]]></content>
      <tags>
        <tag>游记</tag>
        <tag>CSP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P3115 【[USACO15JAN]牛路线Cow Routing】]]></title>
    <url>%2Fblog%2F2019%2F12%2F11%2F%E9%A2%98%E8%A7%A3-P3115-%E3%80%90-USACO15JAN-%E7%89%9B%E8%B7%AF%E7%BA%BFCow-Routing%E3%80%91%2F</url>
    <content type="text"><![CDATA[-1.前置知识最短路，图论 0.大体思路对每条航线进行建边处理，同时记录两个城市之间的城市数(这里题目中的经过多少城市指从$u$到$v$不包括首/尾的城市数)，然后跑$Dijkstra$即可 1.建边本题由于边数较多，采用邻接矩阵存图较为合适。 定义$cost[i][j]$表示从$i$到$j$的最少费用，$to[i][j]$表示在费用最少的情况下从$i$到$j$所经过的最少城市数 假设一条航线的费用是$money$,有$len$个城市，对应的编号分别为$x_{1},x_{2},···,x_{len}$ 首先要明确一个常识性问题：在一条航线上，一个城市不能飞到它之前的城市 所以我们可以得到一个显然的建边方法，对于一条航线的$x_{i}$，向$x_{j}(i&lt;j&lt;=len)$建一条长度为$money$的边。需要注意的是，如果之前$cost[i][j]$已赋值，则 如果$money&lt;cost[i][j]$，需要更新$cost[i][j],to[i][j]$ 如果$money=cost[i][j]$，则如果$i$到$j$之间的城市数$&lt;to[i][j]$，更新$to[i][j]$ 这样就可以满足在花费最少的情况下经过的城市数最少 2.Dijkstra定义$c[i]$为起点到$i$的最少花费，$ans[i]$为起点到$i$之间经过的城市数 假设当前从城市$k$开始拓展。 如果$k$与某个城市$i$有连边$cost[k][i]$，我们可以类比之前建边的方法进行更新。 如果$c[k]+cost[k][i]&lt;c[i]$，更新$c[i],ans[i]$ 如果$c[k]+cost[k][i]=c[i]$，如果$ans[k]+to[k][i]&lt;ans[i]$，更新$ans[i]$ 其中$ans[i]$的更新是指$ans[i]=ans[k]+to[k][i]$ 根据定义，$ans[i]$表示起点到$i$的城市数，$ans[k]$表示起点到$k$的城市数，$to[k][i]$表示$k$到$i$之间的城市数，所以很明显有$ans[i]=ans[k]+to[k][i]$ 3.Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;int read()//快读&#123; int sum = 0, f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = (sum &lt;&lt; 1) + (sum &lt;&lt; 3) + c - '0'; c = getchar(); &#125; return sum * f;&#125;int a, b, n, len, maxn;int cost[1010][1010], x[10010], to[1010][1010], money, ans[1010];unsigned long long c[1010];//别忘了开long longpriority_queue&lt;pair &lt;long long, int&gt; &gt; q;bool vis[1010];void Dijkstra()//堆优化Dij&#123; for(int i = 1; i &lt;= maxn; i++) c[i] = LONG_LONG_MAX; c[a] = 0; q.push(make_pair(0, a)); while(!q.empty()) &#123; int k = q.top().second; q.pop(); if(vis[k]) continue; vis[k] = 1; for(int i = 1; i &lt;= maxn; i++) if(cost[k][i] != 1e9 + 10)//有连边 &#123; if(c[i] &gt; c[k] + cost[k][i]) &#123; c[i] = c[k] + cost[k][i]; ans[i] = ans[k] + to[k][i]; q.push(make_pair(-c[i], i)); &#125; else &#123; if(c[i] == c[k] + cost[k][i]) &#123; if(ans[i] &gt; ans[k] + to[k][i]) ans[i] = ans[k] + to[k][i]; &#125; &#125; &#125; &#125;&#125;int main()&#123; for(int i = 1; i &lt;= 1010; i++) for(int j = 1; j &lt;= 1010; j++) cost[i][j] = 1e9 + 10;//赋初值 memset(to, 127, sizeof(to));//赋初值 a = read(), b = read(), n = read(); //建边 for(int i = 1; i &lt;= n; i++) &#123; money = read(), len = read(); for(int j = 1; j &lt;= len; j++) x[j] = read(), maxn = max(maxn, x[j]); for(int j = 1; j &lt;= len; j++) &#123; for(int k = j + 1; k &lt;= len; k++) &#123; if(cost[x[j]][x[k]] &gt; money) cost[x[j]][x[k]] = money, to[x[j]][x[k]] = k - j;//k-j就是j到k之间的城市数（不包含首尾） else if(cost[x[j]][x[k]] == money) &#123; if(k - j &lt; to[x[j]][x[k]]) &#123; to[x[j]][x[k]] = k - j; &#125; &#125; &#125; &#125; &#125; Dijkstra(); if(c[b] != LONG_LONG_MAX)//判断是否能到达 &#123; printf("%lld %d", c[b], ans[b]); &#125; else &#123; printf("-1 -1"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Manacher算法在OI中的应用&CSP赛前总结——by WKAHPM]]></title>
    <url>%2Fblog%2F2019%2F11%2F15%2F%E6%B5%85%E8%B0%88Manacher%E7%AE%97%E6%B3%95%E5%9C%A8OI%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-CSP%E8%B5%9B%E5%89%8D%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94by-WKAHPM%2F</url>
    <content type="text"><![CDATA[0.什么是Manacher Manachar算法主要是处理字符串中关于回文串的问题的，它可以在 O（n） 的时间处理出以字符串中每一个字符为中心的回文串半径——摘自百度百科 1.从暴力谈起先看一道例题洛谷P3805 题意十分简单明了，求一个字符串$S$中的最大回文子串长度 很容易想到一种$O(N^3)$算法，枚举子串的左边界$l$右边界$r$,判断该子串是否回文即可。 123for(int l = 0; l &lt; len; l ++) for(int r = l; r &lt; len; r ++) if(check(l , r)) ans = max(ans , r - l + 1); 在此算法上加入亿一点简单优化可以优化到$O(N^2)$,对于长度为奇数的回文字符串，回文子串的中心一定是某个字符，对于长度为偶数的回文字符串，回文子串的中心一定是两个字符之间的空隙，一种显然的作法是枚举这些回文中心，向两边拓展直到字符不相等或到达边界 由于$WKAHPM$比较懒,所以就不贴代码了。 暴力的缺点： 1.需要分类讨论 2.枚举了很多没用的子串 这时候我们就需要再加入亿一点优化。 2.Manacher的初始化 暴力的缺点——需要分类讨论 如何解决这个问题？一种作法是在每个字符之间再加入一个分隔字符（当然这个字符不能存在在原本的字符串中），举个栗子,比如字符串$ababac$： a b a b a c # a # b # a # b # a # c # 这个方法有效地避免了分类讨论，容易发现我们插入了$N+1$个#号，字符串的长度变为$2N+1$，为奇数，是不是很神奇呢 为了防止越界情况，我们在开头和结尾再加入一个字符，比如$@$，这部分的代码可以这么写 12345678910void news()&#123; s_new += "@#"; for(int i = 0;i &lt; s.size(); i++) &#123; s_new += s[i]; s_new += '#'; &#125; s_new += '@';&#125; 3.Manacher的原理 定义$p[i]$表示以$i$为对称中心能扩展的最大回文子串半径，即左/右边界到对称中心的距离。 $Manacher$的算法思想就是快速求出$p$数组。 我们来看看$p$数组与答案的关系(这里省略@) s # a # b # a # b # a # c # ans 0 1 0 3 0 5 0 3 0 1 0 1 0 p 1 2 1 4 1 6 1 4 1 2 1 2 1 显然有$ans[i]=p[i]-1$ 证明： 设回文子串$s$原来的长度为$len$，对称中心为$i$； 则$s$插入字符后的长度变为$2\times len+1$； 此时$p[i]=(2\times len+1+1)/2=len+1$,所以$p[i]-1$即为答案 所以求出$p[i]$就可以求出答案 4.Manacher的实现$Manacher$的实现用到了回文子串的一个性质——对称性 利用该性质可以有效地避免重复枚举，通过之前枚举过的子串来确定这个点至少能扩展的长度 设$mr$为之前找到的回文子串的最右边，$mid$为该回文子串的对称中心。 假设当前枚举到第$i$位，因为枚举过$mid$了，所以显然有$i&gt;mid$，接下来需要分类讨论两种情况来快速求出$p[i]$： 为了方便讨论，设$j$为$i$以$mid$为对称中心的对称点，$s_{i}$是以$i$为对称中心的回文子串，$s_{j}$是以$j$为对称中心的回文子串 (1)i &lt; mr这时候我们又能分2种情况 1 $s_{i}$的右边界不大于$mr$ 如图 由对称性知，此时$p[i]=p[j]$ 2 $s_{i}$的右边界大于$mr$ 如图 这时我们只能确定α段是具有对称性的，此时$p[i]=mr-i$ 也就是说，当$i$在$mr$左边，那么$p[i]$肯定是$mr-i$与$p[j]$的最小值。因为$j$与$i$关于$mid$对称，所以在$[i,mr]$这一段内可以直接使用$p[j]$的值，但是$i$已知的回文串长度不能到$mr$后面去，所以跟$mr-i$取$min$。 (2) i &gt;= mr此时我们无法通过对称性得到$p[i]$，所以$p[i]=1$ 代码实现如下： 123456789101112131415161718192021int Manacher()&#123; int mx=0; int maxn=-1; int id=0; for(int i=1;i&lt;s_new.size();i++) &#123; if(i&lt;mx)//情况1 ans[i]=min(ans[2*id-i],mx-i); else//情况2 ans[i]=1; while(s_new[i-ans[i]]==s_new[i+ans[i]]) ans[i]++;//扩展 if(mx&lt;i+ans[i])//更新右边界 &#123; id=i; mx=i+ans[i]; &#125; maxn=max(maxn,ans[i]-1);//更新答案 &#125; return maxn;&#125; 5.例题洛谷P5018对称二叉树 这题可以用$Manacher$来解决。 可以先用中序遍历对每个节点编号，利用$a$和$size$数组存放每个节点的权值和以这个节点为根节点的二叉树的节点数，对每个数组进行$Manacher$，将先后两次的以第$i$个点为对称中心的最大回文子串半径存放在$p1[i],p2[i]$中。 另外本题不需要初始化，$Manacher$初始化的原因是可能存在偶数长度的回文子串，但在对称二叉树中不可能存在偶数长度的回文子串，因为在对称二叉树中，除根节点以外每一个左儿子都有一个右儿子与之对应，所以节点数为奇数个。 求出$p1,p2$后，枚举编号$1$~$N$，判断以$i$为根节点的二叉树是否为对称二叉树，如果是则对$ans$和$size[i]$取$max$，对称二叉树需要满足两个条件： 1 权值对称 2 结构对称 体现在程序中就是$p1[i] \times 2 - 1 &gt;= size[i]$并且$p2[i] \times 2 - 1 == size[i]$ 首先解释一下为什么是$p1[i] \times 2 - 1$而不是$p1[i]-1$ $p1[i] \times 2 - 1$是因为之前的$Manacher$我们没有进行初始化，所以此时的$p1[i]$要乘2 接着解释一下为什么是$p1[i] \times 2 - 1 &gt;= size[i]$ 如图 如果写成$p1[i] \times 2 - 1 == size[i]$的话，则对于编号为$5$的节点，$p1[5] \ times 2 - 1 =5$,而$size[5]=3$，所以当节点权值相等时，可能出现$p1[i] \times 2 - 1 &gt; size[i]$的情况。 6.结语明天就是$CSP$了，大家调整好心态，多背背模板，基本上$t1t2$过了$t3t4$打一下暴力就省一了，祝各位$RP++$(这不是毒奶) 愿降临到你身边]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈OI中的骗分技巧——by WKAHPM]]></title>
    <url>%2Fblog%2F2019%2F10%2F21%2F%E6%B5%85%E8%B0%88OI%E4%B8%AD%E7%9A%84%E9%AA%97%E5%88%86%E2%80%94%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94by-WKAHPM%2F</url>
    <content type="text"><![CDATA[0.写在前面在NOIP$CSP$的考场上，很多题目我们在考场上往往无法想到正解（当然大佬除外）。这时候我们就需要一些骗分技巧来为自己争取一些部分分。 1.骗分的意义首先我们要了解什么是子任务。 对于一道题，它可能存在多个子任务。这些子任务的数据往往具有某些特点或者在某个小范围内，骗分的意义就是在打不出正解的情况下拿到这些子任务的分数。 例如$2018NOIP$ $T2$中的龙虎斗，它的子任务分布是这样的 【数据规模与约定】 $1 &lt; m &lt; n,1 ≤ p1 ≤ n.$ 对于$20$%的数据,$n = 3, m = 2, ci = 1, s1,s2 ≤ 100$. 另有$20$%的数据,$n ≤ 10, p1 = m, ci = 1, s1,s2 ≤ 100$. 对于$20$%的数据,$n = 3, m = 2, ci = 1,s1,s2 ≤ 100$. 对于$60$%的数据,$n ≤ 100, ci = 1,s1,s2 ≤ 100$. 对于$80$%的数据,$n ≤ 100, ci,s1,s2 ≤ 100$. 对于$100$%的数据,$n ≤ 10^5, ci = 1, s1,s2 ≤ 10^9$. 观察可以发现,$80$%的数据都很小，这时候我们就可以用暴力来拿到这$80$分。 2.基础的骗分1.输样例一道题目都会给你输入输出样例，如果你想不出其他解决该问题的方法，可以尝试直接输出样例，这就是考验你$rp$的时候了 例题：$2018NOIP$ $T4$对称二叉树 输出第二个样例即$3$可以拿到32分 没错就是这段代码可以为你拿到32分 1234567891011#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; //freopen("tree.in", "r", stdin); //freopen("tree.out", "w" ,stdout); cout &lt;&lt; 3; return 0;&#125; 当一道题目包含无解的情况时，也可以通过输出无解来获得部分分 2.输出随机数这个也是考验$rp$的，根据数据范围输出随机数。 随机数生成代码 123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; srand(time(0)); //随机种子 printf("%d" , rand()%b + a) //输出一个范围在a~a+b-1的随机数 return 0;&#125; 需要注意的是随机数的生成范围在不同操作系统下是不一样的，在Windows下是$0$~$32767$ 由于篇幅限制，基础的骗分技巧不再赘述。 3.高级骗分技巧1.打表很多人可能认为打表是最基础的骗分技巧，但是打表也是有艺术的。 打表的用处很多，例如 1 减小时间复杂度 2 找规律 3 ······ 先说说如何减小时间复杂度。 当一些题目数据范围很小时，我们可以考虑通过打表使程序运行效率提高，例如$2008NOIP$ $T3$传球游戏 这是我$90$分的程序 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int f[31][31],n,m;int dfs(int x,int y)&#123; if(f[x][y]) return f[x][y]; if(y==0) &#123; if(x==1)return f[x][y]=1; else return f[x][y]=0; &#125; if(x==n) &#123; return f[x][y]=dfs(x-1,y-1)+dfs(1,y-1); &#125; else if(x==1) return f[x][y]=dfs(n,y-1)+dfs(x+1,y-1); else return f[x][y]=dfs(x-1,y-1)+dfs(x+1,y-1);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); printf("%d",dfs(1,m)); return 0;&#125; 但是这个程序会被$10$ $29$这个数据给卡超时 这个时候加入打表就可以完美$AC$这道题 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int f[31][31],n,m;int dfs(int x,int y)&#123; if(f[x][y]) return f[x][y]; if(y==0) &#123; if(x==1)return f[x][y]=1; else return f[x][y]=0; &#125; if(x==n) &#123; return f[x][y]=dfs(x-1,y-1)+dfs(1,y-1); &#125; else if(x==1) return f[x][y]=dfs(n,y-1)+dfs(x+1,y-1); else return f[x][y]=dfs(x-1,y-1)+dfs(x+1,y-1);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); if(n==10&amp;&amp;m==29) &#123; cout&lt;&lt;0; return 0; &#125; printf("%d",dfs(1,m)); return 0;&#125; 这段程序比上一段程序多出来的部分就是 12345if(n==10&amp;&amp;m==29) &#123; cout&lt;&lt;0; return 0; &#125; 对于一些对素数判断存在要求的题目，我们可以预处理出素数表，减少判断的时间。 大致是这样的 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std; bool prime(long long num) //快速判断素数&#123; if (num == 2 || num == 3) &#123; return true; &#125; if (num % 6 != 1 &amp;&amp; num % 6 != 5) &#123; return false; &#125; for (int i = 5; i*i &lt;= num; i += 6) &#123; if (num % i == 0 || num % (i+2) == 0) &#123; return false; &#125; &#125; return true;&#125; int main()&#123; freopen("prime.out","w",stdout);//将表输出到文件里，方便复制 for(int i = 2; i &lt;= n; i ++) if(prime(i)) cout &lt;&lt; "i,"//加入逗号方便复制 return 0;&#125; 这时候将prime.out里的数字复制到表里就可以了 1Prime[LEN]=&#123;2,3,5,···&#125; 再来说说找规律。 对于一些题目，我们可以输出一些小数据的答案，观察答案与输入数据的关系，这种方法一般适用于数论题。 如$1999NOIP$ $T1$? Cantor表 可以通过行列和答案的关系找出某种规律。 打表的方式千变万化，所以有着”打表出省一”之说（笑），当然也不能过分依赖打表，造成思维惰性。 2.dfs如果你熟练掌握了$dfs$（深度优先搜索），你会发现“万物皆可搜”。 当一个题目打不出来怎么办？先打个$dfs$，可能这不是最优解，但是$dfs$思路清晰，码量小，可以拿到部分分。而且有时它也可以便于你想出正解。动态规划的思想有部分就来自于搜索。 例如$2018NOIP$ $T4$对称二叉树 如果你熟练掌握了二叉树的知识，你会很容易写出一个$dfs$，而$dfs$就是这道题目的正解。。。 所以万物皆可搜 万物皆可搜 万物皆可搜 3.灵活运用子任务的数据范围或数据特点数据范围往往不是无意义的，它存在的意义就是卡掉某些错解。 先上张图 数据范围对选择算法非常重要，算法的选择将会决定你是否能做出这道题。 根据子任务的数据范围，我们可以通过它来选择不同子任务用的算法。 如开头提到的龙虎斗，对于$80$分的数据$n&lt;=100$,用$O(n^2)$的算法是肯定不会超时的。所以可以这么写代码 12345678if(n &lt;= 100)&#123; ····//暴力代码&#125;if(n &gt; 100)&#123; ····//瞎搞&#125; 比如$2018NOIP$ $T3$摆渡车 对于$10$%的数据，满足$m=1$ 这时意味着每个人的等待时间都为0，所以 12345if(m == 1)&#123; cout &lt;&lt; 0 ; return 0;&#125; 就可以拿到10分 4.对拍在你写出骗分程序后，如果你所有题目都做完了且检验后，这时你就可以返回之前通过骗分做的题目，想一些正解。 还是以龙虎斗为例，在你打出一个可以满足$100$%数据范围的时间复杂度的程序后，你想检验它的正确性，这时候运用对拍可以十分方便地检验。 对拍模板： 1234567:loopshuju.exebaoli.exeshiyan.exefc fan.out fan1.outif %errorlevel%&#x3D;&#x3D;0 goto looppause 新建一个.txt文件，将上面的代码复制进去。再将后缀名改为.bat，文件名任意。 其中shuju.exe是你出数据的程序，shiyan.exe是你想的“正解”，baoli.exe是你打的暴力程序。 fan.out和fan1.out分别是你baoli和shiyan的输出文件。 这些东西需要放在同一个文件夹里，然后双击这个文件名.bat就可以开始愉快的对拍了。 5.例题1.最大连续和首先看到$10$%的数据所有数都是正数，这是只要把所有数加起来就是结果。 对于$30$%的数据，我们很容易可以写出一个暴力。 12345678910ans = a[1]; for(int i = 1; i &lt;= n; i ++) for(int j = i; j &lt;= n; j ++) &#123; int sum = 0; for(int k = i; k &lt;= j; k ++)&#123; sum += a[k]; &#125; ans = max(ans , sum); &#125; 对于$50$%的数据，在$30$%的程序基础上加入前缀和优化。 对于$80$%的数据，可以考虑进行二分（数据过水，在洛谷上被水过去了） 对于$100$%的数据，定义$dp[i]$为$1$~$i$的最大连续和。 对于$a[i]$，明显有两种选择，一种是取之前的最大连续和，一种是不取之前的最大连续和，以这个数为开头。 1dp[i] = max(a[i] , dp[i - 1] + a[i]); 2.$2017NOIP$ $T4$ 跳房子首先观察题目，发现题目中存在无解的情况，所以可以先加入特判是否存在答案。判断条件就是所有格子的最大和未超过$k$的话，输出无解。 接下来观察数据范围，发现$1,2$组数据$n$的范围较小，可以考虑$dfs$(见题目目录下1.cpp) 可以在该程序的基础上加上二分进行优化(见题目目录下2.cpp) 继续观察数据范围，发现前$5$组数据$n&lt;=500$，可以考虑用朴素$dp$求解 定义$dp[pos]$为从起点到$pos$格能获得的最大分数， 不难发现$dp[pos]$可以由某个格$i$跳$j$步到达 所以有方程$dp[pos]=max(dp[pos],dp[i]+s[i+j])$ 其中$0&lt;=i&lt;n,left&lt;=j&lt;=right,pos = i + j$，$left,right$分别是能跳的步数的左边界和右边界。时间复杂度$O(n^2)$（见题目目录下3.cpp） 这样本题就可以拿到$50$分了 如果想拿到满分需要加入单调队列优化$dp$，这里不再赘述（其实是我不会） 6.总结骗分是种艺术，在考场上灵活运用骗分技巧可以为你争取部分分。但是这并不意味着你不用去思考这道题目的正解，要知道思考正解远比想尽办法骗分更有意义。]]></content>
      <tags>
        <tag>CSP</tag>
        <tag>骗分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑如何进入pixiv]]></title>
    <url>%2Fblog%2F2019%2F10%2F10%2F%E7%94%B5%E8%84%91%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5pixiv%2F</url>
    <content type="text"><![CDATA[Pixiv，是一个主要由日本艺术家所组成的虚拟社群，主体为由pixiv股份制有限公司所运营的为插画艺术特化的社交网络服务网站。新兴的日本同人画、插画作品分享站点。采用了web2.0的方式，每个参与者都有自己的主页并可以对作品评价打分。——百度百科 当你想进入$pixiv$时，你可能遇到这种情况 一开始是进不去$pixiv$的（除非你挂了$VPN$） Step0.准备工作 pixiv-nginx 链接 提取码：apz7 Step1.解压文件将压缩包解压，把文件夹放在C盘 Step2.安装证书打开pixiv-nginx-1.15.3，双击ca.cer 点击安装证书 存储位置选择当前用户 选择将所有的证书都放入下列储存 选择受信任的根证书颁发机构 然后点击完成即可 Step3.修改hosts复制pixiv-nginx-1.15.3内的hosts到C:\Windows\System32\drivers\etc内替换原hosts Step4.开启Nginx到pixiv-nginx-1.15.3,打开4.可视化工具（这个操作简单） 打开后是如下界面 点Nginx后面的Start，看到打钩出现即为成功 接下来就可以打开pixiv了！ 每次上pixiv都要打开nginx，如果觉得麻烦可以运行pixiv-nginx-1.15.3下的nginx添加开机启动.bat 答疑：无法打开Nginx怎么办 1 确保你上面的步骤都正确 2 打开pixiv-nginx-1.15.3下的logs文件夹，打开error.log，复制里面的错误信息到度娘。 如果你的错误日志里的信息是类似 2019/10/02 09:06:17 [emerg] 6244#12448: bind() to 127.0.0.1:443 failed (10013: An attempt was made to access a socket in a way forbidden by its access permissions) 这样的，那么这个错误信息是指你的端口被占用了。占用的端口是443（看第一行127.0.0.1:443） 端口占用解决方案]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1578【奶牛浴场】]]></title>
    <url>%2Fblog%2F2019%2F10%2F08%2F%E9%A2%98%E8%A7%A3-P1578%E3%80%90%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA%E3%80%91%2F</url>
    <content type="text"><![CDATA[0.问题类型这是一道经典的最大子矩形问题，本人的思路参考了国家队wzk大佬的论文《浅谈用极大化思想解决最大子矩形问题》 这篇论文介绍了两种求最大子矩形的思路，分别是通过障碍点找子矩形和通过悬线找子矩形，本题的数据范围适合使用第一种方法 1.算法思路定义极大子矩形为$4$条边都不能向外拓展的有效子矩形（这里的有效即子矩形内不包括障碍点)。 可以得到最大子矩形是所有极大子矩形中最大的，所以只要枚举最大的子矩形，求出其中最大的即可 2.算法实现怎么找极大子矩形？根据极大子矩形的定义，我们可以得出极大子矩形的$4$条边一定覆盖障碍点（或边界） 为了方便讨论，我们先将整个牛场的4个顶点设为障碍点。 例如 10 10 4 1 1 3 4 6 3 9 8 1.从左往右搜将障碍点按横坐标排序（左右顺序）后得到如下编号。 (作者画画不是那么好qwq) 一开始从$1$号障碍点开始，从左往右找极大子矩形。 一开始的极大子矩形上下边界$up,low$为整个牛场的上下边界 $1$号障碍点往右找，到$2$号障碍点，如图 可以得到一个极大子矩形，它的面积就是障碍点$2$的横坐标减去障碍点$1$的横坐标乘以上边界减去下边界。 接下来需要对上下边界做一些修改，否则之后的极大子矩形可能会包括障碍点。因为$2$的纵坐标大于$1$的纵坐标，所以修改上边界，修改为$2$的纵坐标。 接下来到$3$，同理可以得到如下极大子矩形 它的面积就是$3$的横坐标减去$1$的横坐标乘以上边界（$2$的纵坐标）减去下边界 之后的$4$也同理。 然后从$2$开始往右找，从$3$开始往右找,从$4$开始往右找，跟从$1$开始找都是一样的。 2.从右往左搜从左往右搜后我们会发现有一些遗漏的情况，就是极大子矩形的左边界是牛场的左边界，右边界覆盖一个障碍点的情况，如图 解决方法很简单，把从左往右搜倒过来从右往左搜一遍即可 3.特殊情况在从左往右搜和从右往左搜后我们发现还有一种情况没有考虑到，就是极大子矩形的左右边界分别是牛场的左右边界，如图 解决方法是，再将障碍点按纵坐标排序，如图 可以得到这类极大子矩形的面积就是相邻两个障碍点（按纵坐标排序后）纵坐标之差乘以牛场的长 时间复杂度$O(N^2)$，$N$为障碍点数 3.代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;bits/stdc++.h&gt;using namespace std;int read()//快读&#123; int sum = 0 , f = 1; char c = getchar(); while(c &lt; '0' or c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' and c &lt;= '9') &#123; sum = (sum &lt;&lt; 1) + (sum &lt;&lt; 3) + c - '0'; c = getchar(); &#125; return sum * f;&#125;struct S&#123;//存放障碍点信息 int x , y;&#125;s[5010];bool cmp1(S a , S b)//按横坐标排序&#123; if(a.x != b.x) return a.x &lt; b.x; else return a.y &lt; b.y; &#125;bool cmp2(S a , S b)//按纵坐标排序&#123; if(a.y != b.y) return a.y &lt; b.y; else return a.x &lt; b.x ; &#125;int l , w , n , ans; int main()&#123; l = read() , w = read() , n = read(); for(int i = 1; i &lt;= n; i ++) s[i].x = read() , s[i].y = read(); s[++ n].x = 0 , s[n].y = 0;//将四个顶点设为障碍点 s[++ n].x = 0 , s[n].y = w; s[++ n].x = l , s[n].y = 0; s[++ n].x = l , s[n].y = w; int x1 , x2 , y1 , y2;//x1为左边界，x2为右边界,y1为下边界，y2为上边界 //从左往右搜 sort(s + 1 , s + n + 1 , cmp1); for(int i = 1; i &lt;= n; i ++) &#123; x1 = s[i].x , y1 = 0 , y2 = w; for(int j = i + 1; j &lt;= n; j ++) &#123; x2 = s[j].x; ans = max(ans , (x2 - x1) * (y2 - y1)); if(s[j].y &lt; s[i].y) y1 = max(y1 , s[j].y);//更新上下边界 else y2 = min(y2 , s[j].y); &#125; &#125; //从右往左搜 for(int i = n; i &gt;= 1; i --) &#123; x1 = s[i].x , y1 = 0 , y2 = w; for(int j = i - 1; j &gt;= 1; j --) &#123; x2 = s[j].x; ans = max(ans , (x1 - x2) * (y2 - y1)); if(s[j].y &lt; s[i].y) y1 = max(y1 , s[j].y); else y2 = min(y2 , s[j].y); &#125; &#125; //处理特殊情况 sort(s + 1 , s + n + 1 , cmp2); for(int i = 1; i &lt;= n - 1; i ++) &#123; ans = max(ans , l * (s[i + 1].y - s[i].y)); &#125; printf("%d" , ans); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划（dp）</tag>
        <tag>最大子矩形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[倍增LCA学习笔记]]></title>
    <url>%2Fblog%2F2019%2F10%2F06%2F%E5%80%8D%E5%A2%9ELCA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.什么是LCA LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。——百度百科 这么说可能不直观，我们通过一张图来理解一下 （图片来源百度百科） 在这棵树中，点$3$和点$6$的最近公共祖先是$2$，因为3的祖先是{1,2}，6的祖先是{4,2,1}。它们的公共祖先是{2,1}，而其中深度最大的是$2$ 2.怎么求LCA1.朴素算法了解了$LCA$的定义，不难得出一种暴力算法，即对于$u,v$两个点，我们让它们不断地一步一步往上跳，直到第一次相遇。 算法时间复杂度：$O(N)$ 2.倍增算法既然一步一步跳太慢，我们可以考虑设计一种倍增算法，让它一次跳$2^{0},2^{1},···.2^{n}$次方步。 算法流程：定义$fa[i][j]$为第$i$个点跳$2^{j}$步后达到的点，$deep[i]$为第$i$个点的深度。 1.建树，计算深度，预处理$fa[i][0]$这一部分可以用$dfs$实现 12345678910void dfs(int t , int father) //t表示当前点编号，father表示它的父亲结点编号&#123; deep[t] = deep[father] + 1;//深度是父亲深度+1 fa[t][0] = father;//t跳一步正好到father for(int i = head[t]; i ; i = edge[i].Next)//链式前向星 &#123; if(edge[i].to != father)//避免出现死循环 dfs(edge[i].to , t); &#125;&#125; 2.预处理$fa[i][j]$因为$2^{j}=2^{j-1}+2^{j-1}$，所以我们可以得到转移方程 $fa[i][j]=fa[fa[i][j-1]][j-1]$ 即先跳$2^{j-1}$到达$fa[i][j-1]$,再跳$2^{j-1}$步到达$fa[fa[i][j-1][j-1]]$ Code 12345678910void prework()&#123; for(int j = 1; j &lt;= 20; j ++)//为了保险开到2^20，一般超过2^20的数据都会超时了 &#123; for(int i = 1; i &lt;= n; i ++) &#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; &#125; &#125;&#125; 3.求$LCA$假设求$x,y$的$LCA$ 为了方便讨论，假设$deep[x]&gt;deep[y]$，即$x$的深度大于$y$的深度 先让$x$跳到与$y$同一深度，代码如下 1for(int i = 20; i &gt;= 0; i --) if(deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i];//只要x还比y深，就跳，否则不跳 如果这时候如果$x$已经等于$y$了，直接输出即可。 到达同一深度后，我们开始让$x,y$一起跳，注意这里我们要跳到的是它们$LCA$的下一层（因为我们跳到的是满足$x$和$y$不相等的最浅的一层，而它们的上层即为$LCA$）。 还是看最开始的例子，$3,6$,调整至同一高度后为$3,4$，，循环过后$x$和$y$的值并没有改变，因为我们跳到的是$LCA$的下一层。 代码如下 12for(int i = 20; i &gt;= 0; i --) if(fa[x][i] != fa[y][i]) x = fa[x][i] , y = fa[y][i];//如果它们跳2^i后不相等，那么肯定不是LCA的上面，所以跳 最后的答案就是$f[x][0]$了 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;bits/stdc++.h&gt;using namespace std;int n , m , s , cnt;int deep[500100];int fa[500010][31];struct G&#123; int to , Next;&#125;edge[1000010];int head[500010];void add(int from , int to)//建边&#123; edge[++ cnt].Next = head[from]; edge[cnt].to = to; head[from] = cnt;&#125;void dfs(int t , int father)//预处理深度&#123; deep[t] = deep[father] + 1; fa[t][0] = father; for(int i = head[t]; i ; i = edge[i].Next) &#123; if(edge[i].to != father) dfs(edge[i].to , t); &#125;&#125;void prework()//预处理fa数组&#123; for(int j = 1; j &lt;= 20; j ++) &#123; for(int i = 1; i &lt;= n; i ++) &#123; fa[i][j] = fa[fa[i][j - 1]][j - 1]; &#125; &#125;&#125;int query(int x , int y)//求LCA&#123; if(deep[x] &lt; deep[y]) swap(x , y);//令x的深度大于y的深度 for(int i = 20; i &gt;= 0; i --) if(deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i];//让x,y跳到同一深度 for(int i = 20; i &gt;= 0; i --) if(fa[x][i] != fa[y][i]) x = fa[x][i] , y = fa[y][i];//让x,y一起跳 if(x == y) return x; else return fa[x][0];&#125;int main()&#123;// ios::sync_with_stdio(false); scanf("%d%d%d" , &amp;n , &amp;m , &amp;s); for(int i = 1; i &lt;= n - 1; i ++) &#123; int x , y; scanf("%d%d" , &amp;x , &amp;y); add(y , x); add(x , y); &#125; dfs(s , 0); prework(); for(int i = 1; i &lt;= m; i ++) &#123; int a , b; scanf("%d%d" , &amp;a , &amp;b); printf("%d\n" , query(a , b)); &#125; return 0;&#125; 时间复杂度$O(logn)$ 4.一些思考为什么求LCA中$j$要从大到小枚举。 这个和天平称重时从大到小放砝码有点类似，举个例子，比如跳9步，如果按从小到大枚举是$1+2+4+8$,而$9 \ne1+2+4+8$,还需要回去重新找，而从大到小的话直接求出$9=8+1$ 5.例题P3379 【模板】最近公共祖先（LCA） 泉州市信息技术基地校OJ 密室逃脱]]></content>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
        <tag>倍增</tag>
        <tag>LCA,最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[康托展开学习笔记]]></title>
    <url>%2Fblog%2F2019%2F09%2F29%2F%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.什么是康托展开 康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。——摘自百度百科 简单来说，康托展开就是对于任意一个全排列，求一个自然数与它对应，即一个全排列到一个自然数的映射，这种映射是唯一的。 2.怎么实现康托展开公式$ X=\sum_{i=1}^n a_{i}(i-1)! $ 其中，$a_{i}$代表在这个排列中的第$i$个数后面有多少个数比它小。 这个公式求的是当前排列前面有多少个排列 例如，对于排列$14325$，它的康托展开是 $X=0\times(5-1)!+2\times(4-1)!+1\times(3-1)!+0\times(2-1)!+0\times(1-1)!=0+12+2+0+0=14$ 所以$14325$前面还有$14$个排列，所以$14325$是第$14+1=15$个排列 本蒟蒻对于这个公式的一些浅显理解:假设有一个排列$a_{1},a_{2},···,a_{n}$ 如果其满足$a_{1} &lt; a_{2}&lt;···&lt; a_{n}$,那么它是第一个排列。所以答案为$1$，计算公式之后不难发现公式正确 如果$a_{2},a_{3},···,a_{n}$中有比$a_{1}$小的数，以这些数为开头的排列必定在$a_{1}$为开头的排列前面，所以要加上这些排列数。确定了开头了之后，其后面还有$(n-1)$个数，可以构成$(n-1)!$种序列，所以公式第一项为比$a_{1}$小的数的个数乘以$(n-1)!$ 以此类推，可以得到该序列的排位。 代码实现123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 110;long long sum[N];int a[N] , n , Min[N];void fc(int n)//预处理阶乘&#123; sum[0] = 1; for(int i = 1; i &lt;= n - 1; i ++) sum[i] = i * sum[i - 1];&#125;void get(int pos)//预处理ai&#123; for(int i = pos + 1; i &lt;= n; i ++) if(a[i] &lt; a[pos]) Min[pos] ++;&#125;long long cantor()//康托展开&#123; long long ans = 0; for(int i = 1; i &lt;= n; i ++) ans += Min[i] * sum[n - i]; return ans; &#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; fc(n); for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= n; i ++) get(i); printf("%lld" , cantor() + 1); return 0;&#125; 3.逆康托展开知道了如何给定排列求序号，因为排列与序号一一对应，所以自然可以用序号求排列。 逆康托展开其实就是把康托展开反向计算。 假设字典序号为$pos$，共有$n$个数 首先用$pos\div(n-1)!$，余数自然就是$\sum_{i=2}^n a_{i}(n-i)! $,商就是 $a_{1}$ 如此反复，可求得$a_{1},a_{2},···,a_{n}$ 例如：给定$pos=15,n=5$，所以有$pos-1=14$个比它小的序列 $14\div(5-1)!=0······14,a_{1}=0$ $14\div(4-1)!=2······2,a_{2}=2$ $2\div(3-1)!=1······0,a_{3}=1$ $0\div(2-1)!=0······0,a_{4}=0$ $0\div(1-1)!=0,a_{5}=0$ 接下来，在$1,2,3,4,5$中，有$0$个比它小的数的数是$1$，所以第一位为$1$ 在$2,3,4,5$中，有$2$个比它小的数的数是$4$，所以第二位为$4$ 在$2,3,5$中，有$1$个比它小的数的数是$3$，所以第三位为$3$ 在$2,5$中，有$0$个比它小的数的数是$2$,所以第四位为$2$ 第五位为$5$ 综上，原序列为$14325$ 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 110;long long sum[N];int a[N] , n , pos , Min[N];bool use[N];void fc(int n)&#123; sum[0] = 1; for(int i = 1; i &lt;= n - 1; i ++) sum[i] = i * sum[i - 1];&#125;void recantor(int pos)&#123; for(int i = n - 1; i &gt;= 0; i --) &#123; int s = 0; Min[n - i] = pos / sum[i] , pos = pos % sum[i]; for(int j = 1; j &lt;= n; j ++) &#123; if(! use[j]) s ++; if(s == Min[n - i] + 1) &#123; a[n - i] = j; use[j] = 1; break; &#125; &#125; &#125; &#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; pos; fc(n); recantor(pos - 1); for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; a[i]; return 0;&#125; 4.例题P3014[USACO11FEB]牛线Cow Line P5367【模板】康托展开]]></content>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
        <tag>康托展开</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广州中山纪念中学游记]]></title>
    <url>%2Fblog%2F2019%2F07%2F14%2F%E5%B9%BF%E5%B7%9E%E4%B8%AD%E5%B1%B1%E7%BA%AA%E5%BF%B5%E4%B8%AD%E5%AD%A6%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[$Day 1$坐动车，去学校。顺便去腾讯公司上了个厕所 （这学校比我们学校大多了啊！！） 本来还想吃完晚饭颓狼人杀的，结果莫名其妙跟着老师去看机房，然后讲注意事项，OJ网址，接着莫名其妙地打了一晚上的题（我还要打狼人杀啊！） $Day 2$早上打模拟赛，被神仙们虐爆了，$100+80+30+60=270rk12$，我好菜啊$QwQ$ 第一题简单暴力模拟，第二题本来想暴力拆字符串结果爆空间了，还好拿了$80$，第三题写了一个自以为正确的贪心结果WAWA大哭了，第四题数位dp只能拿$60$暴力分（出题人良心！）了。 顺便膜一下我校大佬$lmk$，$100+100+100+70=370rk1$太强了！吊打我！ 然后讲题，改题。 顺便讲了一下数位dp，学完之后当晚肝了一题windy数，感觉良好 $Day 3$还是模拟赛，继续被神仙们狂虐，$50+20+0+20=90rk5$，太菜了吧$qwq$ 第一题被讲题人誉为本次比赛中最难的一题(那为什么还要放在第一题啊)，主要原因是题目很难理解(可以当阅读理解了吧（雾）)，但不知道为什么我暴搜骗了50，第二题讲题人言简意赅地点出了核心思想——乱搞，第三题是道dp但完全看不出来，第四题旁边的$gy$一直跟我说不是最小生成树，不是最小生成树，结果正解就是最小生成树+虚点连边。。。。。。 再次膜拜我校大佬$lmk$,$10+90+0+100=200rk1$魔鬼！ 最后发现第三题要用压位高精，不然会爆空间，不得不感叹一下出题人的毒瘤 $Day 4$今天没有模拟赛，甚好，去听了一早上的dp，然后下午一直在肝dp $Day 5$又是模拟赛，继续划水，$100+85+10+10=205rk12$菜死了。 第一题签到题简单模拟，第二题毒瘤数据制造者居然让dfs爆栈了，换成bfs才过，第三题数学题，可惜没看出答案是卡特兰数，而且还要加上高精，最后一题dp打了个暴搜水分。。。 话说某位老师居然参加了这场比赛而且居然没有AK（笑） 膜拜我校大佬$xzx$,$100+100+0+100=300rk2$（$rk1$老师）太可怕了。 $Day 6$一场异常简单的模拟赛，一堆神仙AK，然而我第一题爆零因为没特判换行符….，该死的OJ，该死的Linux。。。 $Day7$没有打比赛而是去听了一下堆，下午找了几题练练，感觉良好。。。 （priority_queue大法好啊） $Day8$又是被神仙们虐的一天，$100+0+37.5+12.5=150rk5$(希望这是我数学期末考的分数) 第一题数论，数据范围$O(\sqrt{n})$明显会TLE但竟然让我水过了！第二题二维离散化，又是什么神仙算法。。。第三题Floyd+匈牙利算法，第四题玄学算法（我也不知道我后面是怎么改对的） $Day 9$最后的一场比赛了，然而我还是考炸了，$20+0+0+92.3=112.3rk7$。 第一题还是恶心数论，不过这次数据只让我的$O(n)$拿了20qwq，第二题听说是状压dp（但我不会呀），第三题dp以为是贪心。。。第四题二分边界设错emmm，还是太粗心了$QwQ$ $Day 10$在纪中机房的最后一天了，老师为我们分享了他的OI心得，分别时还是有点不舍。 晚上放假，和大佬们一起去学校里的公园走了走，回到宿舍开始完成一直未能完成的事业——狼人杀，我们在晚上睡觉时间后跑到别的宿舍玩狼人杀与查房的斗智斗勇超刺激的 $Day 11$回家。 the end.是不可能的 吐槽区 不知道什么时候开始一到机房大家几乎都点开了slay.one或者2048 纪中的食堂的饭菜挺好吃的啊（每天中午第一行第三列孜然鸡腿（只有一天在第二行第四列）） fch老师经典语录：我会很烦躁的 直到倒数第2（3？）天我们才知道食堂有夜宵，而且是烧烤！然后一下课一堆人(包括我)像sb一样冲了出去（众所周知sb=smart boy） 听说纪中好像还是个5A级景区？？？ 舍监经典语录：你们待在纪中一天就是一天纪中人 / 有没有一点纪律观念时间观念 特意去买了一本纪中的草稿纸当纪念，下学期就用它了 fch老师OJ上的头像 一本通的编者之一宋老师竟然来给我们讲课了！而且讲的很好啊（宋老师：让学生听不懂才是一堂好课） 等我想到了再补吧······ 小小的总结第一次去外省培训，一次次被小学生和神仙们虐到自闭。菜死了的我深深地感受到了人外有人。被虐的同时我也学到了许多，数位dp,匈牙利算法,rmq问题,倍增求LCA······也收获了许多友谊。 在一天纪中，就做一天纪中人。有缘再见，纪中！ 最后引用fch老师的一句话 程序员之所以犯错误，不是因为他们不懂，而是因为他们自以为什么都懂。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF581B 【Luxurious Houses】]]></title>
    <url>%2Fblog%2F2019%2F06%2F24%2F%E9%A2%98%E8%A7%A3-CF581B-%E3%80%90Luxurious-Houses%E3%80%91%2F</url>
    <content type="text"><![CDATA[不难看出，题目要求的是每一个房子后面最高的房子与它的高度差$+1$，（如果比它矮输出$0$） 我们定义 $maxn[i]$表示第$i$到第$n$个房子高度的最大值（$n$为房子数） $h[i]$表示第$i$个房子的高度 因为$maxn[i+1]$存放的已经是第$i+1$到第$n$个房子的最大值了，所以第$i$到第$n$个房子的最大值只要让当前房子的高度与$maxn[i+1]$进行比较即可 即$maxn[i]=max(h[i],maxn[i+1])$ 代码如下 1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100010;int n;int h[MAXN] , maxn[MAXN];int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; h[i]; &#125; for(int i = n; i &gt;= 2; i --) maxn[i] = max(h[i] , maxn[i + 1]); //预处理最大值 for(int i = 1; i &lt;= n - 1; i ++) cout &lt;&lt; max(maxn[i + 1] - h[i] + 1 , 0) &lt;&lt; " ";//如果没比它高要输出0！ cout &lt;&lt; 0;//最后一个后面已经没有房子了当然是0 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>动态规划（dp）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1152A 【Neko Finds Grapes】]]></title>
    <url>%2Fblog%2F2019%2F05%2F19%2F%E9%A2%98%E8%A7%A3-CF1152A-%E3%80%90Neko-Finds-Grapes%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意： 给出两组数，求两组中的两数之和为奇数的组数（不可重复选取） 思路： 我们知道奇数+偶数=奇数 所以先统计两组中奇数出现的个数和偶数出现的个数 将第一组数中奇数出现的个数与第二组中偶数进行配对，即取$min(lenji1,lenou2)$ 再将将第一组数中偶数出现的个数与第二组中奇数进行配对，即取$min(lenou1,lenji2)$ 两个结果相加即可 Code 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int lenji1,lenji2,lenou1,lenou2;//分别表示第一组数中奇数个数、第二组数中奇数个数、第一组数中偶数个数、第二组中偶数个数int n,m;int a,b;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)//统计 &#123; cin&gt;&gt;a; a%2==1?lenji1++:lenou1++; &#125; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;b; b%2==1?lenji2++:lenou2++; &#125; cout&lt;&lt;min(lenji1,lenou2)+min(lenji2,lenou1);//取min相加 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>数论,数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF17A 【Noldbach problem】]]></title>
    <url>%2Fblog%2F2019%2F04%2F18%2F%E9%A2%98%E8%A7%A3-CF17A-%E3%80%90Noldbach-problem%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目要求的是一个素数与它相邻的素数之和$+1$为素数（注意这个素数要$\le n$） 思路： 预处理$2$~$n$的素数 暴力枚举 Code1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int p[1010],len,n,sum,k;bool prime(int num)//素数判断&#123; if(num&lt;2) return 0; if(num==2 or num==3) return 1; if(num%6!=5 and num%6!=1) return 0; for(int i=5;i*i&lt;=num;i+=6) &#123; if(num%i==0 or num%(i+2)==0) return 0; &#125; return 1;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;k; for(int i=2;i&lt;=n;i++)//预处理 &#123; if(prime(i)) p[++len]=i; &#125; for(int i=2;i&lt;=len;i++)//枚举 &#123; if(prime(p[i-1]+p[i]+1) and p[i-1]+p[i]+1&lt;=n) sum++; &#125; cout&lt;&lt;(sum&gt;=k?"YES":"NO");//相当于if(sum&gt;=k) cout&lt;&lt;"YES";else cout&lt;&lt;"NO"; return 0;&#125; 用时：$1024ms$ 我们可以在原来的程序做一些小小的优化 对枚举部分，我们加入一个边界条件 $p[i-1]+p[i] \le n$（$p[i]$为素数） Code1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int p[1010],len,n,sum,k;bool prime(int num)&#123; if(num&lt;2) return 0; if(num==2 or num==3) return 1; if(num%6!=5 and num%6!=1) return 0; for(int i=5;i*i&lt;=num;i+=6) &#123; if(num%i==0 or num%(i+2)==0) return 0; &#125; return 1;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;k; for(int i=2;i&lt;=n;i++) &#123; if(prime(i)) p[++len]=i; &#125; for(int i=2;i&lt;=len and p[i-1]+p[i]+1&lt;=n;i++)//边界条件 &#123; if(prime(p[i-1]+p[i]+1)) sum++; &#125; cout&lt;&lt;(sum&gt;=k?"YES":"NO"); return 0;&#125; 用时：$994ms$ （$emmm$才快了$30ms$）]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>数论,数学</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1133A 【Middle of the Contest】]]></title>
    <url>%2Fblog%2F2019%2F04%2F16%2F%E9%A2%98%E8%A7%A3-CF1133A-%E3%80%90Middle-of-the-Contest%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道字符串模拟题，思路如下： 1 输入时将两个时间存储 2 将两个时间化为以分钟做单位 3 得到中间时间与第一个时间的差 4 输出 注意：当时间或分钟数$&lt;=9$时，要用$0$补齐位数 Code 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;string s1,s2; int h1,h2,m1,m2;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;s1&gt;&gt;s2; for(int i=0;i&lt;2;i++)//将时间存储 h1+=(s1[i]-'0')*pow(10,1-i),h2+=(s2[i]-'0')*pow(10,1-i); for(int i=3;i&lt;=4;i++) m1+=(s1[i]-'0')*pow(10,4-i),m2+=(s2[i]-'0')*pow(10,4-i); int ans=((h2*60+m2)-(h1*60+m1))/2;//求得中间时间与第一个时间的差 h1+=ans/60;//加上时间差 m1+=ans%60; if(m1&gt;=60)//如果分钟&gt;=60要进位 &#123; h1++; m1%=60; &#125; if(h1&lt;=9)//输出，&lt;=9的用0补齐 cout&lt;&lt;0&lt;&lt;h1&lt;&lt;":"; else cout&lt;&lt;h1&lt;&lt;":"; if(m1&lt;=9) cout&lt;&lt;0&lt;&lt;m1; else cout&lt;&lt;m1; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些好用的网站]]></title>
    <url>%2Fblog%2F2019%2F04%2F14%2F%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Latex公式大全 Latex在线编辑器 函数图像绘制 OI Wiki 图论作图工具 数列查询网站 数学工具 画SAM 放大图片 数据结构与算法可视化 Virtual Judge BZOJ离线]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1118A 【Water Buying】]]></title>
    <url>%2Fblog%2F2019%2F04%2F11%2F%E9%A2%98%E8%A7%A3-CF1118A-%E3%80%90Water-Buying%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意： 你需要买$n$升水，现在有两种规格的水瓶：1升水的和2升水的，现给出1升水和2升水水瓶的单价，求最少需要花费多少钱。有$q$个询问。 思路：贪心 要使总花费最小，我们需要尽量多选取性价比高的规格。 Code123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int q;long long n,a,b;//注意要开long longint main()&#123; cin&gt;&gt;q; for(int i=1;i&lt;=q;i++) &#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; if(a*2&lt;=b)//买1升的性价比高于买2升的性价比 &#123; cout&lt;&lt;n*a&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;n/2*b+(n-n/2*2)*a&lt;&lt;endl;//题目要求的是刚好购买n升，所以不足2升的要买1升的补齐 &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1092B 【Teams Forming】]]></title>
    <url>%2Fblog%2F2019%2F04%2F10%2F%E9%A2%98%E8%A7%A3-CF1092B-%E3%80%90Teams-Forming%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题的基本思想就是贪心吧 题目就是让你两两分组，使得每组能力值的差值最小 设$a_{1},a_{2},···,a_{n}$表示每个学生的能力值 且满足：$a_{1} \le a_{2} \le ··· \le a_{n}$ 则对于任意一个能力值$a_{i}$，它的最优匹配为$a_{i+1}$（$i$为奇数） 考虑到$a_{1}$，我们不取$a_{i-1}$（你想想$a_{1-1}$是什么） 假设存在一个能力值$a_{k}$ ($k&gt; i+1$)，使得$a_{k}-a_{i}&lt; a_{i+1}-a_{i}$ 即: $a_{k}&lt;a_{i+1}$ ∵ $a_{i+1}&lt;a_{k}$ ∴ 不存在这样的$k$ Code1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110],ans; int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1);//要先排序 for(int i=1;i&lt;=n;i+=2) //i要为奇数 &#123; ans+=a[i+1]-a[i];//答案加上两个能力值的差 &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1145F 【Neat Words】]]></title>
    <url>%2Fblog%2F2019%2F04%2F08%2F%E9%A2%98%E8%A7%A3-CF1145F-%E3%80%90Neat-Words%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题其实是一道很水的字符串模拟，不要被难度骗了 CF恶意评分又不是一两天了（雾） 注意题目中说到的 由直线或都是由曲线构成的 是指该字母的笔画（我理解题目理解了半天$qwq$） 具体思路： 1 应用$map$将由直线（或者曲线）构成的字母的映射值设为1 2 计算该字符串的所有对应的映射值之和，因为题目要求全为直线或全为曲线，所以当总和为$len$($len$为字符串长度)或$0$时，输出$YES$，否则输出$NO$ Code1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;string s;map&lt;char,bool&gt; p;int main()&#123; ios::sync_with_stdio(false); p['A']=1;//打表 p['E']=1; p['F']=1; p['H']=1; p['I']=1; p['K']=1; p['L']=1; p['M']=1; p['N']=1; p['T']=1; p['V']=1; p['W']=1; p['X']=1; p['Y']=1; p['Z']=1; cin&gt;&gt;s; int sum=0; for(int i=0;i&lt;s.size();i++) sum+=p[s[i]];//统计映射值之和 if(sum==s.size() or sum==0) cout&lt;&lt;"YES";//判断 else cout&lt;&lt;"NO"; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1794 【装备运输_NOI导刊2010提高（04）】]]></title>
    <url>%2Fblog%2F2019%2F04%2F06%2F%E9%A2%98%E8%A7%A3-P1794-%E3%80%90%E8%A3%85%E5%A4%87%E8%BF%90%E8%BE%93-NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%EF%BC%8804%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道01背包模板题吧。。。其实就是再增加了一个体积参数 状态转移方程： $F_{j,k}=max(F_{j-v_{i},k-g_{i}}+t_{i},F_{j,k})$ Code 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int V,G,n;//V和G为最大体积和重量int t[510],v[510],g[510];int f[510][510];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;V&gt;&gt;G; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;t[i]&gt;&gt;v[i]&gt;&gt;g[i]; for(int i=1;i&lt;=n;i++) for(int j=V;j&gt;=v[i];j--) for(int k=G;k&gt;=g[i];k--) f[j][k]=max(f[j-v[i]][k-g[i]]+t[i],f[j][k]);//状态转移方程 cout&lt;&lt;f[V][G];//f[V][G]即为答案 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划（dp）</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1043A 【Elections】]]></title>
    <url>%2Fblog%2F2019%2F04%2F01%2F%E9%A2%98%E8%A7%A3-CF1043A-%E3%80%90Elections%E3%80%91%2F</url>
    <content type="text"><![CDATA[一看数据范围， $1 \le n \le 100 $，此时不枚举更待何时？（雾） 注意获胜是指小$A$的票数大于小$B$的票数，而不是大于等于。（原谅作者语文不好$qwq$） Code12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110];int sum1,sum2;bool comp(int a,int b)//自定义排序函数，从大到小排&#123; return a&gt;b;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum1+=a[i];//预处理小B的票数 sort(a+1,a+n+1,comp);//因为k&gt;=max&#123;ai&#125;，所以考虑先排序 for(int k=a[1];;k++) &#123; sum2=0;//一定要初始化！ for(int i=1;i&lt;=n;i++) sum2+=k-a[i];//每个人投给小A的票数就是每个人可以投的票数减去每个人投给小B的票数 if(sum2&gt;sum1)//是&gt;不是&gt;= &#123; cout&lt;&lt;k; return 0; &#125; &#125; return 0;&#125; 观察一下代码，我们发现可以在求小$A$的票数部分做一些小小的优化 观察可以发现，$sum2$=$\sum_{i=1}^{n}(k-a_{i})$ 原式 $=$ $k\times n-\sum_{i=1}^{n}a_{i}$ $=$ $k\times n-sum1$ 于是在求小$A$的票数部分可以优化到$O(1)$复杂度 Code1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110];int sum1,sum2;bool comp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum1+=a[i]; sort(a+1,a+n+1,comp); for(int k=a[1];;k++) &#123; sum2=k*n-sum1;//求小A的票数，当然你也可以不用再设一个变量直接比较 if(sum2&gt;sum1) &#123; cout&lt;&lt;k; return 0; &#125; &#125; return 0;&#125; 接下来我们再观察一下这个程序，我们发现，这个程序其实就要求最小的$k$，使得$k$满足$k\times n-sum1&gt;sum1$ 这不就是一个不等式吗 移项： $k\times n&gt;2\times sum1$ 系数化一: $k&gt;2\times sum1 /n$ 于是在求答案的部分就可以优化到$O(1)$复杂度 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110];int sum1;bool comp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum1+=a[i]; sort(a+1,a+n+1,comp); if(2*sum1/n+1&lt;a[1]) cout&lt;&lt;a[1];//因为k要&gt;=max a[i]，所以如果2*sum/n+1&lt;a[1]要输出a[1] else cout&lt;&lt;2*sum1/n+1; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set学习笔记]]></title>
    <url>%2Fblog%2F2019%2F03%2F31%2Fset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.什么是set 和 set的好处$set$的翻译为集合，是一个内部自动有序且不含重复元素(即满足集合的互异性)的$STL$容器，其内部采用“红黑树”实现。 什么是集合？点这 $set$的好处在于自动完成去重和按升序排序 2.举个栗子比如这题 1.普通作法看到数据范围这么水肯定想到用桶排 Code12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int b[1001],n,i,j,m=0,x; memset(b,0,sizeof(b)); cin&gt;&gt;n; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;x; if(b[x]==0) m++; b[x]++; &#125; cout&lt;&lt;m&lt;&lt;endl; for(i=0;i&lt;=1000;i++) if(b[i]&gt;0) cout&lt;&lt;i&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; 2.set如果你会了$set$，这道题就可以这么打 Code1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int n;set&lt;int&gt; st;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int x; scanf("%d",&amp;x); st.insert(x); &#125; printf("%d\n",st.size()); for(set&lt;int&gt;::iterator it= st.begin(); it!=st.end(); it++) &#123; printf("%d ",*it); &#125; return 0;&#125; 如果数据范围大了话，明显不能用桶排解决，这时候$set$的好处就可以体现出来。 领会了$set$的好处之后，接下来让我们了解 3.set的定义使用$set$之前，必须添加$set$头文件，即1#include&lt;set&gt;也可以打好我们的$bits/stdc++.h$ 同时必须要有 1using namespace std; 定义一个$set$的方法： 1set&lt;typename&gt; name; 其中$typename$为任何基本类型或者容器，$name$为这个集合的名字 同时$set$也支持定义数组，如: 1set&lt;typename&gt; name[MAXN] 即定义了$MAXN$个$set$容器 4.set的访问一大坑点是$set$只能通过迭代器访问 1.定义一个迭代器1set&lt;typename&gt;::iterator it; 即定义一个名为$it$的迭代器 2.通过迭代器访问注意事项： 1 $set$不支持类似*$(it+i)$的访问 2 $set$也不支持$it&lt;name.end()$这种访问 我们需要使用*$it$来访问$set$中的元素 5.set的常用函数1.insert()1.作用$insert()$用来插入一个数到$set$中，并自动排序+去重 2.时间复杂度$O(log_{2}n)$ 3.用法例如，以下一段代码输出$1$ $2$ $3 $ 123456for(int i=3;i&gt;=1;i--) a.insert(i);a.insert(1);for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" ";&#125; 2.begin()和end()1.作用分别用来获取$set$容器的首地址和尾地址 用法跟其他$STL$容器一样这里不再赘述 3.size()1.作用用于获取$set$容器中元素的个数 2.时间复杂度$O(1)$ 3.用法例如，以下一段代码输出$3$ 123for(int i=3;i&gt;=1;i--) a.insert(i);a.insert(1);cout&lt;&lt;a.size(); 4.clear()1.作用用于清空$set$容器中的所有元素 2.时间复杂度$O(n)$ ($n$为$set$中的元素个数) 3.用法例如，以下一段代码输出$1$ 1234for(int i=3;i&gt;=1;i--) a.insert(i);a.clear();a.insert(1);cout&lt;&lt;a.size(); 5.erase()1.作用可以用来删除单个元素也可以用来删除一段区间的元素 1.删除单个元素 1.时间复杂度$O(1)$ (使用迭代器) $O(log_{2}n)$ (使用欲删除元素的值) 2.用法1.$erase(it)$ $it$为欲删除的元素的迭代器 例如，以下一段代码输出$2$ $3$ 123456for(int i=3;i&gt;=1;i--) a.insert(i);a.erase(a.begin());for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" ";&#125; 2.$erase(value)$ $value$为欲删除元素的值 例如以下一段代码输出$1$ $3$ 123456for(int i=3;i&gt;=1;i--) a.insert(i);a.erase(2);for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" ";&#125; 2.删除一个区间的元素 1.时间复杂度$O(right-left)$ $(左闭右开区间[left,right))$ 2.用法$erase(left,right)$用来删除左闭右开区间[$left$,$right$)之间的元素 例如，以下一段代码输出$1$ 1234567for(int i=5;i&gt;=1;i--) a.insert(i);set&lt;int&gt;::iterator it=a.find(2);a.erase(it,a.end());for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" ";&#125; 6.find()1.作用返回元素在$set$中的迭代器 2.时间复杂度$O(log_{2}n)$ ($n$为$set$中的元素个数) 3.用法例如，以下一段代码输出$2$ 12for(int i=5;i&gt;=1;i--) a.insert(i);cout&lt;&lt;*a.find(2); 6.推荐例题 1 洛谷P1059 明明的随机数 之后还会继续放上]]></content>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1130A 【Be Positive】]]></title>
    <url>%2Fblog%2F2019%2F03%2F30%2F%E9%A2%98%E8%A7%A3-CF1130A-%E3%80%90Be-Positive%E3%80%91%2F</url>
    <content type="text"><![CDATA[一看数据范围： $-10^{3}\le d \le 10^{3}$，$1 \le n \le 100$ 这是让我们打表枚举的节奏啊（雾） 思路很简单，枚举每一个$d$，判断是否满足条件即可 Code12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110];int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=-1000;i&lt;=1000;i++) &#123; if(i==0) continue;//d不能为0 int sum=0; for(int j=1;j&lt;=n;j++) &#123; if(a[j]*i&gt;0) sum++;//a[i]/d与a[i]*d同正负 &#125; if(2*sum&gt;=n) //满足条件 &#123; cout&lt;&lt;i; return 0; &#125; &#125; cout&lt;&lt;0; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>CodeForces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A+B problem(高精)python]]></title>
    <url>%2Fblog%2F2019%2F03%2F27%2FA-B-problem-%E9%AB%98%E7%B2%BE-python%2F</url>
    <content type="text"><![CDATA[自带高精就是好呢，代码好简单/QwQ12345a=input()b=input()a=int(a)b=int(b)print(a+b)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF102A 【Clothes】]]></title>
    <url>%2Fblog%2F2019%2F03%2F27%2F%E9%A2%98%E8%A7%A3-CF102A-%E3%80%90Clothes%E3%80%91%2F</url>
    <content type="text"><![CDATA[本萌新来介绍一种$dfs$思路： 1 如果件数已经$=$3，那么判断，如果符合条件，则更新答案 2 如果件数$&lt;$3，那么枚举$1$~$n$,如果该件衣服没被取过，则标记为已取并$dfs$下一件 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std; int n,m,money[110],minx=INT_MAX;bool p[110][110],f,use[110];int s[5];bool comp()//判断是否符合条件&#123; if(p[s[1]][s[2]] and p[s[1]][s[3]] and p[s[2]][s[3]]) return 1; return 0;&#125;void dfs(int t,int sum)&#123; if(t&gt;3)//件数&gt;3判断 &#123; if(comp()) &#123; f=1;//标记为有方案 minx=min(minx,sum); &#125; return; &#125; for(int i=1;i&lt;=n;i++) &#123; if(!use[i])//该件衣服没被取过 &#123; s[t]=i;//保存答案编号用于之后判断 use[i]=1;//标记为已取 dfs(t+1,sum+money[i]); use[i]=0;//回溯 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;money[i]; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; p[x][y]=1;//建有向图 p[y][x]=1; &#125; dfs(1,0); if(f) cout&lt;&lt;minx; else cout&lt;&lt;"-1"; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>深度优先搜索（dfs）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string学习笔记]]></title>
    <url>%2Fblog%2F2019%2F03%2F24%2Fstring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.What’s string$string$ 是一种$STL$的容器，支持多种字符串操作。 2.string的定义使用$string$需要添加头文件 1#include&lt;string&gt; 或者打好万能库，胜过zhw 同时必须要有 1using namespace std; 定义$string$的方法非常简单，如下： 1string name;//name为字符串名称 同时也可以定义$string$数组，如下： 1string name[MAXN];//name为数组名，MAXN为数组大小 即这个数组中的每一个元素都是$string$类型 3.string初始化可以直接在定义的时候初始化，如： 1string name="I love C++!"; 等价于： 12string name;name="I love C++!"; 也可以写成： 1string name("I love C++!"); 4.string的访问1.通过下标访问12string s="I love C++!";printf("%c",s[0]);//输出I 2.通过迭代器访问1.迭代器的定义1string::iterator node;//定义一个名为node的迭代器 2.访问123string s="I love C++";string::iterator node=s.begin()//获取s的首地址printf("%c",*node);//输出I(因为是迭代器所以前面要加上*) 5.string的基本运算1.加法运算加法运算可以将两个字符串拼接在一起，但加号两边必须至少有一个为$string$类型 如，下列程序是合法的： 1234string s1="I love ";string s2="C++";s1+=s2;//等价于s1=s1+s2cout&lt;&lt;s1;//输出I love C++ 但下列程序是不合法的： 12string s1="I love "+"C++";cout&lt;&lt;s1&lt;&lt;endl; 下列程序依然合法： 123string s2="C";string s1="I love "+s2+"++";cout&lt;&lt;s1&lt;&lt;endl;//输出I love C++ 2.关系运算关系运算可以按字典序比较两个字符串的大小，如： 1234string s1="abcde";string s2="bcdef";if(s1&lt;s2) cout&lt;&lt;"Winner!";//输出Winner!else cout&lt;&lt;"Lose!"; 6.string的输入与输出1.利用cin和cout输入输出$cin$在读到空格时将会停止读入，例如以下一段程序输入$123$ $456$后，仅会输出$123$ 123string s;cin&gt;&gt;s;cout&lt;&lt;s; 2.利用getline输入$getline$可以用来读整行的字符串(包括空格)，例如以下一段程序输入$123$ $456$后，输出$123$ $456$ 123string s;getline(cin,s);cout&lt;&lt;s; 3.将string转换为字符数组输入输出$c$_$str()$可以将$string$转换为字符数组，如： 123string s;scanf("%s",s.c_str());printf("%s",s.c_str()); 输入$123$ $456$ 输出$123$ 7.string的常用函数1.length()和size()1.作用用来获取字符串的长度，即字符个数 2.时间复杂度$O(1)$ 3.用法123string s="abcd";int len=s.size();cout&lt;&lt;len;//输出4 2.begin()和end()1.作用分别用来获取字符串的首地址和尾地址，一般与迭代器配合使用 2.时间复杂度$O(1)$? 3.用法12345string s="I love C++!";for(string::iterator it=s.begin()+2;it!=s.end();it++)&#123; printf("%c",*it);//输出love C++! &#125; 3.clear()1.作用用来清空字符串中的所有元素 2.时间复杂度$O(1)$ 3.用法123string s="I love C++!";s.clear();cout&lt;&lt;s;//输出为空 4.substr()1.作用返回字符串的字串 2.时间复杂度$O(n)$ ($n$为字符串长度) 3.用法$s.substr(node,len)$返回从$node$位置开始，长度为$len$的字串 如： 12string s="I love C++!";cout&lt;&lt;s.substr(2,4);//输出love 5.insert()1.作用插入字符串 2.时间复杂度$O(n)$ ($n$为字符串长度) 3.用法$insert$有多种写法 1.$insert(node,s)$ 在$node$号位置插入字符串$s$ 123string s="I C++!";s.insert(2,"love");cout&lt;&lt;s;//输出I love C++! 2.$insert(node,s,sum)$ 在$node$号位置插入字符串$s$的前$sum$个字符 123string s="I C++!";s.insert(2,"love python",4);cout&lt;&lt;s;//输出I love C++! 3.$insert(it,it2,it3)$ $it$为原字符串的欲插入位置，$it1$,$it2$为待插入字符串的首尾迭代器(左闭右开) 1234string s="I C++!";string ss="love python";s.insert(s.begin()+2,ss.begin(),ss.begin()+4);cout&lt;&lt;s;//输出I love C++! 4.$insert(node,sum,c)$ 在$node$号位置插入$sum$个字符$c$ 123string s="I love C!";s.insert(8,2,'+');cout&lt;&lt;s;//输出I love C++! 6.erase()1.作用$erase()$可以删除单个字符或一个区间内的字符 2.时间复杂度$O(n)$ ($n$为字符串长度) 3.用法1.$erase(it)$ $it$为欲删除元素的迭代器 123string s="I love C+++!";s.erase(s.begin()+10);cout&lt;&lt;s;//输出I love C++! 2.$erase(left,right)$ $left$为区间的起始迭代器，$right$为区间末尾迭代器的下一个地址。左闭右开区间 123string s="I love C++++!";s.erase(s.begin()+10,s.begin()+12);cout&lt;&lt;s;//输出I love C++! 3.$erase(node,len)$ 删除从$node$号位置开始$len$个字符 123string s="I love C++++!";s.erase(10,2);cout&lt;&lt;s;//输出I love C++! 7.find()1.作用返回子串第一次出现的位置，如果找不到返回string::npos 2，时间复杂度$O(nm)$ $n,m$分别为第一个，第二个字符串的长度 3，用法1.$find(s)$，返回$s$在原字符串第一次出现的位置 123456789string s="I love C++!";if(s.find("C++")!=string::npos) cout&lt;&lt;s.find("C++")&lt;&lt;" ";else cout&lt;&lt;"-1"&lt;&lt;" ";if(s.find("python")!=string::npos) cout&lt;&lt;s.find("python")&lt;&lt;" ";else cout&lt;&lt;"-1"&lt;&lt;" ";//输出7 -1 2.$find(s,node)$ 返回原字符串从$node$号位置开始$s$第一次出现的位置 123456789string s="I love C++!";if(s.find("C++")!=string::npos) cout&lt;&lt;s.find("C++")&lt;&lt;endl;else cout&lt;&lt;"-1"&lt;&lt;endl;if(s.find("C++",8)!=string::npos) cout&lt;&lt;s.find("python")&lt;&lt;endl;else cout&lt;&lt;"-1"&lt;&lt;endl;//输出7 -1 8.replace()1.作用替换字符串 2.时间复杂度$O(n)$ ($n$为要替换的字符串长度) 3.用法1.$replace(node,len,s)$ 把原字符串从$node$号位置长度为$len$的子串替换为$s$ 12string s="I love python!";cout&lt;&lt;s.replace(7,6,"C++");//输出I love C++! 2.$replace(it1,it2,s)$ 表示把原字符串的迭代器$it1$~$it2$范围内(左闭右开区间)的子串替换为$s$ 12string s="I love python!";cout&lt;&lt;s.replace(s.begin()+7,s.begin()+13,"C++");//输出I love C++! 8.字符串数字互化可以用$sscanf$和$sprintf$实现 1234string s="19260817";int a;sscanf(s.c_str(),"%d",&amp;a);//把s以整数的形式输入到a(s要为字符数组)cout&lt;&lt;a;//输出19260817 1234int a=19260817;char s[30];sprintf(s,"%d",a);cout&lt;&lt;s;//输出19260817 同时我们也可以用一个神奇的东西——$stringstream$ 友情提示：这个东西十分耗时! 123456stringstream ss;string s="19260817";int n;ss&lt;&lt;s;//将s传入ssss&gt;&gt;n;//将ss传入ncout&lt;&lt;n;//输出19260817 如果要多次调用$stringstream$,记住在每一次使用前都要$clear()$ 9.推荐例题 1 猪国杀 2 洛谷P1308 统计单词数 思路点拨：运用$find$函数实现 3 洛谷P1079 Vigenère 密码 思路点拨：按照题意模拟即可]]></content>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5269 【欧稳欧再次学车】]]></title>
    <url>%2Fblog%2F2019%2F03%2F23%2F%E9%A2%98%E8%A7%A3-P5269-%E3%80%90%E6%AC%A7%E7%A8%B3%E6%AC%A7%E5%86%8D%E6%AC%A1%E5%AD%A6%E8%BD%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[三年OI一场空，不开long long 见祖宗 一道模拟题，具体解释在代码里： Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,l,r,x,k;long long dang,zhuan;//一定要开long long !!!long long ans;int main()&#123;// freopen("1.out","w",stdout); scanf("%d%d%d%d%d%d",&amp;t,&amp;n,&amp;l,&amp;r,&amp;x,&amp;k); zhuan=l;//zhuan存放转速 dang=1;//dang存放档位 int flag=0; for(int i=1;i&lt;=t;i++) &#123; int xx,yy; scanf("%d%d",&amp;xx,&amp;yy); if(xx==0)//升档 &#123; if(dang==n) //如果dang已经到达了n，那么是非法序列 &#123; cout&lt;&lt;"-1"; return 0; &#125; dang++; zhuan=l;//转速调整为l &#125; if(xx==1)//降档 &#123; if(dang==1) //如果dang是1，那么是非法序列 &#123; cout&lt;&lt;"-1"; return 0; &#125; dang--; zhuan=r;//转速调整为r &#125; if(yy==1)//踩油门 &#123; zhuan+=x;//转速加上x if(zhuan&gt;r) zhuan=r;//对r取min &#125; ans+=zhuan*dang //一定要在发动机有没有爆炸前加 if(zhuan==r) &#123; flag++; if(flag==k)//爆炸 &#123; cout&lt;&lt;ans; return 0; &#125; &#125; else flag=0; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解CF96A【Football】]]></title>
    <url>%2Fblog%2F2019%2F03%2F19%2F%E9%A2%98%E8%A7%A3CF96A%E3%80%90Football%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道字符串模拟，直接暴力枚举即可Code123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;string s;int main()&#123; cin &gt;&gt; s; for(int i = 0 ; i &lt; s.size(); i++) &#123; int ans = 1; char c = s[i]; for(int j = i + 1 ; j &lt; s.size(); j++) &#123; if(s[j] != c)//不一样直接退出 &#123; break; &#125; else &#123; ans++; &#125; if(ans == 7)//有七个一样的输出YES &#123; puts("YES"); return 0; &#125; &#125; &#125; puts("NO");//不危险输出NO return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷神帖]]></title>
    <url>%2Fblog%2F2019%2F03%2F11%2F%E6%B4%9B%E8%B0%B7%E7%A5%9E%E5%B8%96%2F</url>
    <content type="text"><![CDATA[1.炸出10几个管理员2.A+B problem3.洛谷新闻4.第一高楼5.举报CCF_NOI6.AK IOI7.Harry_Potter事件8.神仙打架]]></content>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树学习笔记]]></title>
    <url>%2Fblog%2F2019%2F03%2F11%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.线段树的作用 给定一个整数序列，让你完成如下操作 修改序列上某个位置（区间）上的数 询问序列中某个区间的和 “暴力”算法 单点修改$O(1)$ 询问区间和$O(区间长度)$ “前缀和”算法 单点修改$O(区间长度)$ 询问区间和$O(1)$ 线段树$O(nlogn)$ 2.线段树的概念 线段树是一棵二叉树，树上的每个结点对应序列的一段区间 3.线段树的操作1.结构体1234struct node&#123; int l,r,w,f;//l,r代表左，右端点，w代表这一段区间和，f是懒标记（懒标记在之后会提到）&#125;tree[4*n];//线段树要开到4倍的空间 2.建树基本思想： 1 二分 2 对于二分到的每一个结点，把左右端点的信息储存 3 叶结点输入 12345678910111213void build(int l,int r,int k)&#123; tree[k].l =l,tree[k].r =r; if(tree[k].l==tree[k].r)//叶子结点 &#123; scanf("%d",&amp;tree[k].w); return; &#125; int m=(l+r)/2; build(l,m,k*2);//左孩子 build(m+1,r,k*2+1);//右孩子 tree[k].w =tree[k*2].w +tree[k*2+1].w ;//合并&#125; 3.单点查询123456789101112void ask(int k)&#123; if(tree[k].l ==tree[k].r )//是目标结点 &#123; ans=tree[k].w ;//储存答案 return; &#125; if(tree[k].f ) down(k);//下传懒标记 int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) ask(k*2);//在左边递归左孩子 else ask(k*2+1);//在右边递归右孩子&#125; 4.单点修改12345678910111213void add(int k)&#123; if(tree[k].l ==tree[k].r )//是目标结点 &#123; tree[k].w +=y;//修改 return; &#125; if(tree[k].f ) down(k);//懒标记下传 int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) add(k*2);//在左边递归左孩子 else add(k*2+1);//在右边递归右孩子 tree[k].w =tree[k*2].w +tree[k*2+1].w ;//状态修改&#125; 5.区间求和123456789101112void sum(int k)&#123; if(tree[k].l &gt;=x&amp;&amp;tree[k].r &lt;=y)//左右端点全在目标区间内 &#123; ans+=tree[k].w ;//答案直接加上这一段区间和 return; &#125; if(tree[k].f ) down(k);//懒标记下传 int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) sum(k*2);//往左孩子移 if(y&gt;m) sum(k*2+1);//往右孩子移&#125; 6.区间修改在前面的操作中我们经常看到有懒标记下传这个操作，那么懒标记到底是什么呢 1.1懒标记的作用 存储到这个节点的更新信息，暂时不把更新信息传到子节点。 1.2懒标记的下传 1 将当前节点的懒标记累加到子节点的懒标记中 2 修改子节点状态，即区间和$w$=原状态+区间长度×父节点下传的懒标记 3 父节点懒标记清空 12345678void down(int k)&#123; tree[k*2].f +=tree[k].f ;//修改子节点懒标记(下同) tree[k*2+1].f +=tree[k].f ; tree[k*2].w +=tree[k].f *(tree[k*2].r -tree[k*2].l +1);//修改子节点状态(下同) tree[k*2+1].w +=tree[k].f *(tree[k*2+1].r -tree[k*2+1].l +1); tree[k].f =0;//懒标记清零&#125; 2.区间修改1234567891011121314void add2(int k)//y为增加的数，(a,b)为目标区间&#123; if(tree[k].l &gt;=a&amp;&amp;tree[k].r &lt;=b)//在目标左右端点内 &#123; tree[k].w +=(tree[k].r -tree[k].l +1)*y;//状态修改 tree[k].f +=y;//懒标记加上y return; &#125; if(tree[k].f) down(k);//懒标记下传 int m=(tree[k].l +tree[k].r )/2; if(a&lt;=m) add2(k*2);//如区间求和(下同) if(b&gt;m) add2(k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;//修改状态&#125; 4.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; long long l,r,w,f;&#125; tree[400001];long long ans,x,y,a,b,n,p,m;void build(int l,int r,int k)//建树 &#123; tree[k].l =l,tree[k].r =r; if(tree[k].l==tree[k].r) &#123; scanf("%lld",&amp;tree[k].w); return; &#125; int m=(l+r)/2; build(l,m,k*2); build(m+1,r,k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;&#125;void down(int k)//懒标记下传 &#123; tree[k*2].f +=tree[k].f ; tree[k*2+1].f +=tree[k].f ; tree[k*2].w +=tree[k].f *(tree[k*2].r -tree[k*2].l +1); tree[k*2+1].w +=tree[k].f *(tree[k*2+1].r -tree[k*2+1].l +1); tree[k].f =0;&#125;void ask(int k)//单点查询 &#123; if(tree[k].l ==tree[k].r ) &#123; ans=tree[k].w ; return; &#125; if(tree[k].f ) down(k); int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) ask(k*2); else ask(k*2+1);&#125;void add(int k)//单点修改加法 &#123; if(tree[k].l ==tree[k].r ) &#123; tree[k].w +=y; return; &#125; if(tree[k].f ) down(k); int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) add(k*2); else add(k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;&#125;void sum(int k)//区间求和 &#123; if(tree[k].l &gt;=x&amp;&amp;tree[k].r &lt;=y) &#123; ans+=tree[k].w ; return; &#125; if(tree[k].f ) down(k); int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) sum(k*2); if(y&gt;m) sum(k*2+1);&#125;void add2(int k)//区间修改加法 &#123; if(tree[k].l &gt;=a&amp;&amp;tree[k].r &lt;=b) &#123; tree[k].w +=(tree[k].r -tree[k].l +1)*y; tree[k].f +=y; return; &#125; if(tree[k].f) down(k); int m=(tree[k].l +tree[k].r )/2; if(a&lt;=m) add2(k*2); if(b&gt;m) add2(k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m);//n个数和m个操作 build(1,n,1);//建树 for(int i=1; i&lt;=m; i++) &#123; scanf("%lld",&amp;p); ans=0; switch(p) &#123; case 1:&#123;//1为单点查询 cin &gt;&gt; x; ask(1); printf("%lld\n",ans); break; &#125; case 2:&#123;//2为单点修改 cin &gt;&gt; x &gt;&gt; y; add(1); break; &#125; case 3:&#123;//3为区间求和 cin &gt;&gt; x &gt;&gt; y ; sum(1); printf("%lld\n",ans); break; &#125; case 4:&#123;//4为区间修改 cin &gt;&gt; a &gt;&gt; b &gt;&gt; y; add2(1); break; &#125; &#125; &#125; return 0;&#125; 5.推荐例题 1 洛谷P2068统计和 思路点拨：线段树模板 2 洛谷P3372【模板】线段树 1 思路点拨：线段树模板]]></content>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF32A 【Reconnaissance】]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-CF32A-%E3%80%90Reconnaissance%E3%80%91%2F</url>
    <content type="text"><![CDATA[一看到了求方案数，马上想到了枚举 $dfs$ 深搜思路：$dfs(t)$ ($t$为选了几个人) 1 如果已经选取了两个数，$ans$++并$return$ 2 枚举$1\sim n$ 如果第$a_{i}$个人没被选过且与前一个人身高差的绝对值不超过$d$，则标记为已选并$dfs(t+1)$ Code12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int n,d,a[1010],ans,s[1010];//s用来存前一个人的身高bool p[1010];//p用来标记已选过的人void dfs(int t)&#123; if(t&gt;2) &#123; ans++; return; &#125; for(int i=1; i&lt;=n; i++) &#123; s[0]=a[i];//s[0]需要设成a[i]，这样第一个人才能选 if(abs(a[i]-s[t-1])&lt;=d&amp;&amp;!p[i]) &#123; p[i]=1; s[t]=a[i];//记录前一个人的身高 dfs(t+1); p[i]=0;//回溯 &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;d); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;a[i]); &#125; dfs(1); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>深度优先搜索（dfs）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF25B 【Phone numbers】]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-CF25B-%E3%80%90Phone-numbers%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道字符串模拟题首先我们知道 偶数+偶数=偶数 偶数+奇数=奇数 然后我们就可以对$N$进行分类讨论： 当$N\le3$时，直接输出字符串即可 当$N=2k$ $(k\ge2)$时，可以把$N$拆分成若干个长度为2的字符串，在两个字符串之间添上-号 当$N=2k+1$ $(k\ge2)$时，可以把$N$拆分成一个长度为3的字符串和若干个长度为2的字符串，在两个字符串之间添上-号 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;string s;int sum;int n;int main()&#123; scanf("%d",&amp;n); cin&gt;&gt;s; if(n&lt;=3) //如果n&lt;=3，直接输出 &#123; cout&lt;&lt;s; return 0; &#125; if(n%2==0) //n为偶数则拆分成若干个长度为2的字符串 &#123; for(int i=0; i&lt;n; i++) &#123; sum++; printf("%c",s[i]); if(i==n-1) return 0; if(sum==2) &#123; printf("-"); sum=0; &#125; &#125; &#125; else //n为奇数则拆分成一个长度为3的字符串和若干个长度为2的字符串 &#123; for(int i=0; i&lt;3; i++) &#123; printf("%c",s[i]); &#125; printf("-"); for(int i=3; i&lt;n; i++) &#123; sum++; printf("%c",s[i]); if(i==n-1) return 0; if(sum==2) &#123; printf("-"); sum=0; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT3523 【OddString】]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-AT3523-%E3%80%90OddString%E3%80%91%2F</url>
    <content type="text"><![CDATA[如题，输出奇数位上的字母即可AC 注意字符串下标是从0开始的！ Code12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;char s[100010];int main()&#123; gets(s); for(int i=0;i&lt;strlen(s);i+=2)//输出奇数位 &#123; printf("%c",s[i]); &#125; printf("\n");//记得换行 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT2201 【鏡文 / Mirror String】]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-AT2201-%E3%80%90%E9%8F%A1%E6%96%87-Mirror-String%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道简单的字符串模拟，刷难度真给力 本蒟蒻的思路比较麻烦，但个人认为比较好理解 1 先将字符串倒序存放 2 按照规则改变字母 3 比较 Code：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;char s1[100010],s2[100010];int len;int main()&#123; cin&gt;&gt;s1; for(int i=strlen(s1)-1; i&gt;=0; i--) &#123; s2[len++]=s1[i];//倒序存放 &#125; for(int i=0; i&lt;strlen(s2); i++) &#123; switch(s2[i])//按照规则改变字母 &#123; case 'b': &#123; s2[i]='d'; break; &#125; case 'd': &#123; s2[i]='b'; break; &#125; case 'p': &#123; s2[i]='q'; break; &#125; case 'q': &#123; s2[i]='p'; break; &#125; &#125; &#125; if(strcmp(s1,s2)==0) cout&lt;&lt;"Yes"&lt;&lt;endl;//比较，注意如果两个字符串一样，strcmp返回0 else cout&lt;&lt;"No"&lt;&lt;endl;//记得换行 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>字符串</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解CF45I【TCMCF+++】]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3CF45I%E3%80%90TCMCF-%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意：给你$N$个整数，让你从中选$r$个数($0&lt;r \leq N$)，使得它们的乘积最大。输出任意一组解 思路：（大佬勿喷） 1 我们知道几个正整数的乘积总是正数，所以遇到正整数直接输出就好啦 2 遇到负数就不同了，我们知道“奇负偶正”，于是就有两种情况： 1 如果有偶数个负数，因为“偶正”，所以全部输出 2 如果有奇数个负数，我们只能输出个数-1个负数，并且这些负数的绝对值最大 3 接下来还需要三个特判 特判1：如果$N=1$并且这个数小于等于0，输出这个数 特判2：如果$N$（$N&gt;1$）个整数全是0，输出0 特判3：如果$N$（$N&gt;1$）个整数中全是非正数（只有0和负数），如果只有1个负数并且0的个数不为0，输出0（因为0比负数大） 4 然后。。。你就AC了 code123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[110],sum1=0,sum2=0;//sum1统计0的个数，sum2统计负数的个数int main()&#123; scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;a[i]); if(a[i]&lt;0) sum2++;//a[i]是负数，sum2++ else if(a[i]==0) sum1++;//a[i]是0，sum1++ else printf("%d ",a[i]);//a[i]是正数，输出！ &#125; sort(a+1,a+n+1);//因为要取绝对值最大的负数，所以先排序 if(sum2%2==0)//偶数个负数全部输出 &#123; for(int i=1; i&lt;=sum2; i++) &#123; printf("%d ",a[i]); &#125; &#125; else//奇数个负数输出个数-1个 &#123; for(int i=1;i&lt;=sum2-1;i++) &#123; printf("%d ",a[i]); &#125; &#125; if(n==1&amp;&amp;a[1]&lt;=0) &#123; cout&lt;&lt;a[1]; return 0; &#125; if(sum1==n) cout&lt;&lt;0;//全是0 if(sum1+sum2==n&amp;&amp;sum2==1) cout&lt;&lt;0;//全是负数和0且负数只有一个 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解CF545D【Queue】]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3CF545D%E3%80%90Queue%E3%80%91%2F</url>
    <content type="text"><![CDATA[这道题基本思路就是贪心（标签里的队列是什么鬼不会是因为标题叫队列吧）主要还是证明贪心的正确性(大佬勿喷) 设总等待时间为 $time$ , $n$个人等待时间分别为$t_{1}$,$t_{2}$,$t_{3}$···$t_{n}$,要使总等待人数最少,则$time$ 要取最小值: $time$ = $t_{1}$+($t_{1}$+$t_{2}$)+($t_{1}$+$t_{2}$+$t_{3}$)+···+($t_{1}$+$t_{2}$+$t_{3}$+···$t_{n}$) $time$ = $n \cdot t_{1}$+ $(n-1)\cdot t_{2}$+ ··· + $t_{n}$ 当$t_{1} \le $ $t_{2} \le$ ······ $t_{n}$ 时，$time$为最小值(简单的证明过程) —————————————————————————————————————————— 所以只要先每个人的等待时间排序一遍，设定一个总时间变量$time$,只要$time$小 于这个人的等待时间答案就+1，同时$time$也要加上这个人的等待时间 代码 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n,t[100010],sum,ti;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;t[i]); sort(t+1,t+n+1);//排序（从小到大) for(int i=1;i&lt;=n;i++) &#123; if(t[i]&gt;=ti)//如果time&lt;这个人等待时间 &#123; sum++;//答案+1 ti+=t[i];//time加上这个人的等待时间 &#125; &#125; printf("%d",sum); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P1049【装箱问题】]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3P1049%E3%80%90%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到好多大佬都用动规，这题数据范围太水了(n&lt;=30)于是本蒟蒻先来发篇dfs深搜思路： 把n个物品两种可能（取与不取）都搜一遍，得到的最小体积就是答案 具体解释看代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int v,n,w[40],minx=INT_MAX;//minx存放最小体积，初始赋最大值void dfs(int volume,int pointer)//volume代表当前体积//pointer指示第pointer个物品&#123; if(volume&lt;0) return;//首先需要判断如果体积&lt;0就退出 if(pointer&gt;n)//如果n个物品都搜过了 &#123; if(volume&lt;minx)//判断当前体积是否小于最小体积 minx=volume;//是的话更新最小体积 return; &#125; if(volume==0)//小小的剪枝，如果当前体积已经为0了，那么不可能有更优解 &#123; minx=0; return; &#125; dfs(volume-w[pointer],pointer+1);//取该件物品 dfs(volume,pointer+1);//不取该件物品&#125;int main()&#123; scanf("%d%d",&amp;v,&amp;n); for(int i=1; i&lt;=n; i++) scanf("%d",&amp;w[i]); dfs(v,1); printf("%d",minx);//minx存放的即为答案 return 0;&#125; 但是如果数据范围加大了话。。。其实本题就是把0-1背包中物品的价值与体积画了个等号，于是本题就变成了一道0-1 背包模板题 代码如下：12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int w[31],f[20010];int main()&#123; int v,n; scanf("%d%d",&amp;v,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=n;i++) for(int j=v;j&gt;=w[i];j--) if(f[j]&lt;f[j-w[i]]+w[i]) f[j]=f[j-w[i]]+w[i];//状态转移方程 printf("%d",v-f[v]);//最后用体积减去最优解 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>深度优先搜索（dfs）</tag>
        <tag>动态规划（dp）</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P1451【求细胞数量】]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3P1451%E3%80%90%E6%B1%82%E7%BB%86%E8%83%9E%E6%95%B0%E9%87%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道可以用dfs做的题目（大佬勿喷）总体思路如下： 1 用一个bool数组存放每个位置是否为细胞数字 2 输入，如果这个数大于0，把这个位置标记为1 3 枚举每一个位置，如果是细胞数字就开始搜，同时答案加1 4 输出 深搜部分： 1 把这个位置标记为0 2 枚举四个方向，如果是细胞数字就从这个位置继续搜 （就是把所有连通的细胞数字都标记为0，周围再也没有细胞数字了就代表一个细胞） 代码如下：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,sum;char s;bool p[110][110];int a[4]=&#123;1,-1,0,0&#125;;//四个方向int b[4]=&#123;0,0,-1,1&#125;;void dfs(int x,int y) &#123; p[x][y]=0;//把这个位置标记为0 for(int i=0;i&lt;4;i++) &#123; int xx=x+a[i]; int yy=y+b[i]; if(p[xx][yy])//如果这个位置是细胞数字，从这个位置开始搜 dfs(xx,yy); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;s; if(s&gt;'0') p[i][j]=1;//是细胞数字标记为1 &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; if(p[i][j])//如果是细胞数字开始搜 &#123; sum++; dfs(i,j); &#125; &#125; printf("%d",sum); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>深度优先搜索（dfs）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[我才不会告诉你这篇文章是用来测验$LaTeX$的 $Day $ $0$告别期中考，来到福州，与机房的各位大佬去试了一下机，回来的时候互奶着哪位大佬要 $AK$了， 哪位大佬要省一了，晚上不务正业地玩着狼人杀，似乎忘记了此行的目的。 $Day$ $1$早上很早地就起来看一本通了，在宾馆颓了一早上，到了要比赛时才匆匆忙忙地背了一下$DP$ 方程 进入考场，先用了5$min$看了一遍所有题目，发现不简单 先看了一下$T1$，一道十分简单的字符串模拟，花了5$min$就敲完了，怕有坑不知道看了几遍题面。。。 看了一下$T2$，题目叙述比较长，于是先去看了看$T3$，想了一会儿觉得是贪心，于是打了个贪心调了挺久的，把两个小样例过了再去看大样例，发现答案比正确答案少了很多，于是想了很多方法，最终还是没想出来。 又回过头去看$T2$,理解完题面意思后发现是一道模拟，下意识写了个$O(N^{2})$的暴力，发现大数据会卡，脑抽没发现$O(n)$的算法，又去调了一会$T3$ 最后30$min$去看了一眼$T4$，发现是二叉树，但是没学过，直接输出0想骗些分 比赛结束，预计得分:$100+80+30+10=220$ 赛后去你谷测了一下民间数据，发现得分比预期的高，$100+80+30+20=230$ 用老师的数据也测了一下，$210$也还好 最后CCF的官方成绩出来了，发现才$100+80+10+4=194$分，原来$T3$的正解是$DP$，发现如果在原来的贪心上再改动一点应该可以过更多的数据的 最后$FJ$的分数线出来了——$195$，$194$的我当场崩溃$QwQ$ 第一次参加$NOIP$就带着差一分省一的遗憾结束了，不过反正我才初一还有很多机会对吧]]></content>
      <tags>
        <tag>游记</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A+B problem]]></title>
    <url>%2Fblog%2F2019%2F03%2F09%2FA-B-problem%2F</url>
    <content type="text"><![CDATA[纪念博客的诞生QwQ123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a+b; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
