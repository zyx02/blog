<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解 CF1152A 【Neko Finds Grapes】]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%A2%98%E8%A7%A3-CF1152A-%E3%80%90Neko-Finds-Grapes%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意： 给出两组数，求两组中的两数之和为奇数的组数（不可重复选取） 思路： 我们知道奇数+偶数=奇数 所以先统计两组中奇数出现的个数和偶数出现的个数 将第一组数中奇数出现的个数与第二组中偶数进行配对，即取$min(lenji1,lenou2)$ 再将将第一组数中偶数出现的个数与第二组中奇数进行配对，即取$min(lenou1,lenji2)$ 两个结果相加即可 Code 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;int lenji1,lenji2,lenou1,lenou2;//分别表示第一组数中奇数个数、第二组数中奇数个数、第一组数中偶数个数、第二组中偶数个数int n,m;int a,b;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)//统计 &#123; cin&gt;&gt;a; a%2==1?lenji1++:lenou1++; &#125; for(int i=1;i&lt;=m;i++) &#123; cin&gt;&gt;b; b%2==1?lenji2++:lenou2++; &#125; cout&lt;&lt;min(lenji1,lenou2)+min(lenji2,lenou1);//取min相加 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>数论,数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF17A 【Noldbach problem】]]></title>
    <url>%2F2019%2F04%2F18%2F%E9%A2%98%E8%A7%A3-CF17A-%E3%80%90Noldbach-problem%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目要求的是一个素数与它相邻的素数之和$+1$为素数（注意这个素数要$\le n$） 思路： 预处理$2$~$n$的素数 暴力枚举 Code1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int p[1010],len,n,sum,k;bool prime(int num)//素数判断&#123; if(num&lt;2) return 0; if(num==2 or num==3) return 1; if(num%6!=5 and num%6!=1) return 0; for(int i=5;i*i&lt;=num;i+=6) &#123; if(num%i==0 or num%(i+2)==0) return 0; &#125; return 1;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;k; for(int i=2;i&lt;=n;i++)//预处理 &#123; if(prime(i)) p[++len]=i; &#125; for(int i=2;i&lt;=len;i++)//枚举 &#123; if(prime(p[i-1]+p[i]+1) and p[i-1]+p[i]+1&lt;=n) sum++; &#125; cout&lt;&lt;(sum&gt;=k?"YES":"NO");//相当于if(sum&gt;=k) cout&lt;&lt;"YES";else cout&lt;&lt;"NO"; return 0;&#125; 用时：$1024ms$ 我们可以在原来的程序做一些小小的优化 对枚举部分，我们加入一个边界条件 $p[i-1]+p[i] \le n$（$p[i]$为素数） Code1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;int p[1010],len,n,sum,k;bool prime(int num)&#123; if(num&lt;2) return 0; if(num==2 or num==3) return 1; if(num%6!=5 and num%6!=1) return 0; for(int i=5;i*i&lt;=num;i+=6) &#123; if(num%i==0 or num%(i+2)==0) return 0; &#125; return 1;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n&gt;&gt;k; for(int i=2;i&lt;=n;i++) &#123; if(prime(i)) p[++len]=i; &#125; for(int i=2;i&lt;=len and p[i-1]+p[i]+1&lt;=n;i++)//边界条件 &#123; if(prime(p[i-1]+p[i]+1)) sum++; &#125; cout&lt;&lt;(sum&gt;=k?"YES":"NO"); return 0;&#125; 用时：$994ms$ （$emmm$才快了$30ms$）]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>数论,数学</tag>
        <tag>素数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1133A 【Middle of the Contest】]]></title>
    <url>%2F2019%2F04%2F16%2F%E9%A2%98%E8%A7%A3-CF1133A-%E3%80%90Middle-of-the-Contest%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道字符串模拟题，思路如下： 1 输入时将两个时间存储 2 将两个时间化为以分钟做单位 3 得到中间时间与第一个时间的差 4 输出 注意：当时间或分钟数$&lt;=9$时，要用$0$补齐位数 Code 123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;string s1,s2; int h1,h2,m1,m2;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;s1&gt;&gt;s2; for(int i=0;i&lt;2;i++)//将时间存储 h1+=(s1[i]-'0')*pow(10,1-i),h2+=(s2[i]-'0')*pow(10,1-i); for(int i=3;i&lt;=4;i++) m1+=(s1[i]-'0')*pow(10,4-i),m2+=(s2[i]-'0')*pow(10,4-i); int ans=((h2*60+m2)-(h1*60+m1))/2;//求得中间时间与第一个时间的差 h1+=ans/60;//加上时间差 m1+=ans%60; if(m1&gt;=60)//如果分钟&gt;=60要进位 &#123; h1++; m1%=60; &#125; if(h1&lt;=9)//输出，&lt;=9的用0补齐 cout&lt;&lt;0&lt;&lt;h1&lt;&lt;":"; else cout&lt;&lt;h1&lt;&lt;":"; if(m1&lt;=9) cout&lt;&lt;0&lt;&lt;m1; else cout&lt;&lt;m1; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些好用的网站]]></title>
    <url>%2F2019%2F04%2F14%2F%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Latex公式大全 Latex在线编辑器 函数图像绘制 OI Wiki 图论作图工具 数列查询网站 数学工具 画SAM 放大图片 数据结构与算法可视化]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1118A 【Water Buying】]]></title>
    <url>%2F2019%2F04%2F11%2F%E9%A2%98%E8%A7%A3-CF1118A-%E3%80%90Water-Buying%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意： 你需要买$n$升水，现在有两种规格的水瓶：1升水的和2升水的，现给出1升水和2升水水瓶的单价，求最少需要花费多少钱。有$q$个询问。 思路：贪心 要使总花费最小，我们需要尽量多选取性价比高的规格。 Code123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int q;long long n,a,b;//注意要开long longint main()&#123; cin&gt;&gt;q; for(int i=1;i&lt;=q;i++) &#123; cin&gt;&gt;n&gt;&gt;a&gt;&gt;b; if(a*2&lt;=b)//买1升的性价比高于买2升的性价比 &#123; cout&lt;&lt;n*a&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;n/2*b+(n-n/2*2)*a&lt;&lt;endl;//题目要求的是刚好购买n升，所以不足2升的要买1升的补齐 &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1092B 【Teams Forming】]]></title>
    <url>%2F2019%2F04%2F10%2F%E9%A2%98%E8%A7%A3-CF1092B-%E3%80%90Teams-Forming%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题的基本思想就是贪心吧 题目就是让你两两分组，使得每组能力值的差值最小 设$a{1},a{2},···,a_{n}$表示每个学生的能力值 且满足：$a{1} \le a{2} \le ··· \le a_{n}$ 则对于任意一个能力值$a{i}$，它的最优匹配为$a{i+1}$（$i$为奇数） 考虑到$a{1}$，我们不取$a{i-1}$（你想想$a_{1-1}$是什么） 假设存在一个能力值$a{k}$ ($k&gt; i+1$)，使得$a{k}-a{i}&lt; a{i+1}-a_{i}$ 即: $a{k}&lt;a{i+1}$ ∵ $a{i+1}&lt;a{k}$ ∴ 不存在这样的$k$ Code1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110],ans; int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; sort(a+1,a+n+1);//要先排序 for(int i=1;i&lt;=n;i+=2) //i要为奇数 &#123; ans+=a[i+1]-a[i];//答案加上两个能力值的差 &#125; cout&lt;&lt;ans; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1145F 【Neat Words】]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%A2%98%E8%A7%A3-CF1145F-%E3%80%90Neat-Words%E3%80%91%2F</url>
    <content type="text"><![CDATA[这题其实是一道很水的字符串模拟，不要被难度骗了 CF恶意评分又不是一两天了（雾） 注意题目中说到的 由直线或都是由曲线构成的 是指该字母的笔画（我理解题目理解了半天$qwq$） 具体思路： 1 应用$map$将由直线（或者曲线）构成的字母的映射值设为1 2 计算该字符串的所有对应的映射值之和，因为题目要求全为直线或全为曲线，所以当总和为$len$($len$为字符串长度)或$0$时，输出$YES$，否则输出$NO$ Code1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;string s;map&lt;char,bool&gt; p;int main()&#123; ios::sync_with_stdio(false); p['A']=1;//打表 p['E']=1; p['F']=1; p['H']=1; p['I']=1; p['K']=1; p['L']=1; p['M']=1; p['N']=1; p['T']=1; p['V']=1; p['W']=1; p['X']=1; p['Y']=1; p['Z']=1; cin&gt;&gt;s; int sum=0; for(int i=0;i&lt;s.size();i++) sum+=p[s[i]];//统计映射值之和 if(sum==s.size() or sum==0) cout&lt;&lt;"YES";//判断 else cout&lt;&lt;"NO"; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P1794 【装备运输_NOI导刊2010提高（04）】]]></title>
    <url>%2F2019%2F04%2F06%2F%E9%A2%98%E8%A7%A3-P1794-%E3%80%90%E8%A3%85%E5%A4%87%E8%BF%90%E8%BE%93-NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%EF%BC%8804%EF%BC%89%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道01背包模板题吧。。。其实就是再增加了一个体积参数 状态转移方程： $F{j,k}=max(F{j-v{i},k-g{i}}+t{i},F{j,k})$ Code 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int V,G,n;//V和G为最大体积和重量int t[510],v[510],g[510];int f[510][510];int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;V&gt;&gt;G; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;t[i]&gt;&gt;v[i]&gt;&gt;g[i]; for(int i=1;i&lt;=n;i++) for(int j=V;j&gt;=v[i];j--) for(int k=G;k&gt;=g[i];k--) f[j][k]=max(f[j-v[i]][k-g[i]]+t[i],f[j][k]);//状态转移方程 cout&lt;&lt;f[V][G];//f[V][G]即为答案 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>动态规划（dp）</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1043A 【Elections】]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%A2%98%E8%A7%A3-CF1043A-%E3%80%90Elections%E3%80%91%2F</url>
    <content type="text"><![CDATA[一看数据范围， $1 \le n \le 100 $，此时不枚举更待何时？（雾） 注意获胜是指小$A$的票数大于小$B$的票数，而不是大于等于。（原谅作者语文不好$qwq$） Code12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110];int sum1,sum2;bool comp(int a,int b)//自定义排序函数，从大到小排&#123; return a&gt;b;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum1+=a[i];//预处理小B的票数 sort(a+1,a+n+1,comp);//因为k&gt;=max&#123;ai&#125;，所以考虑先排序 for(int k=a[1];;k++) &#123; sum2=0;//一定要初始化！ for(int i=1;i&lt;=n;i++) sum2+=k-a[i];//每个人投给小A的票数就是每个人可以投的票数减去每个人投给小B的票数 if(sum2&gt;sum1)//是&gt;不是&gt;= &#123; cout&lt;&lt;k; return 0; &#125; &#125; return 0;&#125; 观察一下代码，我们发现可以在求小$A$的票数部分做一些小小的优化 观察可以发现，$sum2$=$\sum{i=1}^{n}(k-a{i})$ 原式 $=$ $k\times n-\sum{i=1}^{n}a{i}$ $=$ $k\times n-sum1$ 于是在求小$A$的票数部分可以优化到$O(1)$复杂度 Code1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110];int sum1,sum2;bool comp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum1+=a[i]; sort(a+1,a+n+1,comp); for(int k=a[1];;k++) &#123; sum2=k*n-sum1;//求小A的票数，当然你也可以不用再设一个变量直接比较 if(sum2&gt;sum1) &#123; cout&lt;&lt;k; return 0; &#125; &#125; return 0;&#125; 接下来我们再观察一下这个程序，我们发现，这个程序其实就要求最小的$k$，使得$k$满足$k\times n-sum1&gt;sum1$ 这不就是一个不等式吗 移项： $k\times n&gt;2\times sum1$ 系数化一: $k&gt;2\times sum1 /n$ 于是在求答案的部分就可以优化到$O(1)$复杂度 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110];int sum1;bool comp(int a,int b)&#123; return a&gt;b;&#125;int main()&#123; ios::sync_with_stdio(false); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i],sum1+=a[i]; sort(a+1,a+n+1,comp); if(2*sum1/n+1&lt;a[1]) cout&lt;&lt;a[1];//因为k要&gt;=max a[i]，所以如果2*sum/n+1&lt;a[1]要输出a[1] else cout&lt;&lt;2*sum1/n+1; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[set学习笔记]]></title>
    <url>%2F2019%2F03%2F31%2Fset%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.什么是set 和 set的好处$set$的翻译为集合，是一个内部自动有序且不含重复元素(即满足集合的互异性)的$STL$容器，其内部采用“红黑树”实现。 什么是集合？点这 $set$的好处在于自动完成去重和按升序排序 2.举个栗子比如这题 1.普通作法看到数据范围这么水肯定想到用桶排 Code12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int b[1001],n,i,j,m=0,x; memset(b,0,sizeof(b)); cin&gt;&gt;n; for(i=1;i&lt;=n;i++) &#123; cin&gt;&gt;x; if(b[x]==0) m++; b[x]++; &#125; cout&lt;&lt;m&lt;&lt;endl; for(i=0;i&lt;=1000;i++) if(b[i]&gt;0) cout&lt;&lt;i&lt;&lt;" "; cout&lt;&lt;endl; return 0;&#125; 2.set如果你会了$set$，这道题就可以这么打 Code1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int n;set&lt;int&gt; st;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) &#123; int x; scanf("%d",&amp;x); st.insert(x); &#125; printf("%d\n",st.size()); for(set&lt;int&gt;::iterator it= st.begin(); it!=st.end(); it++) &#123; printf("%d ",*it); &#125; return 0;&#125; 如果数据范围大了话，明显不能用桶排解决，这时候$set$的好处就可以体现出来。 领会了$set$的好处之后，接下来让我们了解 3.set的定义使用$set$之前，必须添加$set$头文件，即1#include&lt;set&gt; 也可以打好我们的$bits/stdc++.h$ 同时必须要有 1using namespace std; 定义一个$set$的方法： 1set&lt;typename&gt; name; 其中$typename$为任何基本类型或者容器，$name$为这个集合的名字 同时$set$也支持定义数组，如: 1set&lt;typename&gt; name[MAXN] 即定义了$MAXN$个$set$容器 4.set的访问一大坑点是$set$只能通过迭代器访问 1.定义一个迭代器1set&lt;typename&gt;::iterator it; 即定义一个名为$it$的迭代器 2.通过迭代器访问注意事项： 1 $set$不支持类似*$(it+i)$的访问 2 $set$也不支持$it&lt;name.end()$这种访问 我们需要使用*$it$来访问$set$中的元素 5.set的常用函数1.insert()1.作用$insert()$用来插入一个数到$set$中，并自动排序+去重 2.时间复杂度$O(log_{2}n)$ 3.用法例如，以下一段代码输出$1$ $2$ $3 $ 123456for(int i=3;i&gt;=1;i--) a.insert(i);a.insert(1);for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" ";&#125; 2.begin()和end()1.作用分别用来获取$set$容器的首地址和尾地址 用法跟其他$STL$容器一样这里不再赘述 3.size()1.作用用于获取$set$容器中元素的个数 2.时间复杂度$O(1)$ 3.用法例如，以下一段代码输出$3$ 123for(int i=3;i&gt;=1;i--) a.insert(i);a.insert(1);cout&lt;&lt;a.size(); 4.clear()1.作用用于清空$set$容器中的所有元素 2.时间复杂度$O(n)$ ($n$为$set$中的元素个数) 3.用法例如，以下一段代码输出$1$ 1234for(int i=3;i&gt;=1;i--) a.insert(i);a.clear();a.insert(1);cout&lt;&lt;a.size(); 5.erase()1.作用可以用来删除单个元素也可以用来删除一段区间的元素 1.删除单个元素 1.时间复杂度$O(1)$ (使用迭代器) $O(log_{2}n)$ (使用欲删除元素的值) 2.用法1.$erase(it)$ $it$为欲删除的元素的迭代器 例如，以下一段代码输出$2$ $3$ 123456for(int i=3;i&gt;=1;i--) a.insert(i);a.erase(a.begin());for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" ";&#125; 2.$erase(value)$ $value$为欲删除元素的值 例如以下一段代码输出$1$ $3$ 123456for(int i=3;i&gt;=1;i--) a.insert(i);a.erase(2);for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" ";&#125; 2.删除一个区间的元素 1.时间复杂度$O(right-left)$ $(左闭右开区间[left,right))$ 2.用法$erase(left,right)$用来删除左闭右开区间[$left$,$right$)之间的元素 例如，以下一段代码输出$1$ 1234567for(int i=5;i&gt;=1;i--) a.insert(i);set&lt;int&gt;::iterator it=a.find(2);a.erase(it,a.end());for(set&lt;int&gt;::iterator it=a.begin();it!=a.end();it++)&#123; cout&lt;&lt;*it&lt;&lt;" ";&#125; 6.find()1.作用返回元素在$set$中的迭代器 2.时间复杂度$O(log_{2}n)$ ($n$为$set$中的元素个数) 3.用法例如，以下一段代码输出$2$ 12for(int i=5;i&gt;=1;i--) a.insert(i);cout&lt;&lt;*a.find(2); 6.推荐例题 1 洛谷P1059 明明的随机数 之后还会继续放上]]></content>
      <tags>
        <tag>C++</tag>
        <tag>set</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF1130A 【Be Positive】]]></title>
    <url>%2F2019%2F03%2F30%2F%E9%A2%98%E8%A7%A3-CF1130A-%E3%80%90Be-Positive%E3%80%91%2F</url>
    <content type="text"><![CDATA[一看数据范围： $-10^{3}\le d \le 10^{3}$，$1 \le n \le 100$ 这是让我们打表枚举的节奏啊（雾） 思路很简单，枚举每一个$d$，判断是否满足条件即可 Code12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[110];int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=-1000;i&lt;=1000;i++) &#123; if(i==0) continue;//d不能为0 int sum=0; for(int j=1;j&lt;=n;j++) &#123; if(a[j]*i&gt;0) sum++;//a[i]/d与a[i]*d同正负 &#125; if(2*sum&gt;=n) //满足条件 &#123; cout&lt;&lt;i; return 0; &#125; &#125; cout&lt;&lt;0; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>CodeForces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A+B problem(高精)python]]></title>
    <url>%2F2019%2F03%2F27%2FA-B-problem-%E9%AB%98%E7%B2%BE-python%2F</url>
    <content type="text"><![CDATA[自带高精就是好呢，代码好简单/QwQ12345a=input()b=input()a=int(a)b=int(b)print(a+b)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF102A 【Clothes】]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A2%98%E8%A7%A3-CF102A-%E3%80%90Clothes%E3%80%91%2F</url>
    <content type="text"><![CDATA[本萌新来介绍一种$dfs$思路： 1 如果件数已经$=$3，那么判断，如果符合条件，则更新答案 2 如果件数$&lt;$3，那么枚举$1$~$n$,如果该件衣服没被取过，则标记为已取并$dfs$下一件 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std; int n,m,money[110],minx=INT_MAX;bool p[110][110],f,use[110];int s[5];bool comp()//判断是否符合条件&#123; if(p[s[1]][s[2]] and p[s[1]][s[3]] and p[s[2]][s[3]]) return 1; return 0;&#125;void dfs(int t,int sum)&#123; if(t&gt;3)//件数&gt;3判断 &#123; if(comp()) &#123; f=1;//标记为有方案 minx=min(minx,sum); &#125; return; &#125; for(int i=1;i&lt;=n;i++) &#123; if(!use[i])//该件衣服没被取过 &#123; s[t]=i;//保存答案编号用于之后判断 use[i]=1;//标记为已取 dfs(t+1,sum+money[i]); use[i]=0;//回溯 &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;money[i]; for(int i=1;i&lt;=m;i++) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; p[x][y]=1;//建有向图 p[y][x]=1; &#125; dfs(1,0); if(f) cout&lt;&lt;minx; else cout&lt;&lt;"-1"; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>深度优先搜索（dfs）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string学习笔记]]></title>
    <url>%2F2019%2F03%2F24%2Fstring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.What’s string$string$ 是一种$STL$的容器，支持多种字符串操作。 2.string的定义使用$string$需要添加头文件 1#include&lt;string&gt; 或者打好万能库，胜过zhw 同时必须要有 1using namespace std; 定义$string$的方法非常简单，如下： 1string name;//name为字符串名称 同时也可以定义$string$数组，如下： 1string name[MAXN];//name为数组名，MAXN为数组大小 即这个数组中的每一个元素都是$string$类型 3.string初始化可以直接在定义的时候初始化，如： 1string name="I love C++!"; 等价于： 12string name;name="I love C++!"; 也可以写成： 1string name("I love C++!"); 4.string的访问1.通过下标访问12string s="I love C++!";printf("%c",s[0]);//输出I 2.通过迭代器访问1.迭代器的定义1string::iterator node;//定义一个名为node的迭代器 2.访问123string s="I love C++";string::iterator node=s.begin()//获取s的首地址printf("%c",*node);//输出I(因为是迭代器所以前面要加上*) 5.string的基本运算1.加法运算加法运算可以将两个字符串拼接在一起，但加号两边必须至少有一个为$string$类型 如，下列程序是合法的： 1234string s1="I love ";string s2="C++";s1+=s2;//等价于s1=s1+s2cout&lt;&lt;s1;//输出I love C++ 但下列程序是不合法的： 12string s1="I love "+"C++";cout&lt;&lt;s1&lt;&lt;endl; 下列程序依然合法： 123string s2="C";string s1="I love "+s2+"++";cout&lt;&lt;s1&lt;&lt;endl;//输出I love C++ 2.关系运算关系运算可以按字典序比较两个字符串的大小，如： 1234string s1="abcde";string s2="bcdef";if(s1&lt;s2) cout&lt;&lt;"Winner!";//输出Winner!else cout&lt;&lt;"Lose!"; 6.string的输入与输出1.利用cin和cout输入输出$cin$在读到空格时将会停止读入，例如以下一段程序输入$123$ $456$后，仅会输出$123$ 123string s;cin&gt;&gt;s;cout&lt;&lt;s; 2.利用getline输入$getline$可以用来读整行的字符串(包括空格)，例如以下一段程序输入$123$ $456$后，输出$123$ $456$ 123string s;getline(cin,s);cout&lt;&lt;s; 3.将string转换为字符数组输入输出$c$_$str()$可以将$string$转换为字符数组，如： 123string s;scanf("%s",s.c_str());printf("%s",s.c_str()); 输入$123$ $456$ 输出$123$ 7.string的常用函数1.length()和size()1.作用用来获取字符串的长度，即字符个数 2.时间复杂度$O(1)$ 3.用法123string s="abcd";int len=s.size();cout&lt;&lt;len;//输出4 2.begin()和end()1.作用分别用来获取字符串的首地址和尾地址，一般与迭代器配合使用 2.时间复杂度$O(1)$? 3.用法12345string s="I love C++!";for(string::iterator it=s.begin()+2;it!=s.end();it++)&#123; printf("%c",*it);//输出love C++! &#125; 3.clear()1.作用用来清空字符串中的所有元素 2.时间复杂度$O(1)$ 3.用法123string s="I love C++!";s.clear();cout&lt;&lt;s;//输出为空 4.substr()1.作用返回字符串的字串 2.时间复杂度$O(n)$ ($n$为字符串长度) 3.用法$s.substr(node,len)$返回从$node$位置开始，长度为$len$的字串 如： 12string s="I love C++!";cout&lt;&lt;s.substr(2,4);//输出love 5.insert()1.作用插入字符串 2.时间复杂度$O(n)$ ($n$为字符串长度) 3.用法$insert$有多种写法 1.$insert(node,s)$ 在$node$号位置插入字符串$s$ 123string s="I C++!";s.insert(2,"love");cout&lt;&lt;s;//输出I love C++! 2.$insert(node,s,sum)$ 在$node$号位置插入字符串$s$的前$sum$个字符 123string s="I C++!";s.insert(2,"love python",4);cout&lt;&lt;s;//输出I love C++! 3.$insert(it,it2,it3)$ $it$为原字符串的欲插入位置，$it1$,$it2$为待插入字符串的首尾迭代器(左闭右开) 1234string s="I C++!";string ss="love python";s.insert(s.begin()+2,ss.begin(),ss.begin()+4);cout&lt;&lt;s;//输出I love C++! 4.$insert(node,sum,c)$ 在$node$号位置插入$sum$个字符$c$ 123string s="I love C!";s.insert(8,2,'+');cout&lt;&lt;s;//输出I love C++! 6.erase()1.作用$erase()$可以删除单个字符或一个区间内的字符 2.时间复杂度$O(n)$ ($n$为字符串长度) 3.用法1.$erase(it)$ $it$为欲删除元素的迭代器 123string s="I love C+++!";s.erase(s.begin()+10);cout&lt;&lt;s;//输出I love C++! 2.$erase(left,right)$ $left$为区间的起始迭代器，$right$为区间末尾迭代器的下一个地址。左闭右开区间 123string s="I love C++++!";s.erase(s.begin()+10,s.begin()+12);cout&lt;&lt;s;//输出I love C++! 3.$erase(node,len)$ 删除从$node$号位置开始$len$个字符 123string s="I love C++++!";s.erase(10,2);cout&lt;&lt;s;//输出I love C++! 7.find()1.作用返回子串第一次出现的位置，如果找不到返回string::npos 2，时间复杂度$O(nm)$ $n,m$分别为第一个，第二个字符串的长度 3，用法1.$find(s)$，返回$s$在原字符串第一次出现的位置 123456789string s="I love C++!";if(s.find("C++")!=string::npos) cout&lt;&lt;s.find("C++")&lt;&lt;" ";else cout&lt;&lt;"-1"&lt;&lt;" ";if(s.find("python")!=string::npos) cout&lt;&lt;s.find("python")&lt;&lt;" ";else cout&lt;&lt;"-1"&lt;&lt;" ";//输出7 -1 2.$find(s,node)$ 返回原字符串从$node$号位置开始$s$第一次出现的位置 123456789string s="I love C++!";if(s.find("C++")!=string::npos) cout&lt;&lt;s.find("C++")&lt;&lt;endl;else cout&lt;&lt;"-1"&lt;&lt;endl;if(s.find("C++",8)!=string::npos) cout&lt;&lt;s.find("python")&lt;&lt;endl;else cout&lt;&lt;"-1"&lt;&lt;endl;//输出7 -1 8.replace()1.作用替换字符串 2.时间复杂度$O(n)$ ($n$为要替换的字符串长度) 3.用法1.$replace(node,len,s)$ 把原字符串从$node$号位置长度为$len$的子串替换为$s$ 12string s="I love python!";cout&lt;&lt;s.replace(7,6,"C++");//输出I love C++! 2.$replace(it1,it2,s)$ 表示把原字符串的迭代器$it1$~$it2$范围内(左闭右开区间)的子串替换为$s$ 12string s="I love python!";cout&lt;&lt;s.replace(s.begin()+7,s.begin()+13,"C++");//输出I love C++! 8.字符串数字互化可以用$sscanf$和$sprintf$实现 1234string s="19260817";int a;sscanf(s.c_str(),"%d",&amp;a);//把s以整数的形式输入到a(s要为字符数组)cout&lt;&lt;a;//输出19260817 1234int a=19260817;char s[30];sprintf(s,"%d",a);cout&lt;&lt;s;//输出19260817 同时我们也可以用一个神奇的东西——$stringstream$ 友情提示：这个东西十分耗时! 123456stringstream ss;string s="19260817";int n;ss&lt;&lt;s;//将s传入ssss&gt;&gt;n;//将ss传入ncout&lt;&lt;n;//输出19260817 如果要多次调用$stringstream$,记住在每一次使用前都要$clear()$ 9.推荐例题 1 猪国杀 2 洛谷P1308 统计单词数 思路点拨：运用$find$函数实现 3 洛谷P1079 Vigenère 密码 思路点拨：按照题意模拟即可]]></content>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 P5269 【欧稳欧再次学车】]]></title>
    <url>%2F2019%2F03%2F23%2F%E9%A2%98%E8%A7%A3-P5269-%E3%80%90%E6%AC%A7%E7%A8%B3%E6%AC%A7%E5%86%8D%E6%AC%A1%E5%AD%A6%E8%BD%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[三年OI一场空，不开long long 见祖宗 一道模拟题，具体解释在代码里： Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;int t,n,l,r,x,k;long long dang,zhuan;//一定要开long long !!!long long ans;int main()&#123;// freopen("1.out","w",stdout); scanf("%d%d%d%d%d%d",&amp;t,&amp;n,&amp;l,&amp;r,&amp;x,&amp;k); zhuan=l;//zhuan存放转速 dang=1;//dang存放档位 int flag=0; for(int i=1;i&lt;=t;i++) &#123; int xx,yy; scanf("%d%d",&amp;xx,&amp;yy); if(xx==0)//升档 &#123; if(dang==n) //如果dang已经到达了n，那么是非法序列 &#123; cout&lt;&lt;"-1"; return 0; &#125; dang++; zhuan=l;//转速调整为l &#125; if(xx==1)//降档 &#123; if(dang==1) //如果dang是1，那么是非法序列 &#123; cout&lt;&lt;"-1"; return 0; &#125; dang--; zhuan=r;//转速调整为r &#125; if(yy==1)//踩油门 &#123; zhuan+=x;//转速加上x if(zhuan&gt;r) zhuan=r;//对r取min &#125; ans+=zhuan*dang //一定要在发动机有没有爆炸前加 if(zhuan==r) &#123; flag++; if(flag==k)//爆炸 &#123; cout&lt;&lt;ans; return 0; &#125; &#125; else flag=0; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解CF96A【Football】]]></title>
    <url>%2F2019%2F03%2F19%2F%E9%A2%98%E8%A7%A3CF96A%E3%80%90Football%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道字符串模拟，直接暴力枚举即可Code123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;string s;int main()&#123; cin &gt;&gt; s; for(int i = 0 ; i &lt; s.size(); i++) &#123; int ans = 1; char c = s[i]; for(int j = i + 1 ; j &lt; s.size(); j++) &#123; if(s[j] != c)//不一样直接退出 &#123; break; &#125; else &#123; ans++; &#125; if(ans == 7)//有七个一样的输出YES &#123; puts("YES"); return 0; &#125; &#125; &#125; puts("NO");//不危险输出NO return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷神帖]]></title>
    <url>%2F2019%2F03%2F11%2F%E6%B4%9B%E8%B0%B7%E7%A5%9E%E5%B8%96%2F</url>
    <content type="text"><![CDATA[1.炸出10几个管理员2.A+B problem3.洛谷新闻4.第一高楼5.举报CCF_NOI6.AK IOI7.Harry_Potter事件8.]]></content>
      <tags>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树学习笔记]]></title>
    <url>%2F2019%2F03%2F11%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.线段树的作用 给定一个整数序列，让你完成如下操作 修改序列上某个位置（区间）上的数 询问序列中某个区间的和 “暴力”算法 单点修改$O(1)$ 询问区间和$O(区间长度)$ “前缀和”算法 单点修改$O(区间长度)$ 询问区间和$O(1)$ 线段树$O(nlogn)$ 2.线段树的概念 线段树是一棵二叉树，树上的每个结点对应序列的一段区间 3.线段树的操作1.结构体1234struct node&#123; int l,r,w,f;//l,r代表左，右端点，w代表这一段区间和，f是懒标记（懒标记在之后会提到）&#125;tree[4*n];//线段树要开到4倍的空间 2.建树基本思想： 1 二分 2 对于二分到的每一个结点，把左右端点的信息储存 3 叶结点输入 12345678910111213void build(int l,int r,int k)&#123; tree[k].l =l,tree[k].r =r; if(tree[k].l==tree[k].r)//叶子结点 &#123; scanf("%d",&amp;tree[k].w); return; &#125; int m=(l+r)/2; build(l,m,k*2);//左孩子 build(m+1,r,k*2+1);//右孩子 tree[k].w =tree[k*2].w +tree[k*2+1].w ;//合并&#125; 3.单点查询123456789101112void ask(int k)&#123; if(tree[k].l ==tree[k].r )//是目标结点 &#123; ans=tree[k].w ;//储存答案 return; &#125; if(tree[k].f ) down(k);//下传懒标记 int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) ask(k*2);//在左边递归左孩子 else ask(k*2+1);//在右边递归右孩子&#125; 4.单点修改12345678910111213void add(int k)&#123; if(tree[k].l ==tree[k].r )//是目标结点 &#123; tree[k].w +=y;//修改 return; &#125; if(tree[k].f ) down(k);//懒标记下传 int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) add(k*2);//在左边递归左孩子 else add(k*2+1);//在右边递归右孩子 tree[k].w =tree[k*2].w +tree[k*2+1].w ;//状态修改&#125; 5.区间求和123456789101112void sum(int k)&#123; if(tree[k].l &gt;=x&amp;&amp;tree[k].r &lt;=y)//左右端点全在目标区间内 &#123; ans+=tree[k].w ;//答案直接加上这一段区间和 return; &#125; if(tree[k].f ) down(k);//懒标记下传 int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) sum(k*2);//往左孩子移 if(y&gt;m) sum(k*2+1);//往右孩子移&#125; 6.区间修改在前面的操作中我们经常看到有懒标记下传这个操作，那么懒标记到底是什么呢 1.1懒标记的作用 存储到这个节点的更新信息，暂时不把更新信息传到子节点。 1.2懒标记的下传 1 将当前节点的懒标记累加到子节点的懒标记中 2 修改子节点状态，即区间和$w$=原状态+区间长度×父节点下传的懒标记 3 父节点懒标记清空 12345678void down(int k)&#123; tree[k*2].f +=tree[k].f ;//修改子节点懒标记(下同) tree[k*2+1].f +=tree[k].f ; tree[k*2].w +=tree[k].f *(tree[k*2].r -tree[k*2].l +1);//修改子节点状态(下同) tree[k*2+1].w +=tree[k].f *(tree[k*2+1].r -tree[k*2+1].l +1); tree[k].f =0;//懒标记清零&#125; 2.区间修改1234567891011121314void add2(int k)//y为增加的数，(a,b)为目标区间&#123; if(tree[k].l &gt;=a&amp;&amp;tree[k].r &lt;=b)//在目标左右端点内 &#123; tree[k].w +=(tree[k].r -tree[k].l +1)*y;//状态修改 tree[k].f +=y;//懒标记加上y return; &#125; if(tree[k].f) down(k);//懒标记下传 int m=(tree[k].l +tree[k].r )/2; if(a&lt;=m) add2(k*2);//如区间求和(下同) if(b&gt;m) add2(k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;//修改状态&#125; 4.完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;bits/stdc++.h&gt;using namespace std;struct node&#123; long long l,r,w,f;&#125; tree[400001];long long ans,x,y,a,b,n,p,m;void build(int l,int r,int k)//建树 &#123; tree[k].l =l,tree[k].r =r; if(tree[k].l==tree[k].r) &#123; scanf("%lld",&amp;tree[k].w); return; &#125; int m=(l+r)/2; build(l,m,k*2); build(m+1,r,k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;&#125;void down(int k)//懒标记下传 &#123; tree[k*2].f +=tree[k].f ; tree[k*2+1].f +=tree[k].f ; tree[k*2].w +=tree[k].f *(tree[k*2].r -tree[k*2].l +1); tree[k*2+1].w +=tree[k].f *(tree[k*2+1].r -tree[k*2+1].l +1); tree[k].f =0;&#125;void ask(int k)//单点查询 &#123; if(tree[k].l ==tree[k].r ) &#123; ans=tree[k].w ; return; &#125; if(tree[k].f ) down(k); int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) ask(k*2); else ask(k*2+1);&#125;void add(int k)//单点修改加法 &#123; if(tree[k].l ==tree[k].r ) &#123; tree[k].w +=y; return; &#125; if(tree[k].f ) down(k); int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) add(k*2); else add(k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;&#125;void sum(int k)//区间求和 &#123; if(tree[k].l &gt;=x&amp;&amp;tree[k].r &lt;=y) &#123; ans+=tree[k].w ; return; &#125; if(tree[k].f ) down(k); int m=(tree[k].l +tree[k].r )/2; if(x&lt;=m) sum(k*2); if(y&gt;m) sum(k*2+1);&#125;void add2(int k)//区间修改加法 &#123; if(tree[k].l &gt;=a&amp;&amp;tree[k].r &lt;=b) &#123; tree[k].w +=(tree[k].r -tree[k].l +1)*y; tree[k].f +=y; return; &#125; if(tree[k].f) down(k); int m=(tree[k].l +tree[k].r )/2; if(a&lt;=m) add2(k*2); if(b&gt;m) add2(k*2+1); tree[k].w =tree[k*2].w +tree[k*2+1].w ;&#125;int main()&#123; scanf("%lld%lld",&amp;n,&amp;m);//n个数和m个操作 build(1,n,1);//建树 for(int i=1; i&lt;=m; i++) &#123; scanf("%lld",&amp;p); ans=0; switch(p) &#123; case 1:&#123;//1为单点查询 cin &gt;&gt; x; ask(1); printf("%lld\n",ans); break; &#125; case 2:&#123;//2为单点修改 cin &gt;&gt; x &gt;&gt; y; add(1); break; &#125; case 3:&#123;//3为区间求和 cin &gt;&gt; x &gt;&gt; y ; sum(1); printf("%lld\n",ans); break; &#125; case 4:&#123;//4为区间修改 cin &gt;&gt; a &gt;&gt; b &gt;&gt; y; add2(1); break; &#125; &#125; &#125; return 0;&#125; 5.推荐例题 1 洛谷P2068统计和 思路点拨：线段树模板 2 洛谷P3372【模板】线段树 1 思路点拨：线段树模板]]></content>
      <tags>
        <tag>C++</tag>
        <tag>学习笔记</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF32A 【Reconnaissance】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-CF32A-%E3%80%90Reconnaissance%E3%80%91%2F</url>
    <content type="text"><![CDATA[一看到了求方案数，马上想到了枚举 $dfs$ 深搜思路：$dfs(t)$ ($t$为选了几个人) 1 如果已经选取了两个数，$ans$++并$return$ 2 枚举$1\sim n$ 如果第$a_{i}$个人没被选过且与前一个人身高差的绝对值不超过$d$，则标记为已选并$dfs(t+1)$ Code12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int n,d,a[1010],ans,s[1010];//s用来存前一个人的身高bool p[1010];//p用来标记已选过的人void dfs(int t)&#123; if(t&gt;2) &#123; ans++; return; &#125; for(int i=1; i&lt;=n; i++) &#123; s[0]=a[i];//s[0]需要设成a[i]，这样第一个人才能选 if(abs(a[i]-s[t-1])&lt;=d&amp;&amp;!p[i]) &#123; p[i]=1; s[t]=a[i];//记录前一个人的身高 dfs(t+1); p[i]=0;//回溯 &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;d); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;a[i]); &#125; dfs(1); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>深度优先搜索（dfs）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF25B 【Phone numbers】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-CF25B-%E3%80%90Phone-numbers%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道字符串模拟题首先我们知道 偶数+偶数=偶数 偶数+奇数=奇数 然后我们就可以对$N$进行分类讨论： 当$N\le3$时，直接输出字符串即可 当$N=2k$ $(k\ge2)$时，可以把$N$拆分成若干个长度为2的字符串，在两个字符串之间添上-号 当$N=2k+1$ $(k\ge2)$时，可以把$N$拆分成一个长度为3的字符串和若干个长度为2的字符串，在两个字符串之间添上-号 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;string s;int sum;int n;int main()&#123; scanf("%d",&amp;n); cin&gt;&gt;s; if(n&lt;=3) //如果n&lt;=3，直接输出 &#123; cout&lt;&lt;s; return 0; &#125; if(n%2==0) //n为偶数则拆分成若干个长度为2的字符串 &#123; for(int i=0; i&lt;n; i++) &#123; sum++; printf("%c",s[i]); if(i==n-1) return 0; if(sum==2) &#123; printf("-"); sum=0; &#125; &#125; &#125; else //n为奇数则拆分成一个长度为3的字符串和若干个长度为2的字符串 &#123; for(int i=0; i&lt;3; i++) &#123; printf("%c",s[i]); &#125; printf("-"); for(int i=3; i&lt;n; i++) &#123; sum++; printf("%c",s[i]); if(i==n-1) return 0; if(sum==2) &#123; printf("-"); sum=0; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT3523 【OddString】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-AT3523-%E3%80%90OddString%E3%80%91%2F</url>
    <content type="text"><![CDATA[如题，输出奇数位上的字母即可AC 注意字符串下标是从0开始的！ Code12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;char s[100010];int main()&#123; gets(s); for(int i=0;i&lt;strlen(s);i+=2)//输出奇数位 &#123; printf("%c",s[i]); &#125; printf("\n");//记得换行 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 AT2201 【鏡文 / Mirror String】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3-AT2201-%E3%80%90%E9%8F%A1%E6%96%87-Mirror-String%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道简单的字符串模拟，刷难度真给力 本蒟蒻的思路比较麻烦，但个人认为比较好理解 1 先将字符串倒序存放 2 按照规则改变字母 3 比较 Code：1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;char s1[100010],s2[100010];int len;int main()&#123; cin&gt;&gt;s1; for(int i=strlen(s1)-1; i&gt;=0; i--) &#123; s2[len++]=s1[i];//倒序存放 &#125; for(int i=0; i&lt;strlen(s2); i++) &#123; switch(s2[i])//按照规则改变字母 &#123; case 'b': &#123; s2[i]='d'; break; &#125; case 'd': &#123; s2[i]='b'; break; &#125; case 'p': &#123; s2[i]='q'; break; &#125; case 'q': &#123; s2[i]='p'; break; &#125; &#125; &#125; if(strcmp(s1,s2)==0) cout&lt;&lt;"Yes"&lt;&lt;endl;//比较，注意如果两个字符串一样，strcmp返回0 else cout&lt;&lt;"No"&lt;&lt;endl;//记得换行 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>题解</tag>
        <tag>AtCoder</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解CF45I【TCMCF+++】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3CF45I%E3%80%90TCMCF-%E3%80%91%2F</url>
    <content type="text"><![CDATA[题目大意：给你$N$个整数，让你从中选$r$个数($0&lt;r \leq N$)，使得它们的乘积最大。输出任意一组解 思路：（大佬勿喷） 1 我们知道几个正整数的乘积总是正数，所以遇到正整数直接输出就好啦 2 遇到负数就不同了，我们知道“奇负偶正”，于是就有两种情况： 1 如果有偶数个负数，因为“偶正”，所以全部输出 2 如果有奇数个负数，我们只能输出个数-1个负数，并且这些负数的绝对值最大 3 接下来还需要三个特判 特判1：如果$N=1$并且这个数小于等于0，输出这个数 特判2：如果$N$（$N&gt;1$）个整数全是0，输出0 特判3：如果$N$（$N&gt;1$）个整数中全是非正数（只有0和负数），如果只有1个负数并且0的个数不为0，输出0（因为0比负数大） 4 然后。。。你就AC了 code123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int n,a[110],sum1=0,sum2=0;//sum1统计0的个数，sum2统计负数的个数int main()&#123; scanf("%d",&amp;n); for(int i=1; i&lt;=n; i++) &#123; scanf("%d",&amp;a[i]); if(a[i]&lt;0) sum2++;//a[i]是负数，sum2++ else if(a[i]==0) sum1++;//a[i]是0，sum1++ else printf("%d ",a[i]);//a[i]是正数，输出！ &#125; sort(a+1,a+n+1);//因为要取绝对值最大的负数，所以先排序 if(sum2%2==0)//偶数个负数全部输出 &#123; for(int i=1; i&lt;=sum2; i++) &#123; printf("%d ",a[i]); &#125; &#125; else//奇数个负数输出个数-1个 &#123; for(int i=1;i&lt;=sum2-1;i++) &#123; printf("%d ",a[i]); &#125; &#125; if(n==1&amp;&amp;a[1]&lt;=0) &#123; cout&lt;&lt;a[1]; return 0; &#125; if(sum1==n) cout&lt;&lt;0;//全是0 if(sum1+sum2==n&amp;&amp;sum2==1) cout&lt;&lt;0;//全是负数和0且负数只有一个 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解CF545D【Queue】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3CF545D%E3%80%90Queue%E3%80%91%2F</url>
    <content type="text"><![CDATA[这道题基本思路就是贪心（标签里的队列是什么鬼不会是因为标题叫队列吧）主要还是证明贪心的正确性(大佬勿喷) 设总等待时间为 $time$ , $n$个人等待时间分别为$t{1}$,$t{2}$,$t{3}$···$t{n}$,要使总等待人数最少,则$time$ 要取最小值: $time$ = $t{1}$+($t{1}$+$t{2}$)+($t{1}$+$t{2}$+$t{3}$)+···+($t{1}$+$t{2}$+$t{3}$+···$t{n}$) $time$ = $n \cdot t{1}$+ $(n-1)\cdot t{2}$+ ··· + $t_{n}$ 当$t{1} \le $ $t{2} \le$ ······ $t_{n}$ 时，$time$为最小值(简单的证明过程) —————————————————————————————————————————— 所以只要先每个人的等待时间排序一遍，设定一个总时间变量$time$,只要$time$小 于这个人的等待时间答案就+1，同时$time$也要加上这个人的等待时间 代码 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int n,t[100010],sum,ti;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;t[i]); sort(t+1,t+n+1);//排序（从小到大) for(int i=1;i&lt;=n;i++) &#123; if(t[i]&gt;=ti)//如果time&lt;这个人等待时间 &#123; sum++;//答案+1 ti+=t[i];//time加上这个人的等待时间 &#125; &#125; printf("%d",sum); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P1049【装箱问题】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3P1049%E3%80%90%E8%A3%85%E7%AE%B1%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[看到好多大佬都用动规，这题数据范围太水了(n&lt;=30)于是本蒟蒻先来发篇dfs深搜思路： 把n个物品两种可能（取与不取）都搜一遍，得到的最小体积就是答案 具体解释看代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int v,n,w[40],minx=INT_MAX;//minx存放最小体积，初始赋最大值void dfs(int volume,int pointer)//volume代表当前体积//pointer指示第pointer个物品&#123; if(volume&lt;0) return;//首先需要判断如果体积&lt;0就退出 if(pointer&gt;n)//如果n个物品都搜过了 &#123; if(volume&lt;minx)//判断当前体积是否小于最小体积 minx=volume;//是的话更新最小体积 return; &#125; if(volume==0)//小小的剪枝，如果当前体积已经为0了，那么不可能有更优解 &#123; minx=0; return; &#125; dfs(volume-w[pointer],pointer+1);//取该件物品 dfs(volume,pointer+1);//不取该件物品&#125;int main()&#123; scanf("%d%d",&amp;v,&amp;n); for(int i=1; i&lt;=n; i++) scanf("%d",&amp;w[i]); dfs(v,1); printf("%d",minx);//minx存放的即为答案 return 0;&#125; 但是如果数据范围加大了话。。。其实本题就是把0-1背包中物品的价值与体积画了个等号，于是本题就变成了一道0-1 背包模板题 代码如下：12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int w[31],f[20010];int main()&#123; int v,n; scanf("%d%d",&amp;v,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;w[i]); for(int i=1;i&lt;=n;i++) for(int j=v;j&gt;=w[i];j--) if(f[j]&lt;f[j-w[i]]+w[i]) f[j]=f[j-w[i]]+w[i];//状态转移方程 printf("%d",v-f[v]);//最后用体积减去最优解 return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>深度优先搜索（dfs）</tag>
        <tag>动态规划（dp）</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解P1451【求细胞数量】]]></title>
    <url>%2F2019%2F03%2F10%2F%E9%A2%98%E8%A7%A3P1451%E3%80%90%E6%B1%82%E7%BB%86%E8%83%9E%E6%95%B0%E9%87%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[一道可以用dfs做的题目（大佬勿喷）总体思路如下： 1 用一个bool数组存放每个位置是否为细胞数字 2 输入，如果这个数大于0，把这个位置标记为1 3 枚举每一个位置，如果是细胞数字就开始搜，同时答案加1 4 输出 深搜部分： 1 把这个位置标记为0 2 枚举四个方向，如果是细胞数字就从这个位置继续搜 （就是把所有连通的细胞数字都标记为0，周围再也没有细胞数字了就代表一个细胞） 代码如下：123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,sum;char s;bool p[110][110];int a[4]=&#123;1,-1,0,0&#125;;//四个方向int b[4]=&#123;0,0,-1,1&#125;;void dfs(int x,int y) &#123; p[x][y]=0;//把这个位置标记为0 for(int i=0;i&lt;4;i++) &#123; int xx=x+a[i]; int yy=y+b[i]; if(p[xx][yy])//如果这个位置是细胞数字，从这个位置开始搜 dfs(xx,yy); &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; cin&gt;&gt;s; if(s&gt;'0') p[i][j]=1;//是细胞数字标记为1 &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) &#123; if(p[i][j])//如果是细胞数字开始搜 &#123; sum++; dfs(i,j); &#125; &#125; printf("%d",sum); return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
        <tag>洛谷</tag>
        <tag>题解</tag>
        <tag>深度优先搜索（dfs）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2019%2F03%2F10%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[我才不会告诉你这篇文章是用来测验$LaTeX$的 $Day $ $0$告别期中考，来到福州，与机房的各位大佬去试了一下机，回来的时候互奶着哪位大佬要 $AK$了， 哪位大佬要省一了，晚上不务正业地玩着狼人杀，似乎忘记了此行的目的。 $Day$ $1$早上很早地就起来看一本通了，在宾馆颓了一早上，到了要比赛时才匆匆忙忙地背了一下$DP$ 方程 进入考场，先用了5$min$看了一遍所有题目，发现不简单 先看了一下$T1$，一道十分简单的字符串模拟，花了5$min$就敲完了，怕有坑不知道看了几遍题面。。。 看了一下$T2$，题目叙述比较长，于是先去看了看$T3$，想了一会儿觉得是贪心，于是打了个贪心调了挺久的，把两个小样例过了再去看大样例，发现答案比正确答案少了很多，于是想了很多方法，最终还是没想出来。 又回过头去看$T2$,理解完题面意思后发现是一道模拟，下意识写了个$O(N^{2})$的暴力，发现大数据会卡，脑抽没发现$O(n)$的算法，又去调了一会$T3$ 最后30$min$去看了一眼$T4$，发现是二叉树，但是没学过，直接输出0想骗些分 比赛结束，预计得分:$100+80+30+10=220$ 赛后去你谷测了一下民间数据，发现得分比预期的高，$100+80+30+20=230$ 用老师的数据也测了一下，$210$也还好 最后CCF的官方成绩出来了，发现才$100+80+10+4=194$分，原来$T3$的正解是$DP$，发现如果在原来的贪心上再改动一点应该可以过更多的数据的 最后$FJ$的分数线出来了——$195$，$194$的我当场崩溃$QwQ$ 第一次参加$NOIP$就带着差一分省一的遗憾结束了，不过反正我才初一还有很多机会对吧]]></content>
      <tags>
        <tag>NOIP</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A+B problem]]></title>
    <url>%2F2019%2F03%2F09%2FA-B-problem%2F</url>
    <content type="text"><![CDATA[纪念博客的诞生QwQ123456789#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a,b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a+b; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
