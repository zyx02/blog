<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WKAHPM的博客</title>
  
  <subtitle>「深藏不露是一种卓越的才能」</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://zyx02.github.io/blog/"/>
  <updated>2021-08-28T15:54:09.167Z</updated>
  <id>http://zyx02.github.io/blog/</id>
  
  <author>
    <name>WKAHPM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[题解]ZJOI2012灾难</title>
    <link href="http://zyx02.github.io/blog/2021/08/28/%E9%A2%98%E8%A7%A3-ZJOI2012%E7%81%BE%E9%9A%BE/"/>
    <id>http://zyx02.github.io/blog/2021/08/28/题解-ZJOI2012灾难/</id>
    <published>2021-08-28T15:33:12.000Z</published>
    <updated>2021-08-28T15:54:09.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P2597" target="_blank" rel="noopener">洛谷</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目中有多个生产者，考虑建一个虚点连向所有的生产者，这样保证了图连通。显然我们要按照拓扑序处理每个节点。</p><p>一个生物死亡只有当且仅当所有指向它的生物死亡，如果它的入度为$1$比较好处理，但如果大于$1$呢？</p><p>让捕食者向被捕食者再建一条边，当遍历到一个捕食者有多条连向它的被捕食者的边时，我们可以让这个捕食者直接向它的所有被捕食者的最近公共祖先连一条边。因为它们的最近公共祖先死亡了它们会全部死亡，所以连向被捕食者的所有边与连向它们最近公共祖先的边是等价的，这样我们就保证了图成为一棵树。</p><p>如图</p><p><img src="https://s3.bmp.ovh/imgs/2021/08/19e794381dab3f6a.jpg" alt=""></p><p>观察发现小强向牛和羊都有连边，牛和羊的最近公共祖先是草，这表明草死亡了牛和羊都会死亡，所以小强也会死亡。所以可以直接让小强向草连一条边。</p><p>最后只需要统计每个节点的子树大小，减去自己的$1$即可</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">70010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , cnt , head[MAXN];</span><br><span class="line"><span class="keyword">int</span> deg[MAXN] , f[<span class="number">30</span>][MAXN] , depth[MAXN];</span><br><span class="line"><span class="keyword">int</span> tcnt , thead[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> To , Nxt;</span><br><span class="line">&#125;edge[MAXN * <span class="number">100</span>] , Tree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> From , <span class="keyword">int</span> To)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++ cnt].Nxt = head[From];</span><br><span class="line">edge[cnt].To = To;</span><br><span class="line">head[From] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTree</span><span class="params">(<span class="keyword">int</span> From , <span class="keyword">int</span> To)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Tree[++ tcnt].Nxt = thead[From];</span><br><span class="line">Tree[tcnt].To = To;</span><br><span class="line">thead[From] = tcnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(depth[x] &lt; depth[y]) swap(x , y);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">20</span>; j &gt;= <span class="number">0</span>; j --) </span><br><span class="line">  <span class="keyword">if</span>(depth[f[j][x]] &gt;= depth[y]) x = f[j][x];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">20</span>; j &gt;= <span class="number">0</span>; j --)</span><br><span class="line">  <span class="keyword">if</span>(f[j][x] != f[j][y]) x = f[j][x] , y = f[j][y];</span><br><span class="line"><span class="keyword">return</span> f[<span class="number">0</span>][x]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++) f[j][k] = f[j - <span class="number">1</span>][f[j - <span class="number">1</span>][k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> q[MAXN] , fa[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Toopsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Head = <span class="number">1</span> , tail = <span class="number">1</span>;</span><br><span class="line">q[tail] = <span class="number">0</span>;</span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(Head &lt;= tail)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k = q[Head];</span><br><span class="line">vis[k] = <span class="number">1</span>;</span><br><span class="line">Head ++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[k]; i != <span class="number">-1</span>; i = edge[i].Nxt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = edge[i].To;</span><br><span class="line"><span class="keyword">if</span>(vis[v] <span class="keyword">or</span> deg[v] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(fa[v] == <span class="number">-1</span>) fa[v] = k;</span><br><span class="line"><span class="keyword">else</span> fa[v] = Lca(fa[v] , k);</span><br><span class="line">deg[v] --;</span><br><span class="line"><span class="keyword">if</span>(deg[v] == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">f[<span class="number">0</span>][v] = fa[v];</span><br><span class="line">depth[v] = depth[fa[v]] + <span class="number">1</span>;</span><br><span class="line">Work(v);</span><br><span class="line">addTree(fa[v] , v);</span><br><span class="line">q[++ tail] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Size[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Size[k] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = thead[k]; i != <span class="number">-1</span>; i = Tree[i].Nxt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = Tree[i].To;</span><br><span class="line">Dfs(v);</span><br><span class="line">Size[k] += Size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen("catas_catas9.in" , "r" , stdin);</span></span><br><span class="line"><span class="comment">//freopen("catas_catas9.out" , "w" , stdout);</span></span><br><span class="line">n = read();</span><br><span class="line"><span class="built_in">memset</span>(head , <span class="number">-1</span> , <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(fa , <span class="number">-1</span> , <span class="keyword">sizeof</span>(fa));</span><br><span class="line"><span class="built_in">memset</span>(thead , <span class="number">-1</span> , <span class="keyword">sizeof</span>(thead));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = read();</span><br><span class="line"><span class="keyword">while</span>(x != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">deg[i] ++;</span><br><span class="line">add(i , x);</span><br><span class="line">add(x , i);</span><br><span class="line">x = read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(deg[i] == <span class="number">0</span>) deg[i] ++ , add(<span class="number">0</span> , i);</span><br><span class="line">&#125;</span><br><span class="line">Toopsort();</span><br><span class="line">Dfs(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if(Size[i] == 0) cout &lt;&lt; i &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , Size[i] - <span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2597&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="LCA,最近公共祖先" scheme="http://zyx02.github.io/blog/tags/LCA-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
      <category term="拓扑排序" scheme="http://zyx02.github.io/blog/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>[题解]vistifj</title>
    <link href="http://zyx02.github.io/blog/2021/08/28/%E9%A2%98%E8%A7%A3-vistifj/"/>
    <id>http://zyx02.github.io/blog/2021/08/28/题解-vistifj/</id>
    <published>2021-08-28T15:17:52.000Z</published>
    <updated>2021-08-28T15:31:30.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://s3.bmp.ovh/imgs/2021/08/a98e39329318842a.png" alt=""></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>一种显然的做法是$dfs$枚举所有路线，但这样时间复杂度爆炸。注意到$n&lt;=100$，考虑记忆化，记录$dp[i][j][3]$表示到坐标$(i,j)$走了$s$ $mod$ $3$所需的最小花费。</p><p>一个小优化是将$dfs$改为像$bfs$的搜索，优先拓展花费小的状态。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n , t ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">110</span>][<span class="number">110</span>][<span class="number">3</span>] , v[<span class="number">110</span>][<span class="number">110</span>], minx = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">  dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Min</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a , <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b? a : b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tot;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp;x) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x.tot &lt; tot;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line">q.push((node)&#123;<span class="number">1</span> , <span class="number">1</span> , <span class="number">0</span>&#125;);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())</span><br><span class="line">&#123;</span><br><span class="line">node k = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(k.tot &gt;= dp[k.x][k.y][k.s % <span class="number">3</span>]) <span class="keyword">continue</span>;</span><br><span class="line">dp[k.x][k.y][k.s % <span class="number">3</span>] = k.tot;</span><br><span class="line"><span class="keyword">if</span>(k.tot &gt;= ans) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(k.x == n <span class="keyword">and</span> k.y == n) &#123;</span><br><span class="line">ans = k.tot;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> xx = k.x + dx[i] , yy = k.y + dy[i] , ss = k.s + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(xx &lt; <span class="number">1</span> <span class="keyword">or</span> xx &gt; n <span class="keyword">or</span> yy &lt; <span class="number">1</span> <span class="keyword">or</span> yy &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">q.push(node&#123;xx , yy , k.tot + t + (ss % <span class="number">3</span> == <span class="number">0</span>) * v[xx][yy] , ss&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = read() , t = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) </span><br><span class="line">    v[i][j] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k ++) dp[i][j][k] = INT_MAX;</span><br><span class="line">bfs();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://s3.bmp.ovh/imgs/2021/08/a98e39329318842a.png
      
    
    </summary>
    
    
      <category term="记忆化搜索" scheme="http://zyx02.github.io/blog/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>[题解]cqoi2017老C的任务</title>
    <link href="http://zyx02.github.io/blog/2021/08/27/%E9%A2%98%E8%A7%A3-cqoi2017%E8%80%81C%E7%9A%84%E4%BB%BB%E5%8A%A1/"/>
    <id>http://zyx02.github.io/blog/2021/08/27/题解-cqoi2017老C的任务/</id>
    <published>2021-08-27T15:54:37.000Z</published>
    <updated>2021-08-27T16:17:38.865Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P3755" target="_blank" rel="noopener">洛谷</a></p><p><img src="https://s3.bmp.ovh/imgs/2021/08/385d1ac98c105798.png" alt=""></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>由于题目不强制在线，我们可以将所有询问离线解决。</p><p>思考如果只有一个询问如何解决？显然可以用二维前缀和搞定。</p><p>对于每个询问，我们只需要求出四个点的答案，假设对角坐标（左下和右上）为$(a,b),(c,d)$，我们只需要求出$(a-1,b-1),(c,b-1),(a-1,d),(c,d)$左下方的所有基站功率之和即可。</p><p>$n&lt;=10^5$，直接$O(n^2)$暴力显然不可取。</p><p>假设我们目前求的点为$(x,y)$，需要统计的即所有满足$x_i&lt;=x,y_i&lt;=y$的基站权值之和。</p><p>（坐标数值较大，需要先进行离散化。）</p><p>可以先将基站的点和每个询问要求的点合在一起。维护一个一维的树状数组$t$，统计横坐标为$x$的基站功率和，按$y$从小到大先排序一遍，然后进行遍历，当遍历到基站时$i$时，对$x_i$进行单点加;当遍历到询问点$j$时，统计$1$~$x_j$区间和即可（此处$1,x_i,x_j$均为离散化后的横坐标），这样保证了两个条件（$x&lt;=x_j,y&lt;=y_j$）</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , cnt , len;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">100010</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line"><span class="keyword">int</span> rk ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> power;</span><br><span class="line"><span class="keyword">bool</span> p;</span><br><span class="line">&#125;a[<span class="number">500010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tree[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">500010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a , Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.y == b.y) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a.x == b.x) <span class="keyword">return</span> a.p &gt; b.p;</span><br><span class="line"><span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pos , <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(pos &lt;= len) tree[pos] += w , pos += lowbit(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(pos) sum += tree[pos] , pos -= lowbit(pos);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = read() , m = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">a[++ cnt].x = read() , a[cnt].y = read() , a[cnt].power = read();</span><br><span class="line">b[cnt] = a[cnt].x;</span><br><span class="line">a[cnt].p = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> A = read() , B = read() , c = read() , d = read();</span><br><span class="line">a[++ cnt].x = A - <span class="number">1</span> , a[cnt].y = B - <span class="number">1</span> , a[cnt].rk = i;</span><br><span class="line">b[cnt] = a[cnt].x;</span><br><span class="line">a[++ cnt].x = c , a[cnt].y = B - <span class="number">1</span> , a[cnt].rk = -i;</span><br><span class="line">b[cnt] = a[cnt].x;</span><br><span class="line">a[++ cnt].x = A - <span class="number">1</span> , a[cnt].y = d , a[cnt].rk = -i;</span><br><span class="line">b[cnt] = a[cnt].x;</span><br><span class="line">a[++ cnt].x = c , a[cnt].y = d , a[cnt].rk = i;</span><br><span class="line">b[cnt] = a[cnt].x;</span><br><span class="line">&#125;</span><br><span class="line">sort(b + <span class="number">1</span> , b + cnt + <span class="number">1</span>);</span><br><span class="line">len = unique(b + <span class="number">1</span> , b + cnt + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++) a[i].x = lower_bound(b + <span class="number">1</span> , b + len + <span class="number">1</span> , a[i].x) - b;</span><br><span class="line">sort(a + <span class="number">1</span> , a + cnt + <span class="number">1</span> , cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].p)</span><br><span class="line">&#123;</span><br><span class="line">add(a[i].x , a[i].power);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k = <span class="built_in">abs</span>(a[i].rk);</span><br><span class="line"><span class="keyword">if</span>(a[i].rk &lt; <span class="number">0</span>) ans[k] -= query(a[i].x);</span><br><span class="line"><span class="keyword">else</span> ans[k] += query(a[i].x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span> , ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3755&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="树状数组" scheme="http://zyx02.github.io/blog/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="二维偏序" scheme="http://zyx02.github.io/blog/tags/%E4%BA%8C%E7%BB%B4%E5%81%8F%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>[题解？]NOIP2014飞扬的小鸟</title>
    <link href="http://zyx02.github.io/blog/2021/08/27/%E9%A2%98%E8%A7%A3%EF%BC%9F-NOIP2014%E9%A3%9E%E6%89%AC%E7%9A%84%E5%B0%8F%E9%B8%9F/"/>
    <id>http://zyx02.github.io/blog/2021/08/27/题解？-NOIP2014飞扬的小鸟/</id>
    <published>2021-08-27T15:40:32.000Z</published>
    <updated>2021-08-27T15:51:52.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/P1941" target="_blank" rel="noopener">洛谷</a></p><h2 id="题解？"><a href="#题解？" class="headerlink" title="题解？"></a>题解？</h2><p>dp方程还是比较好推的吧……但是有一些细节需要注意。</p><p>这是我一开始80分的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , k;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">10010</span>] , y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">10010</span>] , h[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = read() , m = read() , k = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  x[i] = read() , y[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j ++) dp[i][j] = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p = read();</span><br><span class="line">l[p] = read() , h[p] = read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!h[i]) h[i] = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l[<span class="number">0</span>] + <span class="number">1</span>; i &lt; h[<span class="number">0</span>]; i ++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = l[i] + <span class="number">1</span>; j &lt; h[i]; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j == m)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> q = x[i]; q &gt;= <span class="number">0</span>; q --) dp[i][j] = min(dp[i][j] , min(dp[i - <span class="number">1</span>][m - q] , dp[i][m - q]) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(j &gt; x[i]) dp[i][j] = min(dp[i][j] , min(dp[i - <span class="number">1</span>][j - x[i]] , dp[i][j - x[i]]) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(j + y[i] &lt;= m) dp[i][j] = min(dp[i][j] , dp[i - <span class="number">1</span>][j + y[i]]);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l[n] + <span class="number">1</span>; i &lt; h[n]; i ++) ans = min(ans , dp[n][i]);</span><br><span class="line"><span class="keyword">if</span>(ans &lt; <span class="number">2e9</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n%d\n"</span> , ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = l[i] + <span class="number">1</span>; j &lt; h[i]; j ++)</span><br><span class="line">  ans = min(ans , dp[i][j]);</span><br><span class="line"><span class="keyword">if</span>(ans &lt; <span class="number">2e9</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt;= i; kk ++) <span class="keyword">if</span>(h[kk] &lt;= m) tot ++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , tot);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>80分的原因主要是在转移时出现错误，在洛谷这篇讨论中有详细的解答</p><p><a href="https://www.luogu.com.cn/discuss/show/161965" target="_blank" rel="noopener">链接</a></p><p>主要是由于我在转移的时候只考虑在管道间的高度，这样会导致忽略了一些中间的情况，如下面这组样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 1000 2</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 1 10</span><br><span class="line">2 980 990</span><br></pre></td></tr></table></figure><p>在第二个管道转移时由于我只枚举了$980$~$990$,导致$980$之前$dp$值全为inf，无法转移，但事实上小鸟可以多次跳跃，前面的值同样可以用来转移。</p><p>解决方法是先将高度全部枚举一遍，最后再把$0$~$l$和$h$~$m$的值赋为inf</p><p>果然我还是太菜了啊……</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , k;</span><br><span class="line"><span class="keyword">int</span> x[<span class="number">10010</span>] , y[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">10010</span>] , h[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = read() , m = read() , k = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  x[i] = read() , y[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span> * m; j ++) dp[i][j] = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p = read();</span><br><span class="line">l[p] = read() , h[p] = read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!h[i]) h[i] = m + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l[<span class="number">0</span>] + <span class="number">1</span>; i &lt; h[<span class="number">0</span>]; i ++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = x[i] + <span class="number">1</span>; j &lt;= x[i] + m; j ++) </span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = min(dp[i][j] , min(dp[i - <span class="number">1</span>][j - x[i]] , dp[i][j - x[i]]) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = m + <span class="number">1</span>; j &lt;= x[i] + m; j ++) dp[i][m] = min(dp[i][m] , dp[i][j]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = l[i] + <span class="number">1</span>; j &lt; h[i]; j ++) <span class="keyword">if</span>(j + y[i] &lt;= m) dp[i][j] = min(dp[i - <span class="number">1</span>][j + y[i]] , dp[i][j]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= l[i]; j ++) dp[i][j] = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = h[i]; j &lt;= m; j ++) dp[i][j] = <span class="number">2e9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = l[n] + <span class="number">1</span>; i &lt; h[n]; i ++) ans = min(ans , dp[n][i]);</span><br><span class="line"><span class="keyword">if</span>(ans &lt; <span class="number">2e9</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1\n%d\n"</span> , ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = l[i] + <span class="number">1</span>; j &lt; h[i]; j ++)</span><br><span class="line">  ans = min(ans , dp[i][j]);</span><br><span class="line"><span class="keyword">if</span>(ans &lt; <span class="number">2e9</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt;= i; kk ++) <span class="keyword">if</span>(h[kk] &lt;= m) tot ++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , tot);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1941&quot; target=&quot;_blan
      
    
    </summary>
    
    
      <category term="背包" scheme="http://zyx02.github.io/blog/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="动态规划" scheme="http://zyx02.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[题解]CF383C Propagating tree</title>
    <link href="http://zyx02.github.io/blog/2021/08/27/%E9%A2%98%E8%A7%A3-CF383C-Propagating-tree/"/>
    <id>http://zyx02.github.io/blog/2021/08/27/题解-CF383C-Propagating-tree/</id>
    <published>2021-08-27T15:23:54.000Z</published>
    <updated>2021-08-27T15:39:12.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/CF383C" target="_blank" rel="noopener">洛谷</a></p><p><a href="https://codeforces.com/problemset/problem/383/C" target="_blank" rel="noopener">CF</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目要求对给定的$u$节点的子树进行操作，使其$0$级节点加上$val$，$1$级节点减去$val$，$2$级节点加上$val$，以此类推。</p><p>由于对子树进行操作，考虑节点的$dfs$序，计算每个节点第一次被访问和回溯时的时间戳，则它的子树$dfs$序都在这段区间内，由此将树上修改转化为区间修改。</p><p>观察到一个节点加上或减去$val$与其深度的奇偶性有关，假定根节点深度为$1$。我们在以深度为奇数的节点的子树修改时令整个区间加上$val$，深度为偶数的节点的子树修改时令整个区间加上$-val$，输出时奇数深度的节点加上修改的值，偶数深度的节点减去修改的值即可解决。</p><p>由于题目要求区间修改单点查询，可以用树状数组解决。注意初始值不受影响。所以不需要进行初始化(注释部分)，在输出时加上初始值即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> Black[MAXN] , White[MAXN] , ti;</span><br><span class="line"><span class="keyword">int</span> head[MAXN] , cnt , val[MAXN] , depth[MAXN];</span><br><span class="line"><span class="keyword">int</span> tree[MAXN] , id[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> To , Nxt;</span><br><span class="line">&#125;edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> From , <span class="keyword">int</span> To)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++ cnt].Nxt = head[From];</span><br><span class="line">edge[cnt].To = To;</span><br><span class="line">head[From] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k , <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">depth[k] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">Black[k] = ++ ti;</span><br><span class="line">id[ti] = k;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[k]; i; i = edge[i].Nxt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = edge[i].To;</span><br><span class="line"><span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v , k);</span><br><span class="line">&#125;</span><br><span class="line">White[k] = ti;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(pos &lt;= n) tree[pos] += w , pos += lowbit(pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(pos) sum += tree[pos] , pos -= lowbit(pos);</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = read() , m = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) val[i] = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = read() , v = read();</span><br><span class="line">add(u , v) , add(v , u);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line"><span class="comment">//for(int i = 2; i &lt;= n; i ++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//Add(i , val[id[i]] - val[id[i - 1]]);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> op = read();</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = read() , val = read();</span><br><span class="line"><span class="keyword">if</span>(depth[x] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">  Add(Black[x] , val) , Add(White[x] + <span class="number">1</span> , -val);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  Add(Black[x] , -val) , Add(White[x] + <span class="number">1</span> , val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = read();</span><br><span class="line"><span class="keyword">int</span> s = query(Black[x]);</span><br><span class="line"><span class="keyword">if</span>(depth[x] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , val[x] + s);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span> , val[x] - s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/CF383C&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="dfs序" scheme="http://zyx02.github.io/blog/tags/dfs%E5%BA%8F/"/>
    
      <category term="树状数组" scheme="http://zyx02.github.io/blog/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>[题解]CF484E Sign on Fence</title>
    <link href="http://zyx02.github.io/blog/2021/08/25/%E9%A2%98%E8%A7%A3-CF484E-Sign-on-Fence/"/>
    <id>http://zyx02.github.io/blog/2021/08/25/题解-CF484E-Sign-on-Fence/</id>
    <published>2021-08-25T15:38:21.000Z</published>
    <updated>2021-08-25T15:55:36.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.luogu.com.cn/problem/CF484E" target="_blank" rel="noopener">洛谷</a> </p><p><a href="http://codeforces.com/problemset/problem/484/E" target="_blank" rel="noopener">CF</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>看到题目问的是最小值的最大值，显然可以二分求解</p><p>给出的高度在$10^9$范围内，需要先对高度进行离散化</p><p>假如我们二分出了一个$mid$，怎么判断它是否合法？可以这么解决，将所有数大于等于$mid$的数赋为$1$，其余赋为$0$，那么就是判断$[l,r]$之间是否存在一个长度大于等于$k$的连续的$1$</p><p>可以对所有高度建一棵线段树，维护区间内最长$1$的长度，从左和从右开始最长$1$的长度，但是这样空间复杂度爆炸。我们可以使用主席树来维护。</p><p>可以按高度从大到小建树，保证大于等于它的数的位置都赋值了</p><p>初始时要建树计算一下区间长度，否则在pushup时判断时会出错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(tree[ls(k)].lmax &#x3D;&#x3D; tree[ls(k)].len) ···</span><br><span class="line">if(tree[rs(k)].rmax &#x3D;&#x3D; tree[rs(k)].len) ···</span><br></pre></td></tr></table></figure></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls(k) tree[k].ls</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs(k) tree[k].rs</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">   c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , m , cnt , len;</span><br><span class="line"><span class="keyword">int</span> a[MAXN] , b[MAXN] , root[MAXN] , numroot[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hjtTree</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> ls , rs , val , lmax , rmax , len;</span><br><span class="line">&#125;tree[MAXN * <span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[k].val = max(tree[ls(k)].val , tree[rs(k)].val);</span><br><span class="line">tree[k].val = max(tree[ls(k)].rmax + tree[rs(k)].lmax , tree[k].val);</span><br><span class="line"><span class="keyword">if</span>(tree[ls(k)].lmax == tree[ls(k)].len)</span><br><span class="line">  tree[k].lmax = tree[ls(k)].lmax + tree[rs(k)].lmax;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  tree[k].lmax = tree[ls(k)].lmax;</span><br><span class="line"><span class="keyword">if</span>(tree[rs(k)].rmax == tree[rs(k)].len)</span><br><span class="line">  tree[k].rmax = tree[rs(k)].rmax + tree[ls(k)].rmax;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  tree[k].rmax = tree[rs(k)].rmax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> pre , <span class="keyword">int</span> &amp;now , <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tree[++ cnt] = tree[pre];</span><br><span class="line">now = cnt;</span><br><span class="line">tree[now].len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r)</span><br><span class="line">&#123;</span><br><span class="line">tree[now].lmax = tree[now].rmax = tree[now].val = tree[now].len = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(pos &lt;= mid) update(l , mid , ls(pre) , ls(now) , pos);</span><br><span class="line"><span class="keyword">else</span> update(mid + <span class="number">1</span> , r , rs(pre) , rs(now) , pos);</span><br><span class="line">pushup(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> now , <span class="keyword">int</span> sl , <span class="keyword">int</span> sr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l &gt;= sl <span class="keyword">and</span> r &lt;= sr) <span class="keyword">return</span> tree[now].val;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> , s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(sl &lt;= mid) s = max(s , query(l , mid , ls(now) , sl , sr));</span><br><span class="line"><span class="keyword">if</span>(sr &gt; mid) s = max(s , query(mid + <span class="number">1</span> , r , rs(now) , sl , sr));</span><br><span class="line"><span class="keyword">if</span>(sl &lt;= mid <span class="keyword">and</span> sr &gt; mid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> s1 = min(tree[ls(now)].rmax , mid - sl + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> s2 = min(tree[rs(now)].lmax , sr - mid);</span><br><span class="line">s = max(s , s1 + s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> &amp;now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">now = ++ cnt;</span><br><span class="line">tree[now].len = r - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(l , mid , ls(now));</span><br><span class="line">build(mid + <span class="number">1</span> , r , rs(now));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; id[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l , <span class="keyword">int</span> r , <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sl = <span class="number">1</span> , sr = len , ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(sl &lt;= sr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (sl + sr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(query(<span class="number">1</span> , n , numroot[mid] , l , r) &gt;= k)</span><br><span class="line">  ans = mid , sl = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  sr = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b[ans];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) a[i] = b[i] = read();</span><br><span class="line">sort(b + <span class="number">1</span> , b + n + <span class="number">1</span>);</span><br><span class="line">len = unique(b + <span class="number">1</span> , b + n + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = lower_bound(b + <span class="number">1</span> , b + len + <span class="number">1</span> , a[i]) - b;</span><br><span class="line">id[a[i]].push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">build(<span class="number">1</span> , n , root[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">int</span> node = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> siz = id[i].size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; siz; j ++)</span><br><span class="line">&#123;</span><br><span class="line">node ++;</span><br><span class="line">update(<span class="number">1</span> , n , root[node - <span class="number">1</span>] , root[node] , id[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">numroot[i] = root[node];</span><br><span class="line">&#125;</span><br><span class="line">m = read();</span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l = read() , r = read() , k = read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , solve(l , r , k));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/CF484E&quot; target=&quot;_bla
      
    
    </summary>
    
    
      <category term="主席树" scheme="http://zyx02.github.io/blog/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="二分答案" scheme="http://zyx02.github.io/blog/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>[题解]1912异象石</title>
    <link href="http://zyx02.github.io/blog/2021/08/25/%E9%A2%98%E8%A7%A3-1912%E5%BC%82%E8%B1%A1%E7%9F%B3/"/>
    <id>http://zyx02.github.io/blog/2021/08/25/题解-1912异象石/</id>
    <published>2021-08-25T15:12:33.000Z</published>
    <updated>2021-08-25T16:23:01.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://i.loli.net/2021/08/26/8aBWAbkZDgnevFd.png" alt="problem.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>首先考虑如何求树上的任意个点连通的边集的总长度的最小值</p><p>可以对树上的点进行一次$dfs$求出它们的$dfs$序，将所求点按$dfs$序排序后相邻两点（包括头尾）的距离之和即为使这些点连通的边集的总长度的最小值的两倍</p><p>如图（蓝色为各点$dfs$序）</p><p><img src="https://i.loli.net/2021/08/26/4k912bcTBXaDINu.jpg" alt="Inkedgraph _1__LI.jpg"></p><p>假设我们要让$1,2,3,5$连通</p><p>按$dfs$序排序后得到$1,3,5,2$</p><p>$dis(1,3)+dis(3,5)+dis(5,2)+dis(2,1)=5+15+11+1$</p><p>观察发现每条边都被计算两次，所以结果是答案的$2$倍</p><p>有了以上结论后，我们可以得出一个算法，使用平衡树或$set$维护所有异象石的$dfs$序，每次插入一个新的异象石$k$时，查找到它在已有异象石中的前驱和后继，假设为$i,j$，更新$ans$，令其减去$dis(i,j)$并加上$dis(i,k)+dis(k,j)$。同理，删除操作则令$ans$加上$dis(i,j)$减去$dis(i,k)+dis(k,j)$</p><p>注意特判边界</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span> (c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">            f = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n, m, cnt, head[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dist[MAXN], tot, f[<span class="number">30</span>][MAXN], depth[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> To, Nxt, Dis;</span><br><span class="line">&#125; edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> From, <span class="keyword">int</span> To, <span class="keyword">int</span> Dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[++cnt].Dis = Dis;</span><br><span class="line">    edge[cnt].Nxt = head[From];</span><br><span class="line">    edge[cnt].To = To;</span><br><span class="line">    head[From] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    dfn[k] = tot;</span><br><span class="line">    f[<span class="number">0</span>][k] = fa;</span><br><span class="line">    depth[k] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[k]; i; i = edge[i].Nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = edge[i].To;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dist[v] = dist[k] + edge[i].Dis;</span><br><span class="line">        dfs(v, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            f[j][i] = f[j - <span class="number">1</span>][f[j - <span class="number">1</span>][i]];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">20</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">if</span> (depth[f[j][x]] &gt;= depth[y])</span><br><span class="line">            x = f[j][x];</span><br><span class="line">    <span class="keyword">if</span> (x == y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">20</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">if</span> (f[j][x] != f[j][y])</span><br><span class="line">            x = f[j][x], y = f[j][y];</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">0</span>][x];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">int</span> id[MAXN];</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = Lca(x, y);</span><br><span class="line">    <span class="keyword">return</span> dist[x] + dist[y] - <span class="number">2</span> * dist[t];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read(), y = read(), z = read();</span><br><span class="line">        add(x, y, z), add(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        id[dfn[i]] = i;</span><br><span class="line">    prework();</span><br><span class="line">    m = read();</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;ch);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = read();</span><br><span class="line">            <span class="keyword">if</span> (s.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                s.insert(dfn[x]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.lower_bound(dfn[x]);</span><br><span class="line">            <span class="keyword">if</span> (it == s.begin())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> y = *it;</span><br><span class="line">                <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it1 = --s.end();</span><br><span class="line">                <span class="keyword">int</span> z = *it1;</span><br><span class="line">                ans += (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (it == s.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    it--;</span><br><span class="line">                    <span class="keyword">int</span> y = *it;</span><br><span class="line">                    <span class="keyword">int</span> z = *s.begin();</span><br><span class="line">                    ans += (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> y = *it;</span><br><span class="line">                    <span class="keyword">if</span> (it != s.begin())</span><br><span class="line">                        it--;</span><br><span class="line">                    <span class="keyword">int</span> z = *it;</span><br><span class="line">                    ans += (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(dfn[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = read();</span><br><span class="line">            <span class="keyword">if</span> (s.size() == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s.erase(dfn[x]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.find(dfn[x]);</span><br><span class="line">            <span class="keyword">if</span> (it == s.begin())</span><br><span class="line">            &#123;</span><br><span class="line">                it++;</span><br><span class="line">                <span class="keyword">int</span> y = *it;</span><br><span class="line">                <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it1 = --s.end();</span><br><span class="line">                <span class="keyword">int</span> z = *it1;</span><br><span class="line">                ans -= (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator End = s.end();</span><br><span class="line">                End--;</span><br><span class="line">                <span class="keyword">if</span> (it == End)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (it != s.begin())</span><br><span class="line">                        it--;</span><br><span class="line">                    <span class="keyword">int</span> y = *it;</span><br><span class="line">                    <span class="keyword">int</span> z = *s.begin();</span><br><span class="line">                    ans -= (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    it++;</span><br><span class="line">                    <span class="keyword">int</span> y = *it;</span><br><span class="line">                    it--, it--;</span><br><span class="line">                    <span class="keyword">int</span> z = *it;</span><br><span class="line">                    ans -= (calc(x, id[y]) + calc(x, id[z]) - calc(id[y], id[z]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            s.erase(dfn[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'?'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/26/8aBWAbkZDgnevFd.png&quot; a
      
    
    </summary>
    
    
      <category term="LCA,最近公共祖先" scheme="http://zyx02.github.io/blog/tags/LCA-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
      <category term="set" scheme="http://zyx02.github.io/blog/tags/set/"/>
    
      <category term="dfs序" scheme="http://zyx02.github.io/blog/tags/dfs%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>[题解]1037道路重建</title>
    <link href="http://zyx02.github.io/blog/2021/08/25/%E9%A2%98%E8%A7%A3-1037%E9%81%93%E8%B7%AF%E9%87%8D%E5%BB%BA/"/>
    <id>http://zyx02.github.io/blog/2021/08/25/题解-1037道路重建/</id>
    <published>2021-08-25T10:01:03.000Z</published>
    <updated>2021-08-25T16:22:40.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://i.loli.net/2021/08/26/D6MNU7oQhIz2Skq.png" alt="problem.png"></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>记$dp[i][j]$表示在以$i$为根的子树中保留$j$个牛棚需要摧毁的最小道路数，显然$dp[i][1]$等于与$i$相连的道路数。</p><p>对于所有的$v \in son_{i}$,我们可以枚举在$v$的子树中保留的牛棚树进行转移。方程:</p><p>$dp_{k,j} = min(dp[k][j - l] + dp[v][l] - 2)$ $(1&lt;=j&lt;=p,1&lt;=l&lt;j)$</p><p>注意转移中的$-2$,这是由于在$dp[k][j-l]和dp[v][l]$中，$k与v$的连边都被计算了一次，实际上这条边需要保留</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n , p;</span><br><span class="line"><span class="keyword">int</span> Size[<span class="number">160</span>] , Son[<span class="number">160</span>][<span class="number">160</span>] , tot[<span class="number">160</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">160</span>][<span class="number">160</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tot[k] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Size[k]; i ++)</span><br><span class="line">&#123;</span><br><span class="line">tot[k] += dfs(Son[k][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tot[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> k , <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Son[k][<span class="number">1</span>] == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Size[k]; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> v = Son[k][i];</span><br><span class="line"><span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">Dfs(v , k);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = p; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; j; l ++)</span><br><span class="line">&#123;</span><br><span class="line">dp[k][j] = min(dp[k][j] , dp[k][j - l] + dp[v][l] - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = read() , p = read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u = read() , v = read();</span><br><span class="line">Son[u][++ Size[u]] = v;</span><br><span class="line">Son[v][++ Size[v]] = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp , <span class="number">0x3f</span> , <span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) dp[i][<span class="number">1</span>] = Size[i];</span><br><span class="line">Dfs(<span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) ans = min(ans , dp[i][p]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/08/26/D6MNU7oQhIz2Skq.png&quot; a
      
    
    </summary>
    
    
      <category term="背包" scheme="http://zyx02.github.io/blog/tags/%E8%83%8C%E5%8C%85/"/>
    
      <category term="树形动态规划" scheme="http://zyx02.github.io/blog/tags/%E6%A0%91%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>题解P1005Divisible</title>
    <link href="http://zyx02.github.io/blog/2021/08/25/%E9%A2%98%E8%A7%A3P1005Divisible/"/>
    <id>http://zyx02.github.io/blog/2021/08/25/题解P1005Divisible/</id>
    <published>2021-08-25T06:28:08.000Z</published>
    <updated>2021-08-25T06:45:15.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>设$F[i]$为斐波那契数列的第$i$项，其中$F[1]=1,F[2]=1$。</p><p>给定$a,b$，判断$F[a]$能否整除$F[b]$,如果能输出1，否则输出0</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先说结论，若$n|m$,则$F[n]|F[m]$。</p><p>证明：</p><p>首先</p><p>$F[n] = F[n-1]+F[n-2]$</p><p>$F[n] = 2F[n-2]+F[n-3]$</p><p>$F[n] = 3F[n-3] + 2F[n-4]$</p><p>……</p><p>$F[n] = F[m]F[n-m+1]+F[m-1][n-m]$</p><p>先证$gcd(F[n],F[m])=F[gcd(n,m)]$</p><p>$gcd(F[n],F[m])$</p><p>= $gcd(F[m]F[n-m+1]+F[m-1]F[n-m],F[m])$</p><p>= $gcd(F[n-m],F[m])$</p><p>一直递推下去可以得到$gcd(F[n],F[m])=F[gcd(n,m)]$</p><p>再回到本题</p><p>若$F[n]|F[m]$,有$gcd(F[n],F[m])=F[n]$</p><p>所以$gcd(n,m)=n$</p><p>所以$n|m$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目大意&quot;&gt;&lt;a href=&quot;#题目大意&quot; class=&quot;headerlink&quot; title=&quot;题目大意&quot;&gt;&lt;/a&gt;题目大意&lt;/h2&gt;&lt;p&gt;设$F[i]$为斐波那契数列的第$i$项，其中$F[1]=1,F[2]=1$。&lt;/p&gt;
&lt;p&gt;给定$a,b$，判断$F[a]
      
    
    </summary>
    
    
      <category term="数学" scheme="http://zyx02.github.io/blog/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="斐波那契" scheme="http://zyx02.github.io/blog/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>群机器人食用指北</title>
    <link href="http://zyx02.github.io/blog/2020/02/09/%E7%BE%A4%E6%9C%BA%E5%99%A8%E4%BA%BA%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://zyx02.github.io/blog/2020/02/09/群机器人食用指北/</id>
    <published>2020-02-09T01:00:44.000Z</published>
    <updated>2021-08-25T15:41:22.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Last-updated-2020-04-10"><a href="#Last-updated-2020-04-10" class="headerlink" title="Last updated:2020/04/10"></a>Last updated:2020/04/10</h2><h3 id="1-萌化自定义插件"><a href="#1-萌化自定义插件" class="headerlink" title="1 萌化自定义插件"></a>1 <a href="https://cqp.cc/t/45660" target="_blank" rel="noopener">萌化自定义插件</a></h3><p>简介：自动回复+一系列的拓展功能</p><p>命令：</p><ul><li>1 翻译(语种) xxx 例：翻译英语你好</li><li>2 群号 返回群号</li><li>3 我 返回自己的QQ名</li><li>4 聊天系统（已禁用）</li><li>5 随机图片 返回一张图片</li><li>6 以图搜图 调用saucenaoAPI,返回与图片相似度&gt;=60%的图片</li><li>7 以图搜番 调用What a animeAPI,返回图片中的番剧</li></ul><h3 id="2-哔哩哔哩-up直播推送-视频下载-动漫聚合"><a href="#2-哔哩哔哩-up直播推送-视频下载-动漫聚合" class="headerlink" title="2 哔哩哔哩-up直播推送/视频下载/动漫聚合"></a>2 <a href="https://cqp.cc/t/38548" target="_blank" rel="noopener">哔哩哔哩-up直播推送/视频下载/动漫聚合</a></h3><p>简介：哔哩哔哩助手</p><p>命令：</p><p>订阅列表 - 查看你订阅的up</p><p>订阅＋UID/名称 - UP新视频与直播推送</p><p>取消订阅＋UID/名称 - 取消订阅，机器人不再提醒</p><p>群订阅列表 - 查看本群订阅的订阅的up</p><p>群订阅＋UID/名称 - UP新视频与直播推送，机器人会在群内提醒</p><p>群取消订阅＋UID/名称 - 取消订阅，机器人不再提醒</p><p>新番 - 查看今天更新的新番</p><p>番剧列表 - 查看目前B站在连载的动画(此功能强制私聊回复)</p><p>追番列表 - 查看你订阅的番剧和番剧ID</p><p>追番＋番剧ID/名称 - 更新前一段时间，机器人会私聊提醒</p><p>取消追番＋番剧ID/名称 - 取消订阅，机器人不再提醒</p><p>群追番列表 - 查看本群订阅的番剧和番剧ID</p><p>群追番＋番剧ID/名称 - 更新前一段时间，机器人会在群内提醒</p><p>群取消追番＋番剧ID/名称 - 取消订阅，机器人不再提醒</p><p>av＋B站AV号- 查获取视频封面和相关信息</p><p>online - 看看大家大家都在看啥</p><p>追番转移＋自己的哔哩哔哩uid/自己的哔哩哔哩昵称 - 转移自己哔哩哔哩的追番列表到机器人</p><p>随便看看 - 看看我们推荐了啥~</p><h3 id="3-少看点二次元吧"><a href="#3-少看点二次元吧" class="headerlink" title="3 少看点二次元吧"></a>3 <a href="https://cqp.cc/t/48173" target="_blank" rel="noopener">少看点二次元吧</a></h3><p>简介：一款ACG插件</p><p>命令：</p><ul><li>1 番剧搜索+番剧名称 例：番剧搜索 某科学的超电磁炮（没给链接时多试几次）</li><li>2 搜索图片+图片 返回原图地址</li><li>3 搜索番剧+图片 返回图片中番剧</li><li>4 随机图片（需pro版）</li><li>5 b站排行榜</li><li>6 AV/BV自动解析</li></ul><h3 id="4-爱音乐"><a href="#4-爱音乐" class="headerlink" title="4 爱音乐"></a>4 <a href="https://cqp.cc/t/14698" target="_blank" rel="noopener">爱音乐</a></h3><p>简介：返回音乐</p><p>命令：</p><ul><li>1 我想听XX/来首XX/点歌XX</li></ul><h3 id="5-小i机器人"><a href="#5-小i机器人" class="headerlink" title="5 小i机器人"></a>5 <a href="https://cqp.cc/t/23073" target="_blank" rel="noopener">小i机器人</a></h3><p>简介：小i机器人</p><p>命令：</p><p>@聊天</p><p><img src="https://i.loli.net/2020/04/08/WUGaJdB2vR6wAfN.png" alt=""></p><h3 id="6-百科搜索"><a href="#6-百科搜索" class="headerlink" title="6 百科搜索"></a>6 <a href="https://cqp.cc/t/47263" target="_blank" rel="noopener">百科搜索</a></h3><p>简介：百科</p><p>命令：</p><ul><li>1 萌娘百科 XX</li></ul><h3 id="7百度百科"><a href="#7百度百科" class="headerlink" title="7百度百科"></a>7<a href="https://cqp.cc/t/48434" target="_blank" rel="noopener">百度百科</a></h3><p>简介：百度百科</p><p>命令：</p><ul><li>1 百科 XX</li></ul><h3 id="8撤回查看"><a href="#8撤回查看" class="headerlink" title="8撤回查看"></a>8<a href="https://cqp.cc/t/47702" target="_blank" rel="noopener">撤回查看</a></h3><p>简介：防撤回</p><p>命令：</p><ul><li>1 查看撤回+X，查看从这条信息往上数的第X条信息，机器人信息不计入条数（需管理员权限）</li></ul><h3 id="9狼人杀"><a href="#9狼人杀" class="headerlink" title="9狼人杀"></a>9<a href="https://cqp.cc/t/34095" target="_blank" rel="noopener">狼人杀</a></h3><p>简介：狼人杀（仅能开启一个群）</p><p>命令：</p><ul><li><p>1 狼人杀加入</p></li><li><p>2 狼人杀退出</p></li></ul><h3 id="10Lxnet复读机"><a href="#10Lxnet复读机" class="headerlink" title="10Lxnet复读机"></a>10<a href="https://cqp.cc/t/46471" target="_blank" rel="noopener">Lxnet复读机</a></h3><p>简介：复读（随机复读，3条信息复读）</p><p>命令：</p><p>无</p><h3 id="11文字象棋"><a href="#11文字象棋" class="headerlink" title="11文字象棋"></a>11<a href="https://cqp.cc/t/41602" target="_blank" rel="noopener">文字象棋</a></h3><p>简介：象棋</p><p>命令：</p><p>象棋 返回帮助</p><h3 id="12文字五子棋"><a href="#12文字五子棋" class="headerlink" title="12文字五子棋"></a>12<a href="https://cqp.cc/t/42251" target="_blank" rel="noopener">文字五子棋</a></h3><p>简介：五子棋</p><p>命令：</p><p>五子棋 返回帮助</p><h3 id="13b站查询"><a href="#13b站查询" class="headerlink" title="13b站查询"></a>13<a href="https://cqp.cc/t/49103" target="_blank" rel="noopener">b站查询</a></h3><p>简介：查询b站个人信息</p><p>命令：</p><p>查询用户+用户名/UID </p><p>勋章包裹+用户名/UID</p><h3 id="14FJT-CTNET-运势"><a href="#14FJT-CTNET-运势" class="headerlink" title="14FJT / CTNET 运势"></a>14<a href="https://cqp.cc/t/48959" target="_blank" rel="noopener">FJT / CTNET 运势</a></h3><p>简介：仿照洛谷的运势系统</p><p>命令：</p><p>@机器人+/运势</p><h3 id="15简单的多功能骰子"><a href="#15简单的多功能骰子" class="headerlink" title="15简单的多功能骰子"></a>15<a href="https://cqp.cc/t/37604" target="_blank" rel="noopener">简单的多功能骰子</a></h3><p>简介：多功能骰子</p><p>命令：</p><p>.帮助 返回帮助</p><h3 id="16Mr-five斗地主"><a href="#16Mr-five斗地主" class="headerlink" title="16Mr.five斗地主"></a>16<a href="https://cqp.cc/t/32764" target="_blank" rel="noopener">Mr.five斗地主</a></h3><p>简介：斗地主</p><p>命令</p><p>命令列表 返回所有命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Last-updated-2020-04-10&quot;&gt;&lt;a href=&quot;#Last-updated-2020-04-10&quot; class=&quot;headerlink&quot; title=&quot;Last updated:2020/04/10&quot;&gt;&lt;/a&gt;Last updated:2020
      
    
    </summary>
    
    
      <category term="工具" scheme="http://zyx02.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>2019CSP-J游记</title>
    <link href="http://zyx02.github.io/blog/2019/12/13/2019CSP-J%E6%B8%B8%E8%AE%B0/"/>
    <id>http://zyx02.github.io/blog/2019/12/13/2019CSP-J游记/</id>
    <published>2019-12-13T15:11:47.000Z</published>
    <updated>2021-08-25T15:41:26.003Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Day-6"><a href="#Day-6" class="headerlink" title="$Day-6$"></a>$Day-6$</h3><p>听说今年不能去福州<del>玩狼人杀</del>比赛了，在本市考，有点难受</p><p>机房颓颓颓，日常被神仙们虐</p><h3 id="Day-5"><a href="#Day-5" class="headerlink" title="$Day-5$"></a>$Day-5$</h3><p>下午去东海一中参加模拟赛（密码是怀念NOIP），$t1t2$有点太水了，秒切。$t3t4$拿暴力分滚粗。</p><p>考场出来听一堆人讨论$t3t4$正解，心里慌得一匹。才发现$t3$正解就是在暴力（差分）的基础上加上一个离散化。。。我$dzm$了，$t4$正解线段树+$dp$?什么神仙操作。。。</p><p>最后$100+100+50+70=320$自闭了/kk</p><h3 id="Day-4-Day-1"><a href="#Day-4-Day-1" class="headerlink" title="$Day-4$~$Day-1$"></a>$Day-4$~$Day-1$</h3><p>日常改题，颓废，被神仙们吊打，不用上文化课的感觉真好。</p><p>这几天晚上都在公安局吃饭，没想到<del>牢饭</del>公安局的饭还是挺好吃的。</p><p>吃完饭在小七的操场散散步，才发现小七竟有如此美丽的景色。傍晚的微风吹拂在脸颊上，望着操场上挥洒汗水的跑步者，与周围的好友开几个玩笑，一天的疲惫也随之而去。</p><p><del><strong>以上均为想象</strong></del></p><p>吃完饭偶尔去嘲讽一下还在上课的同学，<del>真是快乐</del>。</p><h3 id="Day0"><a href="#Day0" class="headerlink" title="$Day0$"></a>$Day0$</h3><p>明天就是$CSP$了，按照以往的惯例都会由初三大佬来给我这种蒟蒻分享心得，但是今年由于某些不可抗力因素比如<del>wxn</del>，导致初三参赛人数较少。所以今年就由我们这届来分享心得</p><p>传送门:<a href="https://www.luogu.com.cn/blog/Computer2020/qian-tan-manacher-suan-fa-zai-oi-zhong-di-ying-yong-by-wkahpm" target="_blank" rel="noopener">蒟蒻的总结报告</a> | <a href="https://zyx02.github.io/blog/2019/11/15/%E6%B5%85%E8%B0%88Manacher%E7%AE%97%E6%B3%95%E5%9C%A8OI%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-CSP%E8%B5%9B%E5%89%8D%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94by-WKAHPM/#more">在hexo博客上查看</a></p><p>讲的好紧张啊，感觉是讲的最烂的一个了/kk。</p><h3 id="Day1"><a href="#Day1" class="headerlink" title="$Day1$"></a>$Day1$</h3><p>今天就是$CSP$了！</p><p>早上起来打了道<a href="https://www.luogu.com.cn/problem/P3952" target="_blank" rel="noopener">大模拟</a>，感觉良好（<del>然后下午就爆零了</del>）</p><p>来到一中，日常膜神仙。</p><p>进考场，打开一看——一脸懵逼</p><p>感觉$t1$越来越水了，秒切。到$9012$是不是$t1$出个输出$Hello,world!$?</p><p>$t2$第一眼看跟海港貌似有点类似，于是开始打队列。结果发现审错题意了，推到重来，这次用了个手工队。一直怕时间复杂度是$O(N^2)$结果想想发现其实是$O(45N)$的。。。害我担心了这么久。</p><p>手打队列完，小数据都过了，到了大数据，答案不一样？！内心直接崩掉。</p><p>于是开始乱搞，吧手工队换成$stl$就过了？$stl$好啊！</p><p>有了去年的经验，今年先开$t4$，考场发现了一个奇偶性质但是不知道怎么用，难受。只能拿$40$部分分滚粗。</p><p>$t3$一脸懵逼，$10$分特判滚粗。</p><p>预估$100+100+10+40=250$自闭了/kk</p><p>出考场后发现$t3t4$都是原题？？？（$CCF$是懒得出题了）</p><p>$t3$是多次的完全背包，$t4$是根据奇偶性广搜，当场自闭。</p><h3 id="Few-Days-Later"><a href="#Few-Days-Later" class="headerlink" title="$Few$ $Days$ $Later$"></a>$Few$ $Days$ $Later$</h3><p>在各个$OJ$上自测了,基本上都是在$250-260$之间，看来$250$实锤了。</p><h3 id="Day-N"><a href="#Day-N" class="headerlink" title="$Day N$"></a>$Day N$</h3><p>出成绩了，果然$100+100+10+40=250$，自闭/kk</p><p>分数线是$210$，终于拿了一次<del>省一</del>了(虽然现在好像叫评级？）</p><p>希望明年能取得更好的成绩吧</p><p>$the$ $end.$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Day-6&quot;&gt;&lt;a href=&quot;#Day-6&quot; class=&quot;headerlink&quot; title=&quot;$Day-6$&quot;&gt;&lt;/a&gt;$Day-6$&lt;/h3&gt;&lt;p&gt;听说今年不能去福州&lt;del&gt;玩狼人杀&lt;/del&gt;比赛了，在本市考，有点难受&lt;/p&gt;
&lt;p&gt;机房颓颓颓，日常被
      
    
    </summary>
    
    
      <category term="游记" scheme="http://zyx02.github.io/blog/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="CSP" scheme="http://zyx02.github.io/blog/tags/CSP/"/>
    
  </entry>
  
  <entry>
    <title>题解 P3115 【[USACO15JAN]牛路线Cow Routing】</title>
    <link href="http://zyx02.github.io/blog/2019/12/11/%E9%A2%98%E8%A7%A3-P3115-%E3%80%90-USACO15JAN-%E7%89%9B%E8%B7%AF%E7%BA%BFCow-Routing%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/12/11/题解-P3115-【-USACO15JAN-牛路线Cow-Routing】/</id>
    <published>2019-12-11T14:10:37.000Z</published>
    <updated>2019-12-11T14:12:18.143Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="-1.前置知识"></a>-1.前置知识</h4><p>最短路，图论</p><h4 id="0-大体思路"><a href="#0-大体思路" class="headerlink" title="0.大体思路"></a>0.大体思路</h4><p>对每条航线进行<strong>建边</strong>处理，同时记录两个城市之间的城市数(这里题目中的经过多少城市指从$u$到$v$<strong>不包括首/尾</strong>的城市数)，然后跑$Dijkstra$即可</p><h4 id="1-建边"><a href="#1-建边" class="headerlink" title="1.建边"></a>1.建边</h4><p>本题由于边数较多，采用邻接矩阵存图较为合适。</p><p>定义$cost[i][j]$表示从$i$到$j$的最少费用，$to[i][j]$表示<strong>在费用最少的情况下</strong>从$i$到$j$所经过的最少城市数</p><p>假设一条航线的费用是$money$,有$len$个城市，对应的编号分别为$x_{1},x_{2},···,x_{len}$</p><p>首先要明确一个常识性问题：在一条航线上，一个城市<strong>不能飞到它之前的城市</strong></p><p>所以我们可以得到一个显然的建边方法，对于一条航线的$x_{i}$，向$x_{j}(i&lt;j&lt;=len)$建一条长度为$money$的边。需要注意的是，如果之前$cost[i][j]$已赋值，则</p><ul><li><p>如果$money&lt;cost[i][j]$，需要更新$cost[i][j],to[i][j]$</p></li><li><p>如果$money=cost[i][j]$，则如果$i$到$j$之间的城市数$&lt;to[i][j]$，更新$to[i][j]$</p></li></ul><p>这样就可以满足<strong>在花费最少的情况下</strong>经过的城市数最少</p><h4 id="2-Dijkstra"><a href="#2-Dijkstra" class="headerlink" title="2.Dijkstra"></a>2.Dijkstra</h4><p>定义$c[i]$为起点到$i$的最少花费，$ans[i]$为起点到$i$之间经过的城市数</p><p>假设当前从城市$k$开始拓展。</p><p>如果$k$与某个城市$i$有连边$cost[k][i]$，我们可以类比之前建边的方法进行更新。</p><ul><li><p>如果$c[k]+cost[k][i]&lt;c[i]$，更新$c[i],ans[i]$</p></li><li><p>如果$c[k]+cost[k][i]=c[i]$，如果$ans[k]+to[k][i]&lt;ans[i]$，更新$ans[i]$</p></li></ul><p>其中$ans[i]$的更新是指$ans[i]=ans[k]+to[k][i]$</p><p>根据定义，$ans[i]$表示起点到$i$的城市数，$ans[k]$表示起点到$k$的城市数，$to[k][i]$表示$k$到$i$之间的城市数，所以很明显有$ans[i]=ans[k]+to[k][i]$</p><h4 id="3-Code"><a href="#3-Code" class="headerlink" title="3.Code"></a>3.Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span><span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">                c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sum = (sum &lt;&lt; <span class="number">1</span>) + (sum &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">                c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a, b, n, len, maxn;</span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">1010</span>][<span class="number">1010</span>], x[<span class="number">10010</span>], to[<span class="number">1010</span>][<span class="number">1010</span>], money, ans[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> c[<span class="number">1010</span>];<span class="comment">//别忘了开long long</span></span><br><span class="line">priority_queue&lt;pair &lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span><span class="comment">//堆优化Dij</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++) c[i] = LONG_LONG_MAX;</span><br><span class="line">        c[a] = <span class="number">0</span>;</span><br><span class="line">        q.push(make_pair(<span class="number">0</span>, a));</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">int</span> k = q.top().second;</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(vis[k]) <span class="keyword">continue</span>;</span><br><span class="line">                vis[k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">                        <span class="keyword">if</span>(cost[k][i] != <span class="number">1e9</span> + <span class="number">10</span>)<span class="comment">//有连边</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">if</span>(c[i] &gt; c[k] + cost[k][i])</span><br><span class="line">                                &#123;</span><br><span class="line">                                        c[i] = c[k] + cost[k][i];</span><br><span class="line">                                        ans[i] = ans[k] + to[k][i];</span><br><span class="line">                                        q.push(make_pair(-c[i], i));</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(c[i] == c[k] + cost[k][i])</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                <span class="keyword">if</span>(ans[i] &gt; ans[k] + to[k][i]) ans[i] = ans[k] + to[k][i];</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1010</span>; j++)</span><br><span class="line">                        cost[i][j] = <span class="number">1e9</span> + <span class="number">10</span>;<span class="comment">//赋初值</span></span><br><span class="line">        <span class="built_in">memset</span>(to, <span class="number">127</span>, <span class="keyword">sizeof</span>(to));<span class="comment">//赋初值</span></span><br><span class="line">        a = read(), b = read(), n = read();</span><br><span class="line">        <span class="comment">//建边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                money = read(), len = read();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)</span><br><span class="line">                        x[j] = read(), maxn = max(maxn, x[j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= len; k++)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">if</span>(cost[x[j]][x[k]] &gt; money)</span><br><span class="line">                                        cost[x[j]][x[k]] = money, to[x[j]][x[k]] = k - j;<span class="comment">//k-j就是j到k之间的城市数（不包含首尾）</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">if</span>(cost[x[j]][x[k]] == money)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(k - j &lt; to[x[j]][x[k]])</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                to[x[j]][x[k]] = k - j;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Dijkstra();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c[b] != LONG_LONG_MAX)<span class="comment">//判断是否能到达</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld %d"</span>, c[b], ans[b]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1 -1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-前置知识&quot;&gt;&lt;a href=&quot;#1-前置知识&quot; class=&quot;headerlink&quot; title=&quot;-1.前置知识&quot;&gt;&lt;/a&gt;-1.前置知识&lt;/h4&gt;&lt;p&gt;最短路，图论&lt;/p&gt;
&lt;h4 id=&quot;0-大体思路&quot;&gt;&lt;a href=&quot;#0-大体思路&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="http://zyx02.github.io/blog/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://zyx02.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Manacher算法在OI中的应用&amp;CSP赛前总结——by WKAHPM</title>
    <link href="http://zyx02.github.io/blog/2019/11/15/%E6%B5%85%E8%B0%88Manacher%E7%AE%97%E6%B3%95%E5%9C%A8OI%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-CSP%E8%B5%9B%E5%89%8D%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94by-WKAHPM/"/>
    <id>http://zyx02.github.io/blog/2019/11/15/浅谈Manacher算法在OI中的应用-CSP赛前总结——by-WKAHPM/</id>
    <published>2019-11-15T13:47:40.000Z</published>
    <updated>2019-11-20T12:09:47.578Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-什么是Manacher"><a href="#0-什么是Manacher" class="headerlink" title="0.什么是Manacher"></a>0.什么是Manacher</h4><blockquote><p>Manachar算法主要是处理字符串中关于回文串的问题的，它可以在 O（n） 的时间处理出以字符串中每一个字符为中心的回文串半径——摘自百度百科</p></blockquote><h4 id="1-从暴力谈起"><a href="#1-从暴力谈起" class="headerlink" title="1.从暴力谈起"></a>1.从暴力谈起</h4><p>先看一道例题<a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">洛谷P3805</a></p><p>题意十分简单明了，求一个字符串$S$中的最大回文子串长度</p><p>很容易想到一种$O(N^3)$算法，枚举子串的左边界$l$右边界$r$,判断该子串是否回文即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; len; l ++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> r = l; r &lt; len; r ++)</span><br><span class="line">    <span class="keyword">if</span>(check(l , r)) ans = max(ans , r - l + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在此算法上加入<del>亿</del>一点简单优化可以优化到$O(N^2)$,<strong>对于长度为奇数的回文字符串，回文子串的中心一定是某个字符，对于长度为偶数的回文字符串，回文子串的中心一定是两个字符之间的空隙</strong>，一种显然的作法是枚举这些回文中心，向两边拓展直到字符不相等或到达边界</p><p>由于$WKAHPM$比较懒,所以就不贴代码了。</p><p>暴力的缺点：</p><ul><li>1.需要分类讨论</li><li>2.枚举了很多没用的子串</li></ul><p>这时候我们就需要再加入<del>亿</del>一点优化。</p><h4 id="2-Manacher的初始化"><a href="#2-Manacher的初始化" class="headerlink" title="2.Manacher的初始化"></a>2.Manacher的初始化</h4><blockquote><p>暴力的缺点——需要分类讨论</p></blockquote><p>如何解决这个问题？一种作法是在每个字符之间再加入一个分隔字符（<strong>当然这个字符不能存在在原本的字符串中</strong>），举个栗子,比如字符串$ababac$：</p><div class="table-container"><table><thead><tr><th></th><th>a</th><th></th><th>b</th><th></th><th>a</th><th></th><th>b</th><th></th><th>a</th><th></th><th>c</th><th></th></tr></thead><tbody><tr><td>#</td><td>a</td><td>#</td><td>b</td><td>#</td><td>a</td><td>#</td><td>b</td><td>#</td><td>a</td><td>#</td><td>c</td><td>#</td></tr></tbody></table></div><p>这个方法有效地避免了分类讨论，容易发现我们插入了$N+1$个#号，字符串的长度变为$2N+1$，为奇数，<del>是不是很神奇呢</del></p><p>为了防止越界情况，我们在开头和结尾再加入一个字符，比如$@$，这部分的代码可以这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">news</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s_new += <span class="string">"@#"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">s_new += s[i];</span><br><span class="line">s_new += <span class="string">'#'</span>; </span><br><span class="line">&#125;</span><br><span class="line">s_new += <span class="string">'@'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Manacher的原理"><a href="#3-Manacher的原理" class="headerlink" title="3.Manacher的原理"></a>3.Manacher的原理</h4><p> 定义$p[i]$表示以$i$为对称中心能扩展的<strong>最大回文子串半径</strong>，即左/右边界到对称中心的距离。</p><p>$Manacher$的算法思想就是快速求出$p$数组。</p><p>我们来看看$p$数组与答案的关系(这里省略@)</p><div class="table-container"><table><thead><tr><th>s</th><th>#</th><th>a</th><th>#</th><th>b</th><th>#</th><th>a</th><th>#</th><th>b</th><th>#</th><th>a</th><th>#</th><th>c</th><th>#</th></tr></thead><tbody><tr><td><strong>ans</strong></td><td>0</td><td>1</td><td>0</td><td>3</td><td>0</td><td>5</td><td>0</td><td>3</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td><strong>p</strong></td><td>1</td><td>2</td><td>1</td><td>4</td><td>1</td><td>6</td><td>1</td><td>4</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td></tr></tbody></table></div><p>显然有$ans[i]=p[i]-1$</p><p>证明：</p><p>设回文子串$s$原来的长度为$len$，对称中心为$i$；</p><p>则$s$插入字符后的长度变为$2\times len+1$；</p><p>此时$p[i]=(2\times len+1+1)/2=len+1$,所以$p[i]-1$即为答案</p><p>所以求出$p[i]$就可以求出答案</p><h4 id="4-Manacher的实现"><a href="#4-Manacher的实现" class="headerlink" title="4.Manacher的实现"></a>4.Manacher的实现</h4><p>$Manacher$的实现用到了回文子串的一个性质——对称性</p><p>利用该性质可以有效地避免重复枚举，通过之前枚举过的子串来确定这个点<strong>至少</strong>能扩展的长度</p><p>设$mr$为之前找到的回文子串的最右边，$mid$为该回文子串的对称中心。</p><p>假设当前枚举到第$i$位，因为枚举过$mid$了，所以显然有$i&gt;mid$，接下来需要分类讨论两种情况来快速求出$p[i]$：</p><p>为了方便讨论，设$j$为$i$以$mid$为对称中心的对称点，$s_{i}$是以$i$为对称中心的回文子串，$s_{j}$是以$j$为对称中心的回文子串</p><h5 id="1-i-lt-mr"><a href="#1-i-lt-mr" class="headerlink" title="(1)i &lt; mr"></a>(1)i &lt; mr</h5><p>这时候我们又能分2种情况</p><ul><li>1 $s_{i}$的右边界<strong>不大于</strong>$mr$</li></ul><p>如图</p><p><img src="https://i.loli.net/2019/11/15/fROsdocQh2aIuX8.png" alt="TIM截图20191115112913.png"></p><p>由对称性知，此时$p[i]=p[j]$</p><ul><li>2 $s_{i}$的右边界<strong>大于</strong>$mr$</li></ul><p>如图</p><p><img src="https://i.loli.net/2019/11/15/aoX7wxyB9RrE4md.png" alt="TIM截图20191115132136.png"></p><p>这时我们只能<strong>确定α段是具有对称性的</strong>，此时$p[i]=mr-i$</p><p>也就是说，当$i$在$mr$左边，那么$p[i]$肯定是$mr-i$与$p[j]$的<strong>最小值</strong>。因为$j$与$i$关于$mid$对称，所以在$[i,mr]$这一段内可以<strong>直接使用$p[j]$的值</strong>，但是$i$已知的回文串长度<strong>不能到$mr$后面去</strong>，所以跟$mr-i$取$min$。</p><h5 id="2-i-gt-mr"><a href="#2-i-gt-mr" class="headerlink" title="(2) i &gt;= mr"></a>(2) i &gt;= mr</h5><p>此时我们无法通过对称性得到$p[i]$，所以$p[i]=1$</p><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s_new.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;mx)<span class="comment">//情况1</span></span><br><span class="line">  ans[i]=min(ans[<span class="number">2</span>*id-i],mx-i);</span><br><span class="line"><span class="keyword">else</span><span class="comment">//情况2</span></span><br><span class="line">  ans[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(s_new[i-ans[i]]==s_new[i+ans[i]]) ans[i]++;<span class="comment">//扩展</span></span><br><span class="line"><span class="keyword">if</span>(mx&lt;i+ans[i])<span class="comment">//更新右边界</span></span><br><span class="line">&#123;</span><br><span class="line">id=i;</span><br><span class="line">mx=i+ans[i];</span><br><span class="line">&#125;</span><br><span class="line">maxn=max(maxn,ans[i]<span class="number">-1</span>);<span class="comment">//更新答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h4><p><a href="https://www.luogu.org/problem/P5018" target="_blank" rel="noopener">洛谷P5018对称二叉树</a></p><p>这题可以用$Manacher$来解决。</p><p>可以先用中序遍历对每个节点编号，利用$a$和$size$数组存放每个节点的权值和以这个节点为根节点的二叉树的节点数，对每个数组进行$Manacher$，将先后两次的以第$i$个点为对称中心的最大回文子串半径存放在$p1[i],p2[i]$中。</p><p>另外本题不需要初始化，$Manacher$初始化的原因是可能存在偶数长度的回文子串，但在对称二叉树中不可能存在偶数长度的回文子串，因为在对称二叉树中，除根节点以外每一个左儿子都有一个右儿子与之对应，所以节点数为奇数个。</p><p>求出$p1,p2$后，枚举编号$1$~$N$，判断以$i$为根节点的二叉树是否为对称二叉树，如果是则对$ans$和$size[i]$取$max$，对称二叉树需要满足两个条件：</p><ul><li><p>1 权值对称</p></li><li><p>2 结构对称</p></li></ul><p>体现在程序中就是$p1[i] \times 2 - 1 &gt;= size[i]$并且$p2[i] \times 2 - 1 == size[i]$</p><p>首先解释一下为什么是$p1[i] \times 2 - 1$而不是$p1[i]-1$</p><p>$p1[i] \times 2 - 1$是因为之前的$Manacher$我们没有进行初始化，所以此时的$p1[i]$要乘2</p><p>接着解释一下为什么是$p1[i] \times 2 - 1 &gt;= size[i]$</p><p>如图</p><p><img src="https://i.loli.net/2019/11/15/myUHdKNTeh6Ltbr.png" alt="TIM截图20191115154337.png"></p><p>如果写成$p1[i] \times 2 - 1 == size[i]$的话，则对于编号为$5$的节点，$p1[5] \ times 2 - 1 =5$,而$size[5]=3$，所以当节点权值相等时，可能出现$p1[i] \times 2 - 1 &gt; size[i]$的情况。</p><h4 id="6-结语"><a href="#6-结语" class="headerlink" title="6.结语"></a>6.结语</h4><p>明天就是$CSP$了，大家调整好心态，多背背模板，基本上$t1t2$过了$t3t4$打一下暴力就省一了，祝各位$RP++$(<del>这不是毒奶</del>)</p><p>愿<img src="https://i.loli.net/2019/11/15/2ucSPiy8Qrl3WHz.png" alt="TIM截图20191115171839.png">降临到你身边</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-什么是Manacher&quot;&gt;&lt;a href=&quot;#0-什么是Manacher&quot; class=&quot;headerlink&quot; title=&quot;0.什么是Manacher&quot;&gt;&lt;/a&gt;0.什么是Manacher&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Manachar算法主要是
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://zyx02.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Manacher" scheme="http://zyx02.github.io/blog/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>浅谈OI中的骗分技巧——by WKAHPM</title>
    <link href="http://zyx02.github.io/blog/2019/10/21/%E6%B5%85%E8%B0%88OI%E4%B8%AD%E7%9A%84%E9%AA%97%E5%88%86%E2%80%94%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94by-WKAHPM/"/>
    <id>http://zyx02.github.io/blog/2019/10/21/浅谈OI中的骗分—技巧——by-WKAHPM/</id>
    <published>2019-10-21T14:23:26.000Z</published>
    <updated>2019-11-01T10:01:21.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>在<del>NOIP</del>$CSP$的考场上，很多题目我们在考场上往往无法想到正解（<del>当然大佬除外</del>）。这时候我们就需要一些骗分技巧来为自己争取一些部分分。</p><h2 id="1-骗分的意义"><a href="#1-骗分的意义" class="headerlink" title="1.骗分的意义"></a>1.骗分的意义</h2><p>首先我们要了解什么是子任务。</p><p>对于一道题，它可能存在多个子任务。这些子任务的数据往往具有某些特点或者在某个小范围内，骗分的意义就是在打不出正解的情况下拿到这些子任务的分数。</p><p>例如$2018NOIP$ $T2$中的<a href="https://www.luogu.org/problem/P5016" target="_blank" rel="noopener">龙虎斗</a>，它的子任务分布是这样的</p><p>【数据规模与约定】</p><p>$1 &lt; m &lt; n,1 ≤ p1 ≤ n.$</p><p>对于$20$%的数据,$n = 3, m = 2, ci = 1, s1,s2 ≤ 100$.</p><p>另有$20$%的数据,$n ≤ 10, p1 = m, ci = 1, s1,s2 ≤ 100$.</p><p>对于$20$%的数据,$n = 3, m = 2, ci = 1,s1,s2 ≤ 100$.</p><p>对于$60$%的数据,$n ≤ 100, ci = 1,s1,s2 ≤ 100$.</p><p>对于$80$%的数据,$n ≤ 100, ci,s1,s2 ≤ 100$.</p><p>对于$100$%的数据,$n ≤ 10^5, ci = 1, s1,s2 ≤ 10^9$.</p><p>观察可以发现,$80$%的数据都很小，这时候我们就可以用暴力来拿到这$80$分。</p><h2 id="2-基础的骗分"><a href="#2-基础的骗分" class="headerlink" title="2.基础的骗分"></a>2.基础的骗分</h2><h4 id="1-输样例"><a href="#1-输样例" class="headerlink" title="1.输样例"></a>1.输样例</h4><p>一道题目都会给你输入输出样例，如果你想不出其他解决该问题的方法，可以尝试直接输出样例，这就是考验你$rp$的时候了</p><p>例题：$2018NOIP$ $T4$<a href="https://www.luogu.org/problem/P5018" target="_blank" rel="noopener">对称二叉树</a></p><p>输出第二个样例即$3$可以拿到32分</p><p>没错就是这段代码可以为你拿到32分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("tree.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("tree.out", "w" ,stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一道题目包含无解的情况时，也可以通过输出无解来获得部分分</p><h4 id="2-输出随机数"><a href="#2-输出随机数" class="headerlink" title="2.输出随机数"></a>2.输出随机数</h4><p>这个也是考验$rp$的，根据数据范围输出随机数。</p><p>随机数生成代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand(time(<span class="number">0</span>)); <span class="comment">//随机种子</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span> , rand()%b + a) <span class="comment">//输出一个范围在a~a+b-1的随机数 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是随机数的生成范围在不同操作系统下是不一样的，在Windows下是$0$~$32767$</p><p>由于篇幅限制，基础的骗分技巧不再赘述。</p><h2 id="3-高级骗分技巧"><a href="#3-高级骗分技巧" class="headerlink" title="3.高级骗分技巧"></a>3.高级骗分技巧</h2><h4 id="1-打表"><a href="#1-打表" class="headerlink" title="1.打表"></a>1.打表</h4><p>很多人可能认为打表是最基础的骗分技巧，但是打表也是有艺术的。</p><p>打表的用处很多，例如</p><ul><li><p>1 减小时间复杂度</p></li><li><p>2 找规律</p></li><li><p>3 ······</p></li></ul><p>先说说如何减小时间复杂度。</p><p>当一些题目数据范围很小时，我们可以考虑通过打表使程序运行效率提高，例如$2008NOIP$ $T3$<a href="https://www.luogu.org/problem/P1057" target="_blank" rel="noopener">传球游戏</a></p><p>这是我$90$分的程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">31</span>][<span class="number">31</span>],n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> f[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> f[x][y]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> f[x][y]=dfs(x<span class="number">-1</span>,y<span class="number">-1</span>)+dfs(<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> f[x][y]=dfs(n,y<span class="number">-1</span>)+dfs(x+<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> f[x][y]=dfs(x<span class="number">-1</span>,y<span class="number">-1</span>)+dfs(x+<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dfs(<span class="number">1</span>,m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个程序会被$10$ $29$这个数据给卡超时</p><p>这个时候加入打表就可以完美$AC$这道题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">31</span>][<span class="number">31</span>],n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> f[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> f[x][y]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> f[x][y]=dfs(x<span class="number">-1</span>,y<span class="number">-1</span>)+dfs(<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> f[x][y]=dfs(n,y<span class="number">-1</span>)+dfs(x+<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> f[x][y]=dfs(x<span class="number">-1</span>,y<span class="number">-1</span>)+dfs(x+<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">10</span>&amp;&amp;m==<span class="number">29</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dfs(<span class="number">1</span>,m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序比上一段程序多出来的部分就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n==<span class="number">10</span>&amp;&amp;m==<span class="number">29</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于一些对素数判断存在要求的题目，我们可以预处理出素数表，减少判断的时间。</p><p>大致是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> num)</span> <span class="comment">//快速判断素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">2</span> || num == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; num % <span class="number">6</span> != <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i*i &lt;= num; i += <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num % i == <span class="number">0</span> || num % (i+<span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">                              </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   freopen(<span class="string">"prime.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);<span class="comment">//将表输出到文件里，方便复制</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">      <span class="keyword">if</span>(prime(i)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"i,"</span><span class="comment">//加入逗号方便复制</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候将prime.out里的数字复制到表里就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Prime[LEN]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,···&#125;</span><br></pre></td></tr></table></figure><p>再来说说找规律。</p><p>对于一些题目，我们可以输出一些小数据的答案，观察答案与输入数据的关系，这种方法一般适用于数论题。</p><p>如$1999NOIP$ $T1$? <a href="https://www.luogu.org/problem/P1014" target="_blank" rel="noopener">Cantor表</a></p><p>可以通过行列和答案的关系找出某种规律。</p><p>打表的方式千变万化，所以有着”打表出省一”之说（笑），当然也不能过分依赖打表，造成思维惰性。</p><p><img src="https://i.loli.net/2019/11/01/325E1a4NVZvBecM.jpg" alt="你的NOIP.png"></p><h4 id="2-dfs"><a href="#2-dfs" class="headerlink" title="2.dfs"></a>2.dfs</h4><p>如果你熟练掌握了$dfs$（深度优先搜索），你会发现“万物皆可搜”。</p><p>当一个题目打不出来怎么办？先打个$dfs$，可能这不是最优解，但是$dfs$思路清晰，码量小，可以拿到部分分。而且有时它也可以便于你想出正解。动态规划的思想有部分就来自于搜索。</p><p>例如$2018NOIP$ $T4$<a href="https://www.luogu.org/problem/P5018" target="_blank" rel="noopener">对称二叉树</a></p><p>如果你熟练掌握了二叉树的知识，你会很容易写出一个$dfs$，而$dfs$就是这道题目的正解。。。</p><p>所以万物皆可搜 万物皆可搜 万物皆可搜</p><h4 id="3-灵活运用子任务的数据范围或数据特点"><a href="#3-灵活运用子任务的数据范围或数据特点" class="headerlink" title="3.灵活运用子任务的数据范围或数据特点"></a>3.灵活运用子任务的数据范围或数据特点</h4><p>数据范围往往不是无意义的，它存在的意义就是卡掉某些错解。</p><p>先上张图</p><p><img src="https://i.loli.net/2019/10/21/ipIwRUbVNxaZl6J.jpg" alt="时间复杂度.png"></p><p>数据范围对选择算法非常重要，算法的选择将会决定你是否能做出这道题。</p><p>根据子任务的数据范围，我们可以通过它来选择不同子任务用的算法。</p><p>如开头提到的龙虎斗，对于$80$分的数据$n&lt;=100$,用$O(n^2)$的算法是肯定不会超时的。所以可以这么写代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">   ····<span class="comment">//暴力代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ····<span class="comment">//瞎搞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如$2018NOIP$ $T3$<a href="https://www.luogu.org/problem/P5017" target="_blank" rel="noopener">摆渡车</a></p><p>对于$10$%的数据，满足$m=1$</p><p>这时意味着每个人的等待时间都为0，所以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以拿到10分</p><h2 id="4-对拍"><a href="#4-对拍" class="headerlink" title="4.对拍"></a>4.对拍</h2><p>在你写出骗分程序后，如果你所有题目都做完了且检验后，这时你就可以返回之前通过骗分做的题目，想一些正解。</p><p>还是以龙虎斗为例，在你打出一个可以满足$100$%数据范围的时间复杂度的程序后，你想检验它的正确性，这时候运用对拍可以十分方便地检验。</p><p>对拍模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:loop</span><br><span class="line">shuju.exe</span><br><span class="line">baoli.exe</span><br><span class="line">shiyan.exe</span><br><span class="line">fc fan.out fan1.out</span><br><span class="line">if %errorlevel%&#x3D;&#x3D;0 goto loop</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>新建一个.txt文件，将上面的代码复制进去。再将后缀名改为.bat，文件名任意。</p><p>其中shuju.exe是你出数据的程序，shiyan.exe是你想的“正解”，baoli.exe是你打的暴力程序。</p><p>fan.out和fan1.out分别是你baoli和shiyan的输出文件。</p><p>这些东西需要放在同一个文件夹里，然后双击这个文件名.bat就可以开始愉快的对拍了。</p><h2 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h2><h4 id="1-最大连续和"><a href="#1-最大连续和" class="headerlink" title="1.最大连续和"></a>1.<a href="https://www.luogu.org/problem/U92940" target="_blank" rel="noopener">最大连续和</a></h4><p>首先看到$10$%的数据所有数都是正数，这是只要把所有数加起来就是结果。</p><p>对于$30$%的数据，我们很容易可以写出一个暴力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ans = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j ++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k ++)&#123;</span><br><span class="line">  sum += a[k];</span><br><span class="line">  &#125;</span><br><span class="line">ans = max(ans , sum);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对于$50$%的数据，在$30$%的程序基础上加入前缀和优化。</p><p>对于$80$%的数据，可以考虑进行二分（数据过水，在洛谷上被水过去了）</p><p>对于$100$%的数据，定义$dp[i]$为$1$~$i$的最大连续和。</p><p>对于$a[i]$，明显有两种选择，一种是取之前的最大连续和，一种是不取之前的最大连续和，以这个数为开头。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(a[i] , dp[i - <span class="number">1</span>] + a[i]);</span><br></pre></td></tr></table></figure><h4 id="2-2017NOIP-T4-跳房子"><a href="#2-2017NOIP-T4-跳房子" class="headerlink" title="2.$2017NOIP$ $T4$ 跳房子"></a>2.$2017NOIP$ $T4$ <a href="https://www.luogu.org/problem/P3957" target="_blank" rel="noopener">跳房子</a></h4><p>首先观察题目，发现题目中存在无解的情况，所以可以先加入特判是否存在答案。判断条件就是所有格子的最大和未超过$k$的话，输出无解。</p><p>接下来观察数据范围，发现$1,2$组数据$n$的范围较小，可以考虑$dfs$(见题目目录下1.cpp)</p><p>可以在该程序的基础上加上二分进行优化(见题目目录下2.cpp)</p><p>继续观察数据范围，发现前$5$组数据$n&lt;=500$，可以考虑用朴素$dp$求解</p><p>定义$dp[pos]$为从起点到$pos$格能获得的最大分数，</p><p>不难发现$dp[pos]$可以由某个格$i$跳$j$步到达</p><p>所以有方程$dp[pos]=max(dp[pos],dp[i]+s[i+j])$</p><p>其中$0&lt;=i&lt;n,left&lt;=j&lt;=right,pos = i + j$，$left,right$分别是能跳的步数的左边界和右边界。时间复杂度$O(n^2)$（见题目目录下3.cpp）</p><p>这样本题就可以拿到$50$分了</p><p>如果想拿到满分需要加入单调队列优化$dp$，这里不再赘述（<del>其实是我不会</del>）</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>骗分是种艺术，在考场上灵活运用骗分技巧可以为你争取部分分。但是这并不意味着你不用去思考这道题目的正解，要知道思考正解远比想尽办法骗分更有意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0.写在前面&quot;&gt;&lt;/a&gt;0.写在前面&lt;/h2&gt;&lt;p&gt;在&lt;del&gt;NOIP&lt;/del&gt;$CSP$的考场上，很多题目我们在考场上往往无法想到正解（&lt;del&gt;当然大佬
      
    
    </summary>
    
    
      <category term="CSP" scheme="http://zyx02.github.io/blog/tags/CSP/"/>
    
      <category term="骗分" scheme="http://zyx02.github.io/blog/tags/%E9%AA%97%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>电脑如何进入pixiv</title>
    <link href="http://zyx02.github.io/blog/2019/10/10/%E7%94%B5%E8%84%91%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5pixiv/"/>
    <id>http://zyx02.github.io/blog/2019/10/10/电脑如何进入pixiv/</id>
    <published>2019-10-10T14:56:14.000Z</published>
    <updated>2019-10-10T14:56:56.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pixiv，是一个主要由日本艺术家所组成的虚拟社群，主体为由pixiv股份制有限公司所运营的为插画艺术特化的社交网络服务网站。新兴的日本同人画、插画作品分享站点。采用了web2.0的方式，每个参与者都有自己的主页并可以对作品评价打分。——百度百科</p></blockquote><p>当你想进入$pixiv$时，你可能遇到这种情况</p><p><img src="https://i.loli.net/2019/10/10/AL5MwHr6vVpbI7q.png" alt=""></p><p>一开始是进不去$pixiv$的（除非你挂了$VPN$）</p><h2 id="Step0-准备工作"><a href="#Step0-准备工作" class="headerlink" title="Step0.准备工作"></a>Step0.准备工作</h2><ul><li>pixiv-nginx</li></ul><p><a href="https://pan.baidu.com/s/1xIjFWHykeKDzKZzoDzVPBA?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=" target="_blank" rel="noopener">链接</a> 提取码：apz7</p><h2 id="Step1-解压文件"><a href="#Step1-解压文件" class="headerlink" title="Step1.解压文件"></a>Step1.解压文件</h2><p>将压缩包解压，把文件夹放在C盘</p><p><img src="https://i.loli.net/2019/10/10/PlJG5FxpS8BEsfg.png" alt="TIM截图20191010222508.png"></p><h2 id="Step2-安装证书"><a href="#Step2-安装证书" class="headerlink" title="Step2.安装证书"></a>Step2.安装证书</h2><p>打开pixiv-nginx-1.15.3，双击ca.cer<br><img src="https://i.loli.net/2019/10/10/MfNo1QAjd5rmneE.png" alt="TIM截图20191010222657.png"></p><p>点击安装证书</p><p><img src="https://i.loli.net/2019/10/10/hqV34tZ8oyz6Rg2.png" alt="TIM截图20191010222739.png"></p><p>存储位置选择当前用户</p><p><img src="https://i.loli.net/2019/10/10/TYOxFQUetXucWCV.png" alt="TIM截图20191010223300.png"></p><p>选择将所有的证书都放入下列储存</p><p><img src="https://i.loli.net/2019/10/10/VUBqtgz5GRkKSfT.png" alt="TIM截图20191010222900.png"></p><p>选择受信任的根证书颁发机构</p><p><img src="https://i.loli.net/2019/10/10/pcBEF49kQxDagot.png" alt="TIM截图20191010222957.png"></p><p>然后点击完成即可</p><h2 id="Step3-修改hosts"><a href="#Step3-修改hosts" class="headerlink" title="Step3.修改hosts"></a>Step3.修改hosts</h2><p>复制pixiv-nginx-1.15.3内的hosts到C:\Windows\System32\drivers\etc内替换原hosts</p><p><img src="https://i.loli.net/2019/10/10/8qrwT79cpmdtVHB.png" alt="TIM截图20191010223515.png"></p><h3 id="Step4-开启Nginx"><a href="#Step4-开启Nginx" class="headerlink" title="Step4.开启Nginx"></a>Step4.开启Nginx</h3><p>到pixiv-nginx-1.15.3,打开4.可视化工具（这个操作简单）</p><p><img src="https://i.loli.net/2019/10/10/FBwm6IP9zS4r8nu.png" alt="TIM截图20191010223649.png"></p><p>打开后是如下界面</p><p><img src="https://i.loli.net/2019/10/10/W8UqdkNDHLZJhvi.png" alt="TIM截图20191010223721.png"></p><p>点Nginx后面的Start，看到打钩出现即为成功</p><p><img src="https://i.loli.net/2019/10/10/yE1fgPzx3U5LXYQ.png" alt="TIM截图20191010223803.png"></p><p>接下来就可以打开pixiv了！</p><p><img src="https://i.loli.net/2019/10/10/SYxDM157C4pGNou.png" alt="TIM截图20191010224316.png"></p><p>每次上pixiv都要打开nginx，如果觉得麻烦可以运行pixiv-nginx-1.15.3下的nginx添加开机启动.bat</p><h3 id="答疑：无法打开Nginx怎么办"><a href="#答疑：无法打开Nginx怎么办" class="headerlink" title="答疑：无法打开Nginx怎么办"></a>答疑：无法打开Nginx怎么办</h3><ul><li><p>1 确保你上面的步骤都正确</p></li><li><p>2 打开pixiv-nginx-1.15.3下的logs文件夹，打开error.log，复制里面的错误信息到度娘。</p></li></ul><p>如果你的错误日志里的信息是类似</p><blockquote><p>2019/10/02 09:06:17 [emerg] 6244#12448: bind() to 127.0.0.1:443 failed (10013: An attempt was made to access a socket in a way forbidden by its access permissions)</p></blockquote><p>这样的，那么这个错误信息是指你的端口被占用了。占用的端口是443（看第一行127.0.0.1:443）</p><p><a href="https://blog.csdn.net/bad_yixiong/article/details/70267140" target="_blank" rel="noopener">端口占用解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pixiv，是一个主要由日本艺术家所组成的虚拟社群，主体为由pixiv股份制有限公司所运营的为插画艺术特化的社交网络服务网站。新兴的日本同人画、插画作品分享站点。采用了web2.0的方式，每个参与者都有自己的主页并可以对作品评价打分。——百度百科&lt;
      
    
    </summary>
    
    
      <category term="工具" scheme="http://zyx02.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>题解 P1578【奶牛浴场】</title>
    <link href="http://zyx02.github.io/blog/2019/10/08/%E9%A2%98%E8%A7%A3-P1578%E3%80%90%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/10/08/题解-P1578【奶牛浴场】/</id>
    <published>2019-10-08T15:12:20.000Z</published>
    <updated>2019-10-08T15:13:55.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-问题类型"><a href="#0-问题类型" class="headerlink" title="0.问题类型"></a>0.问题类型</h3><p>这是一道经典的最大子矩形问题，本人的思路参考了国家队wzk大佬的论文《浅谈用极大化思想解决最大子矩形问题》</p><p>这篇论文介绍了两种求最大子矩形的思路，分别是通过障碍点找子矩形和通过悬线找子矩形，本题的数据范围适合使用第一种方法</p><h3 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1.算法思路"></a>1.算法思路</h3><p>定义极大子矩形为$4$条边都不能向外拓展的有效子矩形（这里的有效即子矩形内不包括障碍点)。</p><p>可以得到最大子矩形是所有极大子矩形中最大的，所以只要枚举最大的子矩形，求出其中最大的即可</p><h3 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2.算法实现"></a>2.算法实现</h3><p>怎么找极大子矩形？根据极大子矩形的定义，我们可以得出极大子矩形的$4$条边一定覆盖障碍点（或边界）</p><p>为了方便讨论，我们先将整个牛场的4个顶点设为障碍点。</p><p>例如</p><p>10 10</p><p>4</p><p>1 1</p><p>3 4 </p><p>6 3</p><p>9 8</p><h3 id="1-从左往右搜"><a href="#1-从左往右搜" class="headerlink" title="1.从左往右搜"></a>1.从左往右搜</h3><p>将障碍点按横坐标排序（左右顺序）后得到如下编号。</p><p>(作者画画不是那么好qwq)</p><p><img src="https://i.loli.net/2019/10/08/MTs4woRkLn2DqP3.png" alt="TIM截图20191008223603.png"></p><p>一开始从$1$号障碍点开始，从左往右找极大子矩形。</p><p>一开始的极大子矩形上下边界$up,low$为整个牛场的上下边界</p><p>$1$号障碍点往右找，到$2$号障碍点，如图</p><p><img src="https://i.loli.net/2019/10/08/3KxzmUQvLoM8keN.png" alt="1.png"></p><p>可以得到一个极大子矩形，它的面积就是障碍点$2$的横坐标减去障碍点$1$的横坐标乘以上边界减去下边界。</p><p>接下来需要对上下边界做一些修改，否则之后的极大子矩形可能会包括障碍点。因为$2$的纵坐标大于$1$的纵坐标，所以修改上边界，修改为$2$的纵坐标。</p><p>接下来到$3$，同理可以得到如下极大子矩形</p><p><img src="https://i.loli.net/2019/10/08/yLZbSluAH1JU3aw.png" alt="2.png"></p><p>它的面积就是$3$的横坐标减去$1$的横坐标乘以上边界（$2$的纵坐标）减去下边界</p><p>之后的$4$也同理。</p><p>然后从$2$开始往右找，从$3$开始往右找,从$4$开始往右找，跟从$1$开始找都是一样的。</p><h3 id="2-从右往左搜"><a href="#2-从右往左搜" class="headerlink" title="2.从右往左搜"></a>2.从右往左搜</h3><p>从左往右搜后我们会发现有一些遗漏的情况，就是极大子矩形的左边界是牛场的左边界，右边界覆盖一个障碍点的情况，如图</p><p><img src="https://i.loli.net/2019/10/08/CIW8PVt9zjrKyOX.png" alt="3.png"></p><p>解决方法很简单，把从左往右搜倒过来从右往左搜一遍即可</p><h3 id="3-特殊情况"><a href="#3-特殊情况" class="headerlink" title="3.特殊情况"></a>3.特殊情况</h3><p>在从左往右搜和从右往左搜后我们发现还有一种情况没有考虑到，就是极大子矩形的左右边界分别是牛场的左右边界，如图</p><p><img src="https://i.loli.net/2019/10/08/OxDvByJqsWYUiTw.png" alt="4.png"></p><p>解决方法是，再将障碍点按纵坐标排序，如图</p><p><img src="https://i.loli.net/2019/10/08/i8UIqVrj5BEhCFT.png" alt="5.png"></p><p>可以得到这类极大子矩形的面积就是相邻两个障碍点（按纵坐标排序后）纵坐标之差乘以牛场的长</p><p>时间复杂度$O(N^2)$，$N$为障碍点数</p><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span><span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = (sum &lt;&lt; <span class="number">1</span>) + (sum &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span><span class="comment">//存放障碍点信息</span></span><br><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line">&#125;s[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(S a , S b)</span><span class="comment">//按横坐标排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.x != b.x) <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.y &lt; b.y; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(S a , S b)</span><span class="comment">//按纵坐标排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.y != b.y) <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.x &lt; b.x ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l , w , n , ans; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = read() , w = read() , n = read();   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) s[i].x = read() , s[i].y = read();</span><br><span class="line">    s[++ n].x = <span class="number">0</span> , s[n].y = <span class="number">0</span>;<span class="comment">//将四个顶点设为障碍点</span></span><br><span class="line">s[++ n].x = <span class="number">0</span> , s[n].y = w;</span><br><span class="line">s[++ n].x = l , s[n].y = <span class="number">0</span>;</span><br><span class="line">s[++ n].x = l , s[n].y = w;</span><br><span class="line">    <span class="keyword">int</span> x1 , x2 , y1 , y2;<span class="comment">//x1为左边界，x2为右边界,y1为下边界，y2为上边界</span></span><br><span class="line">    <span class="comment">//从左往右搜</span></span><br><span class="line">    sort(s + <span class="number">1</span> , s + n + <span class="number">1</span> , cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">    x1 = s[i].x , y1 = <span class="number">0</span> , y2 = w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">    &#123;</span><br><span class="line">x2 = s[j].x;</span><br><span class="line">ans = max(ans , (x2 - x1) * (y2 - y1));</span><br><span class="line">    <span class="keyword">if</span>(s[j].y &lt; s[i].y) y1 = max(y1 , s[j].y);<span class="comment">//更新上下边界</span></span><br><span class="line">        <span class="keyword">else</span> y2 = min(y2 , s[j].y); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//从右往左搜  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">    x1 = s[i].x , y1 = <span class="number">0</span> , y2 = w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line">    &#123;</span><br><span class="line">    x2 = s[j].x;</span><br><span class="line">ans = max(ans , (x1 - x2) * (y2 - y1));</span><br><span class="line"><span class="keyword">if</span>(s[j].y &lt; s[i].y) y1 = max(y1 , s[j].y);</span><br><span class="line">        <span class="keyword">else</span> y2 = min(y2 , s[j].y); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理特殊情况</span></span><br><span class="line">sort(s + <span class="number">1</span> , s + n + <span class="number">1</span> , cmp2); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">ans = max(ans , l * (s[i + <span class="number">1</span>].y - s[i].y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span> , ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-问题类型&quot;&gt;&lt;a href=&quot;#0-问题类型&quot; class=&quot;headerlink&quot; title=&quot;0.问题类型&quot;&gt;&lt;/a&gt;0.问题类型&lt;/h3&gt;&lt;p&gt;这是一道经典的最大子矩形问题，本人的思路参考了国家队wzk大佬的论文《浅谈用极大化思想解决最大子矩形问题》&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="动态规划（dp）" scheme="http://zyx02.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89/"/>
    
      <category term="最大子矩形" scheme="http://zyx02.github.io/blog/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>倍增LCA学习笔记</title>
    <link href="http://zyx02.github.io/blog/2019/10/06/%E5%80%8D%E5%A2%9ELCA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyx02.github.io/blog/2019/10/06/倍增LCA学习笔记/</id>
    <published>2019-10-05T17:22:52.000Z</published>
    <updated>2019-12-11T11:59:49.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是LCA"><a href="#1-什么是LCA" class="headerlink" title="1.什么是LCA"></a>1.什么是LCA</h2><blockquote><p>LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。——百度百科</p></blockquote><p>这么说可能不直观，我们通过一张图来理解一下</p><p><img src="https://i.loli.net/2019/10/06/vJHnpk1oi2VPAqE.jpg" alt="64380cd7912397dd751c23bb5082b2b7d0a2872c.jpg"></p><p>（图片来源百度百科）</p><p>在这棵树中，点$3$和点$6$的最近公共祖先是$2$，因为3的祖先是{1,2}，6的祖先是{4,2,1}。它们的公共祖先是{2,1}，而其中深度最大的是$2$</p><h2 id="2-怎么求LCA"><a href="#2-怎么求LCA" class="headerlink" title="2.怎么求LCA"></a>2.怎么求LCA</h2><h3 id="1-朴素算法"><a href="#1-朴素算法" class="headerlink" title="1.朴素算法"></a>1.朴素算法</h3><p>了解了$LCA$的定义，不难得出一种暴力算法，即对于$u,v$两个点，我们让它们不断地一步一步往上跳，直到第一次相遇。</p><p>算法时间复杂度：$O(N)$</p><h3 id="2-倍增算法"><a href="#2-倍增算法" class="headerlink" title="2.倍增算法"></a>2.倍增算法</h3><p>既然一步一步跳太慢，我们可以考虑设计一种倍增算法，让它一次跳$2^{0},2^{1},···.2^{n}$次方步。</p><h4 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h4><p>定义$fa[i][j]$为第$i$个点跳$2^{j}$步后达到的点，$deep[i]$为第$i$个点的深度。</p><h4 id="1-建树，计算深度，预处理-fa-i-0"><a href="#1-建树，计算深度，预处理-fa-i-0" class="headerlink" title="1.建树，计算深度，预处理$fa[i][0]$"></a>1.建树，计算深度，预处理$fa[i][0]$</h4><p>这一部分可以用$dfs$实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t , <span class="keyword">int</span> father)</span> <span class="comment">//t表示当前点编号，father表示它的父亲结点编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deep[t] = deep[father] + <span class="number">1</span>;<span class="comment">//深度是父亲深度+1</span></span><br><span class="line">fa[t][<span class="number">0</span>] = father;<span class="comment">//t跳一步正好到father</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[t]; i ; i = edge[i].Next)<span class="comment">//链式前向星</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to != father)<span class="comment">//避免出现死循环</span></span><br><span class="line">  dfs(edge[i].to , t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-预处理-fa-i-j"><a href="#2-预处理-fa-i-j" class="headerlink" title="2.预处理$fa[i][j]$"></a>2.预处理$fa[i][j]$</h4><p>因为$2^{j}=2^{j-1}+2^{j-1}$，所以我们可以得到转移方程</p><p>$fa[i][j]=fa[fa[i][j-1]][j-1]$</p><p>即先跳$2^{j-1}$到达$fa[i][j-1]$,再跳$2^{j-1}$步到达$fa[fa[i][j-1][j-1]]$</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)<span class="comment">//为了保险开到2^20，一般超过2^20的数据都会超时了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-求-LCA"><a href="#3-求-LCA" class="headerlink" title="3.求$LCA$"></a>3.求$LCA$</h4><p>假设求$x,y$的$LCA$</p><p>为了方便讨论，假设$deep[x]&gt;deep[y]$，即$x$的深度大于$y$的深度</p><p>先让$x$跳到与$y$同一深度，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i];<span class="comment">//只要x还比y深，就跳，否则不跳</span></span><br></pre></td></tr></table></figure><p>如果这时候如果$x$已经等于$y$了，直接输出即可。</p><p>到达同一深度后，我们开始让$x,y$一起跳，注意这里我们要跳到的是它们$LCA$的下一层（因为我们跳到的是满足$x$和$y$不相等的最浅的一层，而它们的上层即为$LCA$）。</p><p>还是看最开始的例子，$3,6$,调整至同一高度后为$3,4$，，循环过后$x$和$y$的值并没有改变，因为我们跳到的是$LCA$的下一层。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">   <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i] , y = fa[y][i];<span class="comment">//如果它们跳2^i后不相等，那么肯定不是LCA的上面，所以跳</span></span><br></pre></td></tr></table></figure><p>最后的答案就是$f[x][0]$了</p><p>完整代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n , m , s , cnt;</span><br><span class="line"><span class="keyword">int</span> deep[<span class="number">500100</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">500010</span>][<span class="number">31</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to , Next;</span><br><span class="line">&#125;edge[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span><span class="comment">//建边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++ cnt].Next = head[from];</span><br><span class="line">edge[cnt].to = to;</span><br><span class="line">head[from] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t , <span class="keyword">int</span> father)</span><span class="comment">//预处理深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deep[t] = deep[father] + <span class="number">1</span>;</span><br><span class="line">fa[t][<span class="number">0</span>] = father;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[t]; i ; i = edge[i].Next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to != father)</span><br><span class="line">  dfs(edge[i].to , t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span><span class="comment">//预处理fa数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span><span class="comment">//求LCA</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x , y);<span class="comment">//令x的深度大于y的深度</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i];<span class="comment">//让x,y跳到同一深度</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i] , y = fa[y][i];<span class="comment">//让x,y一起跳</span></span><br><span class="line">     <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x; </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;n , &amp;m , &amp;s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;x , &amp;y);</span><br><span class="line">add(y , x);</span><br><span class="line">add(x , y);</span><br><span class="line">&#125;</span><br><span class="line">dfs(s , <span class="number">0</span>);</span><br><span class="line">prework();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a , b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;a , &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , query(a , b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度$O(logn)$</p><h3 id="4-一些思考"><a href="#4-一些思考" class="headerlink" title="4.一些思考"></a>4.一些思考</h3><p>为什么求LCA中$j$要从大到小枚举。</p><p>这个和天平称重时从大到小放砝码有点类似，举个例子，比如跳9步，如果按从小到大枚举是$1+2+4+8$,而$9 \ne1+2+4+8$,还需要回去重新找，而从大到小的话直接求出$9=8+1$</p><h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h3><p><a href="https://www.luogu.org/problem/P3379" target="_blank" rel="noopener">P3379 【模板】最近公共祖先（LCA）</a></p><p><a href="http://noip.qz1z.com:2000/contest/45/problem/1" target="_blank" rel="noopener">泉州市信息技术基地校OJ 密室逃脱</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是LCA&quot;&gt;&lt;a href=&quot;#1-什么是LCA&quot; class=&quot;headerlink&quot; title=&quot;1.什么是LCA&quot;&gt;&lt;/a&gt;1.什么是LCA&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;LCA（Least Common Ancestors），即最近公共
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="学习笔记" scheme="http://zyx02.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="倍增" scheme="http://zyx02.github.io/blog/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="LCA,最近公共祖先" scheme="http://zyx02.github.io/blog/tags/LCA-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>康托展开学习笔记</title>
    <link href="http://zyx02.github.io/blog/2019/09/29/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyx02.github.io/blog/2019/09/29/康托展开学习笔记/</id>
    <published>2019-09-29T15:41:01.000Z</published>
    <updated>2019-10-05T17:23:54.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是康托展开"><a href="#1-什么是康托展开" class="headerlink" title="1.什么是康托展开"></a>1.什么是康托展开</h2><blockquote><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。——摘自百度百科</p></blockquote><p>简单来说，康托展开就是对于任意一个全排列，求一个自然数与它对应，即一个全排列到一个自然数的映射，这种映射是唯一的。</p><h2 id="2-怎么实现康托展开"><a href="#2-怎么实现康托展开" class="headerlink" title="2.怎么实现康托展开"></a>2.怎么实现康托展开</h2><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>$ X=\sum_{i=1}^n a_{i}(i-1)! $</p><p>其中，$a_{i}$代表在这个排列中的第$i$个数后面有多少个数比它小。</p><p>这个公式求的是当前排列前面有多少个排列</p><p>例如，对于排列$14325$，它的康托展开是</p><p>$X=0\times(5-1)!+2\times(4-1)!+1\times(3-1)!+0\times(2-1)!+0\times(1-1)!=0+12+2+0+0=14$</p><p>所以$14325$前面还有$14$个排列，所以$14325$是第$14+1=15$个排列</p><h4 id="本蒟蒻对于这个公式的一些浅显理解"><a href="#本蒟蒻对于这个公式的一些浅显理解" class="headerlink" title="本蒟蒻对于这个公式的一些浅显理解:"></a>本蒟蒻对于这个公式的一些浅显理解:</h4><p>假设有一个排列$a_{1},a_{2},···,a_{n}$</p><p>如果其满足$a_{1} &lt; a_{2}&lt;···&lt; a_{n}$,那么它是第一个排列。所以答案为$1$，计算公式之后不难发现公式正确</p><p>如果$a_{2},a_{3},···,a_{n}$中有比$a_{1}$小的数，以这些数为开头的排列必定在$a_{1}$为开头的排列前面，所以要加上这些排列数。确定了开头了之后，其后面还有$(n-1)$个数，可以构成$(n-1)!$种序列，所以公式第一项为比$a_{1}$小的数的个数乘以$(n-1)!$</p><p>以此类推，可以得到该序列的排位。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">int</span> a[N] , n , Min[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//预处理阶乘</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">  sum[i] = i * sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos)</span><span class="comment">//预处理ai</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  <span class="keyword">if</span>(a[i] &lt; a[pos]) Min[pos] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cantor</span><span class="params">()</span><span class="comment">//康托展开</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  ans += Min[i] * sum[n - i];</span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">   fc(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) get(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span> , cantor() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-逆康托展开"><a href="#3-逆康托展开" class="headerlink" title="3.逆康托展开"></a>3.逆康托展开</h3><p>知道了如何给定排列求序号，因为排列与序号一一对应，所以自然可以用序号求排列。</p><p>逆康托展开其实就是把康托展开反向计算。</p><p>假设字典序号为$pos$，共有$n$个数</p><p>首先用$pos\div(n-1)!$，余数自然就是$\sum_{i=2}^n a_{i}(n-i)! $,商就是 $a_{1}$</p><p>如此反复，可求得$a_{1},a_{2},···,a_{n}$</p><p>例如：给定$pos=15,n=5$，所以有$pos-1=14$个比它小的序列</p><p>$14\div(5-1)!=0······14,a_{1}=0$</p><p>$14\div(4-1)!=2······2,a_{2}=2$</p><p>$2\div(3-1)!=1······0,a_{3}=1$</p><p>$0\div(2-1)!=0······0,a_{4}=0$</p><p>$0\div(1-1)!=0,a_{5}=0$</p><p>接下来，在$1,2,3,4,5$中，有$0$个比它小的数的数是$1$，所以第一位为$1$</p><p>在$2,3,4,5$中，有$2$个比它小的数的数是$4$，所以第二位为$4$</p><p>在$2,3,5$中，有$1$个比它小的数的数是$3$，所以第三位为$3$</p><p>在$2,5$中，有$0$个比它小的数的数是$2$,所以第四位为$2$</p><p>第五位为$5$</p><p>综上，原序列为$14325$</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">int</span> a[N] , n , pos , Min[N];</span><br><span class="line"><span class="keyword">bool</span> use[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">  sum[i] = i * sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recantor</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">Min[n - i] = pos / sum[i] , pos = pos % sum[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(! use[j])</span><br><span class="line">  s ++;</span><br><span class="line"><span class="keyword">if</span>(s == Min[n - i] + <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> a[n - i] = j;</span><br><span class="line"> use[j] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; pos;</span><br><span class="line">    fc(n);</span><br><span class="line">recantor(pos - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h4><p><a href="https://www.luogu.org/problem/P3014" target="_blank" rel="noopener">P3014[USACO11FEB]牛线Cow Line</a></p><p><a href="https://www.luogu.org/problem/P5367" target="_blank" rel="noopener">P5367【模板】康托展开</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是康托展开&quot;&gt;&lt;a href=&quot;#1-什么是康托展开&quot; class=&quot;headerlink&quot; title=&quot;1.什么是康托展开&quot;&gt;&lt;/a&gt;1.什么是康托展开&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="学习笔记" scheme="http://zyx02.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="康托展开" scheme="http://zyx02.github.io/blog/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    
      <category term="组合数" scheme="http://zyx02.github.io/blog/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>广州中山纪念中学游记</title>
    <link href="http://zyx02.github.io/blog/2019/07/14/%E5%B9%BF%E5%B7%9E%E4%B8%AD%E5%B1%B1%E7%BA%AA%E5%BF%B5%E4%B8%AD%E5%AD%A6%E6%B8%B8%E8%AE%B0/"/>
    <id>http://zyx02.github.io/blog/2019/07/14/广州中山纪念中学游记/</id>
    <published>2019-07-14T15:51:44.000Z</published>
    <updated>2021-08-25T15:41:24.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="$Day 1$"></a>$Day 1$</h2><p>坐动车，去学校。<del>顺便去腾讯公司上了个厕所</del></p><p>（<del>这学校比我们学校大多了啊！！</del>）</p><p>本来还想吃完晚饭<del>颓狼人杀</del>的，结果莫名其妙跟着老师去看机房，然后讲注意事项，OJ网址，接着莫名其妙地打了一晚上的题（<del>我还要打狼人杀啊！</del>）</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="$Day 2$"></a>$Day 2$</h2><p>早上打模拟赛，被神仙们虐爆了，$100+80+30+60=270rk12$，我好菜啊$QwQ$</p><p>第一题简单暴力模拟，第二题本来想暴力拆字符串结果爆空间了，还好拿了$80$，第三题写了一个自以为正确的贪心<del>结果WAWA大哭了</del>，第四题数位dp只能拿$60$暴力分（出题人良心！）了。</p><p>顺便膜一下我校大佬$lmk$，$100+100+100+70=370rk1$太强了！吊打我！</p><p>然后讲题，改题。</p><p>顺便讲了一下数位dp，学完之后当晚肝了一题<a href="https://www.luogu.org/problemnew/show/P2657" target="_blank" rel="noopener">windy数</a>，感觉良好</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="$Day 3$"></a>$Day 3$</h2><p>还是模拟赛，继续被神仙们狂虐，$50+20+0+20=90rk5$，太菜了吧$qwq$</p><p>第一题被讲题人誉为本次比赛中最难的一题(<del>那为什么还要放在第一题啊</del>)，主要原因是题目很难理解(<del>可以当阅读理解了吧（雾）</del>)，但不知道为什么我暴搜骗了50，第二题讲题人言简意赅地点出了核心思想——<del>乱搞</del>，第三题是道dp但完全看不出来，第四题旁边的$gy$一直跟我说不是最小生成树，不是最小生成树，结果正解就是最小生成树+虚点连边。。。。。。</p><p>再次膜拜我校大佬$lmk$,$10+90+0+100=200rk1$魔鬼！</p><p>最后发现第三题要用压位高精，不然会爆空间，不得不感叹一下出题人的<del>毒瘤</del></p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="$Day 4$"></a>$Day 4$</h2><p>今天没有模拟赛，<del>甚好</del>，去听了一早上的dp，然后下午一直在肝dp</p><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="$Day 5$"></a>$Day 5$</h2><p>又是模拟赛，继续划水，$100+85+10+10=205rk12$菜死了。</p><p>第一题签到题简单模拟，第二题毒瘤数据制造者居然让dfs爆栈了，换成bfs才过，第三题数学题，可惜没看出答案是卡特兰数，而且还要加上高精，最后一题dp打了个暴搜水分。。。</p><p>话说某位老师居然参加了这场比赛而且居然没有AK（笑）</p><p>膜拜我校大佬$xzx$,$100+100+0+100=300rk2$（$rk1$老师）太可怕了。</p><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="$Day 6$"></a>$Day 6$</h2><p>一场异常简单的模拟赛，一堆神仙AK，然而我第一题爆零因为没特判换行符….，该死的OJ，该死的Linux。。。</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="$Day7$"></a>$Day7$</h2><p>没有打比赛而是去听了一下堆，下午找了几题练练，感觉良好。。。</p><p>（priority_queue大法好啊）</p><h2 id="Day8"><a href="#Day8" class="headerlink" title="$Day8$"></a>$Day8$</h2><p>又是被神仙们虐的一天，$100+0+37.5+12.5=150rk5$(<del>希望这是我数学期末考的分数</del>)</p><p>第一题数论，数据范围$O(\sqrt{n})$明显会TLE但竟然让我水过了！第二题二维离散化，又是什么神仙算法。。。第三题Floyd+匈牙利算法，第四题玄学算法（我也不知道我后面是怎么改对的）</p><h2 id="Day-9"><a href="#Day-9" class="headerlink" title="$Day 9$"></a>$Day 9$</h2><p>最后的一场比赛了，然而我还是考炸了，$20+0+0+92.3=112.3rk7$。</p><p>第一题还是恶心数论，不过这次数据只让我的$O(n)$拿了20qwq，第二题听说是状压dp（但我不会呀），第三题dp以为是贪心。。。第四题二分边界设错emmm，还是太粗心了$QwQ$</p><h2 id="Day-10"><a href="#Day-10" class="headerlink" title="$Day 10$"></a>$Day 10$</h2><p>在纪中机房的最后一天了，老师为我们分享了他的OI心得，分别时还是有点不舍。</p><p>晚上放假，和大佬们一起去学校里的公园走了走，回到宿舍开始完成一直未能完成的事业——<del>狼人杀</del>，<del>我们在晚上睡觉时间后跑到别的宿舍玩狼人杀与查房的斗智斗勇超刺激的</del></p><h2 id="Day-11"><a href="#Day-11" class="headerlink" title="$Day 11$"></a>$Day 11$</h2><p>回家。</p><h2 id="the-end"><a href="#the-end" class="headerlink" title="the end."></a>the end.</h2><p>是不可能的</p><h2 id="吐槽区"><a href="#吐槽区" class="headerlink" title="吐槽区"></a>吐槽区</h2><ul><li><p><del>不知道什么时候开始一到机房大家几乎都点开了<a href="https://slay.one/" target="_blank" rel="noopener">slay.one</a>或者<a href="http://2048game.com/" target="_blank" rel="noopener">2048</a></del></p></li><li><p>纪中的食堂的饭菜挺好吃的啊（每天中午第一行第三列孜然鸡腿（只有一天在第二行第四列））</p></li><li><p>fch老师经典语录：我会很烦躁的</p></li><li><p>直到倒数第2（3？）天我们才知道食堂有夜宵，而且是烧烤！然后一下课一堆人(包括我)像sb一样冲了出去（<del>众所周知sb=smart boy</del>）</p></li><li><p>听说纪中好像还是个5A级景区？？？</p></li><li><p>舍监经典语录：你们待在纪中一天就是一天纪中人 / 有没有一点纪律观念时间观念</p></li><li><p>特意去买了一本纪中的草稿纸当纪念，<del>下学期就用它了</del></p></li><li><p>fch老师OJ上的头像</p></li></ul><p><img src="https://i.loli.net/2019/07/14/5d2b4db5e3d7f99738.jpg" alt=""></p><ul><li><p>一本通的编者之一宋老师竟然来给我们讲课了！而且讲的很好啊（宋老师：让学生听不懂才是一堂好课）</p></li><li><p>等我想到了再补吧······</p></li></ul><h2 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h2><p>第一次去外省培训，一次次被小学生和神仙们虐到自闭。菜死了的我深深地感受到了人外有人。被虐的同时我也学到了许多，数位dp,匈牙利算法,rmq问题,倍增求LCA······也收获了许多友谊。</p><p>在一天纪中，就做一天纪中人。有缘再见，纪中！</p><p>最后引用fch老师的一句话</p><blockquote><p>程序员之所以犯错误，不是因为他们不懂，而是因为他们自以为什么都懂。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;$Day 1$&quot;&gt;&lt;/a&gt;$Day 1$&lt;/h2&gt;&lt;p&gt;坐动车，去学校。&lt;del&gt;顺便去腾讯公司上了个厕所&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;（&lt;del&gt;这学校比我们学校大
      
    
    </summary>
    
    
      <category term="游记" scheme="http://zyx02.github.io/blog/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF581B 【Luxurious Houses】</title>
    <link href="http://zyx02.github.io/blog/2019/06/24/%E9%A2%98%E8%A7%A3-CF581B-%E3%80%90Luxurious-Houses%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/06/24/题解-CF581B-【Luxurious-Houses】/</id>
    <published>2019-06-24T01:56:55.000Z</published>
    <updated>2019-06-25T14:25:15.070Z</updated>
    
    <content type="html"><![CDATA[<p>不难看出，题目要求的是每一个房子后面最高的房子与它的高度差$+1$，（如果比它矮输出$0$）</p><p>我们定义</p><ul><li><p>$maxn[i]$表示第$i$到第$n$个房子高度的最大值（$n$为房子数）</p></li><li><p>$h[i]$表示第$i$个房子的高度</p></li></ul><p>因为$maxn[i+1]$存放的已经是第$i+1$到第$n$个房子的最大值了，所以第$i$到第$n$个房子的最大值只要让当前房子的高度与$maxn[i+1]$进行比较即可</p><p>即$maxn[i]=max(h[i],maxn[i+1])$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[MAXN] , maxn[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i --)</span><br><span class="line">   maxn[i] = max(h[i] , maxn[i + <span class="number">1</span>]); <span class="comment">//预处理最大值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; max(maxn[i + <span class="number">1</span>] - h[i] + <span class="number">1</span> , <span class="number">0</span>) &lt;&lt; <span class="string">" "</span>;<span class="comment">//如果没比它高要输出0！</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//最后一个后面已经没有房子了当然是0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不难看出，题目要求的是每一个房子后面最高的房子与它的高度差$+1$，（如果比它矮输出$0$）&lt;/p&gt;
&lt;p&gt;我们定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$maxn[i]$表示第$i$到第$n$个房子高度的最大值（$n$为房子数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$h[i]$
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/blog/tags/CodeForces/"/>
    
      <category term="动态规划（dp）" scheme="http://zyx02.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89/"/>
    
  </entry>
  
</feed>
