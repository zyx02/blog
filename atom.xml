<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zyx的博客</title>
  
  <subtitle>「深藏不露是一种卓越的才能」</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zyx02.github.io/"/>
  <updated>2019-10-05T17:24:12.371Z</updated>
  <id>http://zyx02.github.io/</id>
  
  <author>
    <name>不省一不改名</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>倍增LCA学习笔记</title>
    <link href="http://zyx02.github.io/2019/10/06/%E5%80%8D%E5%A2%9ELCA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyx02.github.io/2019/10/06/倍增LCA学习笔记/</id>
    <published>2019-10-05T17:22:52.000Z</published>
    <updated>2019-10-05T17:24:12.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是LCA"><a href="#1-什么是LCA" class="headerlink" title="1.什么是LCA"></a>1.什么是LCA</h2><blockquote><p>LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。——百度百科</p></blockquote><p>这么说可能不直观，我们通过一张图来理解一下</p><p><img src="https://i.loli.net/2019/10/06/vJHnpk1oi2VPAqE.jpg" alt="64380cd7912397dd751c23bb5082b2b7d0a2872c.jpg"></p><p>（图片来源百度百科）</p><p>在这棵树中，点$3$和点$6$的最近公共祖先是$2$，因为3的祖先是{1,2}，6的祖先是{4,2,1}。它们的公共祖先是{2,1}，而其中深度最大的是$2$</p><h2 id="2-怎么求LCA"><a href="#2-怎么求LCA" class="headerlink" title="2.怎么求LCA"></a>2.怎么求LCA</h2><h3 id="1-朴素算法"><a href="#1-朴素算法" class="headerlink" title="1.朴素算法"></a>1.朴素算法</h3><p>了解了$LCA$的定义，不难得出一种暴力算法，即对于$u,v$两个点，我们让它们不断地一步一步往上跳，直到第一次相遇。</p><p>算法时间复杂度：$O(N)$</p><h3 id="2-倍增算法"><a href="#2-倍增算法" class="headerlink" title="2.倍增算法"></a>2.倍增算法</h3><p>既然一步一步跳太慢，我们可以考虑设计一种倍增算法，让它一次跳$2^{0},2^{1},···.2^{n}$次方步。</p><h4 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h4><p>定义$fa[i][j]$为第$i$个点跳$2^{j}$步后达到的点，$deep[i]$为第$i$个点的深度。</p><h4 id="1-建树，计算深度，预处理-fa-i-0"><a href="#1-建树，计算深度，预处理-fa-i-0" class="headerlink" title="1.建树，计算深度，预处理$fa[i][0]$"></a>1.建树，计算深度，预处理$fa[i][0]$</h4><p>这一部分可以用$dfs$实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t , <span class="keyword">int</span> father)</span> <span class="comment">//t表示当前点编号，father表示它的父亲结点编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deep[t] = deep[father] + <span class="number">1</span>;<span class="comment">//深度是父亲深度+1</span></span><br><span class="line">fa[t][<span class="number">0</span>] = father;<span class="comment">//t跳一步正好到father</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[t]; i ; i = edge[i].Next)<span class="comment">//链式前向星</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to != father)<span class="comment">//避免出现死循环</span></span><br><span class="line">  dfs(edge[i].to , t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-预处理-fa-i-j"><a href="#2-预处理-fa-i-j" class="headerlink" title="2.预处理$fa[i][j]$"></a>2.预处理$fa[i][j]$</h4><p>因为$2^{j}=2^{j-1}+2^{j-1}$，所以我们可以得到转移方程</p><p>$fa[i][j]=fa[fa[i][j-1]][j-1]$</p><p>即先跳$2^{j-1}$到达$fa[i][j-1]$,再跳$2^{j-1}$步到达$fa[fa[i][j-1][j-1]]$</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)<span class="comment">//为了保险开到2^20，一般超过2^20的数据都会超时了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-求-LCA"><a href="#3-求-LCA" class="headerlink" title="3.求$LCA$"></a>3.求$LCA$</h4><p>假设求$x,y$的$LCA$</p><p>为了方便讨论，假设$deep[x]&gt;deep[y]$，即$x$的深度大于$y$的深度</p><p>先让$x$跳到与$y$同一深度，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i];<span class="comment">//只要x还比y深，就跳，否则不跳</span></span><br></pre></td></tr></table></figure><p>如果这时候如果$x$已经等于$y$了，直接输出即可。</p><p>到达同一深度后，我们开始让$x,y$一起跳，注意这里我们要跳到它们$LCA$的下一层，否则求出来的可能比答案来的深度小。</p><p>还是看最开始的例子，$3,6$,调整至同一高度后为$3,4$，如果不是跳到$LCA$的下一层的话，它们可能跳到$1$。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">   <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i] , y = fa[y][i];<span class="comment">//如果它们跳2^i后不相等，那么肯定不是LCA的上面，所以跳</span></span><br></pre></td></tr></table></figure><p>最后的答案就是$f[x][0]$了</p><p>完整代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n , m , s , cnt;</span><br><span class="line"><span class="keyword">int</span> deep[<span class="number">500100</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">500010</span>][<span class="number">31</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to , Next;</span><br><span class="line">&#125;edge[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span><span class="comment">//建边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++ cnt].Next = head[from];</span><br><span class="line">edge[cnt].to = to;</span><br><span class="line">head[from] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t , <span class="keyword">int</span> father)</span><span class="comment">//预处理深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deep[t] = deep[father] + <span class="number">1</span>;</span><br><span class="line">fa[t][<span class="number">0</span>] = father;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[t]; i ; i = edge[i].Next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to != father)</span><br><span class="line">  dfs(edge[i].to , t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span><span class="comment">//预处理fa数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span><span class="comment">//求LCA</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x , y);<span class="comment">//令x的深度大于y的深度</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i];<span class="comment">//让x,y跳到同一深度</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i] , y = fa[y][i];<span class="comment">//让x,y一起跳</span></span><br><span class="line">     <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x; </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;n , &amp;m , &amp;s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;x , &amp;y);</span><br><span class="line">add(y , x);</span><br><span class="line">add(x , y);</span><br><span class="line">&#125;</span><br><span class="line">dfs(s , <span class="number">0</span>);</span><br><span class="line">prework();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a , b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;a , &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , query(a , b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度$O(logn)$</p><h3 id="4-一些思考"><a href="#4-一些思考" class="headerlink" title="4.一些思考"></a>4.一些思考</h3><p>为什么求LCA中$j$要从大到小枚举。</p><p>举个例子，比如跳9步，如果按从小到大枚举是$1+2+4+8$,而$9 \ne1+2+4+8$,还需要回去重新找，而从大到小的话直接求出$9=8+1$</p><h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h3><p><a href="https://www.luogu.org/problem/P3379" target="_blank" rel="noopener">P3379 【模板】最近公共祖先（LCA）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是LCA&quot;&gt;&lt;a href=&quot;#1-什么是LCA&quot; class=&quot;headerlink&quot; title=&quot;1.什么是LCA&quot;&gt;&lt;/a&gt;1.什么是LCA&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;LCA（Least Common Ancestors），即最近公共
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="学习笔记" scheme="http://zyx02.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="倍增" scheme="http://zyx02.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="LCA,最近公共祖先" scheme="http://zyx02.github.io/tags/LCA-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>康托展开学习笔记</title>
    <link href="http://zyx02.github.io/2019/09/29/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyx02.github.io/2019/09/29/康托展开学习笔记/</id>
    <published>2019-09-29T15:41:01.000Z</published>
    <updated>2019-10-05T17:23:54.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是康托展开"><a href="#1-什么是康托展开" class="headerlink" title="1.什么是康托展开"></a>1.什么是康托展开</h2><blockquote><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。——摘自百度百科</p></blockquote><p>简单来说，康托展开就是对于任意一个全排列，求一个自然数与它对应，即一个全排列到一个自然数的映射，这种映射是唯一的。</p><h2 id="2-怎么实现康托展开"><a href="#2-怎么实现康托展开" class="headerlink" title="2.怎么实现康托展开"></a>2.怎么实现康托展开</h2><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>$ X=\sum_{i=1}^n a_{i}(i-1)! $</p><p>其中，$a_{i}$代表在这个排列中的第$i$个数后面有多少个数比它小。</p><p>这个公式求的是当前排列前面有多少个排列</p><p>例如，对于排列$14325$，它的康托展开是</p><p>$X=0\times(5-1)!+2\times(4-1)!+1\times(3-1)!+0\times(2-1)!+0\times(1-1)!=0+12+2+0+0=14$</p><p>所以$14325$前面还有$14$个排列，所以$14325$是第$14+1=15$个排列</p><h4 id="本蒟蒻对于这个公式的一些浅显理解"><a href="#本蒟蒻对于这个公式的一些浅显理解" class="headerlink" title="本蒟蒻对于这个公式的一些浅显理解:"></a>本蒟蒻对于这个公式的一些浅显理解:</h4><p>假设有一个排列$a_{1},a_{2},···,a_{n}$</p><p>如果其满足$a_{1} &lt; a_{2}&lt;···&lt; a_{n}$,那么它是第一个排列。所以答案为$1$，计算公式之后不难发现公式正确</p><p>如果$a_{2},a_{3},···,a_{n}$中有比$a_{1}$小的数，以这些数为开头的排列必定在$a_{1}$为开头的排列前面，所以要加上这些排列数。确定了开头了之后，其后面还有$(n-1)$个数，可以构成$(n-1)!$种序列，所以公式第一项为比$a_{1}$小的数的个数乘以$(n-1)!$</p><p>以此类推，可以得到该序列的排位。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">int</span> a[N] , n , Min[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//预处理阶乘</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">  sum[i] = i * sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos)</span><span class="comment">//预处理ai</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  <span class="keyword">if</span>(a[i] &lt; a[pos]) Min[pos] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cantor</span><span class="params">()</span><span class="comment">//康托展开</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  ans += Min[i] * sum[n - i];</span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">   fc(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) get(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span> , cantor() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-逆康托展开"><a href="#3-逆康托展开" class="headerlink" title="3.逆康托展开"></a>3.逆康托展开</h3><p>知道了如何给定排列求序号，因为排列与序号一一对应，所以自然可以用序号求排列。</p><p>逆康托展开其实就是把康托展开反向计算。</p><p>假设字典序号为$pos$，共有$n$个数</p><p>首先用$pos\div(n-1)!$，余数自然就是$\sum_{i=2}^n a_{i}(n-i)! $,商就是 $a_{1}$</p><p>如此反复，可求得$a_{1},a_{2},···,a_{n}$</p><p>例如：给定$pos=15,n=5$，所以有$pos-1=14$个比它小的序列</p><p>$14\div(5-1)!=0······14,a_{1}=0$</p><p>$14\div(4-1)!=2······2,a_{2}=2$</p><p>$2\div(3-1)!=1······0,a_{3}=1$</p><p>$0\div(2-1)!=0······0,a_{4}=0$</p><p>$0\div(1-1)!=0,a_{5}=0$</p><p>接下来，在$1,2,3,4,5$中，有$0$个比它小的数的数是$1$，所以第一位为$1$</p><p>在$2,3,4,5$中，有$2$个比它小的数的数是$4$，所以第二位为$4$</p><p>在$2,3,5$中，有$1$个比它小的数的数是$3$，所以第三位为$3$</p><p>在$2,5$中，有$0$个比它小的数的数是$2$,所以第四位为$2$</p><p>第五位为$5$</p><p>综上，原序列为$14325$</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">int</span> a[N] , n , pos , Min[N];</span><br><span class="line"><span class="keyword">bool</span> use[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">  sum[i] = i * sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recantor</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">Min[n - i] = pos / sum[i] , pos = pos % sum[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(! use[j])</span><br><span class="line">  s ++;</span><br><span class="line"><span class="keyword">if</span>(s == Min[n - i] + <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> a[n - i] = j;</span><br><span class="line"> use[j] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; pos;</span><br><span class="line">    fc(n);</span><br><span class="line">recantor(pos - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h4><p><a href="https://www.luogu.org/problem/P3014" target="_blank" rel="noopener">P3014[USACO11FEB]牛线Cow Line</a></p><p><a href="https://www.luogu.org/problem/P5367" target="_blank" rel="noopener">P5367【模板】康托展开</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是康托展开&quot;&gt;&lt;a href=&quot;#1-什么是康托展开&quot; class=&quot;headerlink&quot; title=&quot;1.什么是康托展开&quot;&gt;&lt;/a&gt;1.什么是康托展开&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="学习笔记" scheme="http://zyx02.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="康托展开" scheme="http://zyx02.github.io/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    
      <category term="组合数" scheme="http://zyx02.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>广州中山纪念中学游记</title>
    <link href="http://zyx02.github.io/2019/07/14/%E5%B9%BF%E5%B7%9E%E4%B8%AD%E5%B1%B1%E7%BA%AA%E5%BF%B5%E4%B8%AD%E5%AD%A6%E6%B8%B8%E8%AE%B0/"/>
    <id>http://zyx02.github.io/2019/07/14/广州中山纪念中学游记/</id>
    <published>2019-07-14T15:51:44.000Z</published>
    <updated>2019-07-15T10:31:46.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="$Day 1$"></a>$Day 1$</h2><p>坐动车，去学校。<del>顺便去腾讯公司上了个厕所</del></p><p>（<del>这学校比我们学校大多了啊！！</del>）</p><p>本来还想吃完晚饭<del>颓狼人杀</del>的，结果莫名其妙跟着老师去看机房，然后讲注意事项，OJ网址，接着莫名其妙地打了一晚上的题（<del>我还要打狼人杀啊！</del>）</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="$Day 2$"></a>$Day 2$</h2><p>早上打模拟赛，被神仙们虐爆了，$100+80+30+60=270rk12$，我好菜啊$QwQ$</p><p>第一题简单暴力模拟，第二题本来想暴力拆字符串结果爆空间了，还好拿了$80$，第三题写了一个自以为正确的贪心<del>结果WAWA大哭了</del>，第四题数位dp只能拿$60$暴力分（出题人良心！）了。</p><p>顺便膜一下我校大佬$lmk$，$100+100+100+70=370rk1$太强了！吊打我！</p><p>然后讲题，改题。</p><p>顺便讲了一下数位dp，学完之后当晚肝了一题<a href="https://www.luogu.org/problemnew/show/P2657" target="_blank" rel="noopener">windy数</a>，感觉良好</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="$Day 3$"></a>$Day 3$</h2><p>还是模拟赛，继续被神仙们狂虐，$50+20+0+20=90rk5$，太菜了吧$qwq$</p><p>第一题被讲题人誉为本次比赛中最难的一题(<del>那为什么还要放在第一题啊</del>)，主要原因是题目很难理解(<del>可以当阅读理解了吧（雾）</del>)，但不知道为什么我暴搜骗了50，第二题讲题人言简意赅地点出了核心思想——<del>乱搞</del>，第三题是道dp但完全看不出来，第四题旁边的$gy$一直跟我说不是最小生成树，不是最小生成树，结果正解就是最小生成树+虚点连边。。。。。。</p><p>再次膜拜我校大佬$lmk$,$10+90+0+100=200rk1$魔鬼！</p><p>最后发现第三题要用压位高精，不然会爆空间，不得不感叹一下出题人的<del>毒瘤</del></p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="$Day 4$"></a>$Day 4$</h2><p>今天没有模拟赛，<del>甚好</del>，去听了一早上的dp，然后下午一直在肝dp</p><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="$Day 5$"></a>$Day 5$</h2><p>又是模拟赛，继续划水，$100+85+10+10=205rk12$菜死了。</p><p>第一题签到题简单模拟，第二题毒瘤数据制造者居然让dfs爆栈了，换成bfs才过，第三题数学题，可惜没看出答案是卡特兰数，而且还要加上高精，最后一题dp打了个暴搜水分。。。</p><p>话说某位老师居然参加了这场比赛而且居然没有AK（笑）</p><p>膜拜我校大佬$xzx$,$100+100+0+100=300rk2$（$rk1$老师）太可怕了。</p><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="$Day 6$"></a>$Day 6$</h2><p>一场异常简单的模拟赛，一堆神仙AK，然而我第一题爆零因为没特判换行符….，该死的OJ，该死的Linux。。。</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="$Day7$"></a>$Day7$</h2><p>没有打比赛而是去听了一下堆，下午找了几题练练，感觉良好。。。</p><p>（priority_queue大法好啊）</p><h2 id="Day8"><a href="#Day8" class="headerlink" title="$Day8$"></a>$Day8$</h2><p>又是被神仙们虐的一天，$100+0+37.5+12.5=150rk5$(<del>希望这是我数学期末考的分数</del>)</p><p>第一题数论，数据范围$O(\sqrt{n})$明显会TLE但竟然让我水过了！第二题二维离散化，又是什么神仙算法。。。第三题Floyd+匈牙利算法，第四题玄学算法（我也不知道我后面是怎么改对的）</p><h2 id="Day-9"><a href="#Day-9" class="headerlink" title="$Day 9$"></a>$Day 9$</h2><p>最后的一场比赛了，然而我还是考炸了，$20+0+0+92.3=112.3rk7$。</p><p>第一题还是恶心数论，不过这次数据只让我的$O(n)$拿了20qwq，第二题听说是状压dp（但我不会呀），第三题dp以为是贪心。。。第四题二分边界设错emmm，还是太粗心了$QwQ$</p><h2 id="Day-10"><a href="#Day-10" class="headerlink" title="$Day 10$"></a>$Day 10$</h2><p>在纪中机房的最后一天了，老师为我们分享了他的OI心得，分别时还是有点不舍。</p><p>晚上放假，和大佬们一起去学校里的公园走了走，回到宿舍开始完成一直未能完成的事业——<del>狼人杀</del>，<del>我们在晚上睡觉时间后跑到别的宿舍玩狼人杀与查房的斗智斗勇超刺激的</del></p><h2 id="Day-11"><a href="#Day-11" class="headerlink" title="$Day 11$"></a>$Day 11$</h2><p>回家。</p><h2 id="the-end"><a href="#the-end" class="headerlink" title="the end."></a>the end.</h2><p>是不可能的</p><h2 id="吐槽区"><a href="#吐槽区" class="headerlink" title="吐槽区"></a>吐槽区</h2><ul><li><p><del>不知道什么时候开始一到机房大家几乎都点开了<a href="https://slay.one/" target="_blank" rel="noopener">slay.one</a>或者<a href="http://2048game.com/" target="_blank" rel="noopener">2048</a></del></p></li><li><p>纪中的食堂的饭菜挺好吃的啊（每天中午第一行第三列孜然鸡腿（只有一天在第二行第四列））</p></li><li><p>fch老师经典语录：我会很烦躁的</p></li><li><p>直到倒数第2（3？）天我们才知道食堂有夜宵，而且是烧烤！然后一下课一堆人(包括我)像sb一样冲了出去（<del>众所周知sb=smart boy</del>）</p></li><li><p>听说纪中好像还是个5A级景区？？？</p></li><li><p>舍监经典语录：你们待在纪中一天就是一天纪中人 / 有没有一点纪律观念时间观念</p></li><li><p>特意去买了一本纪中的草稿纸当纪念，<del>下学期就用它了</del></p></li><li><p>fch老师OJ上的头像</p></li></ul><p><img src="https://i.loli.net/2019/07/14/5d2b4db5e3d7f99738.jpg" alt></p><ul><li><p>一本通的编者之一宋老师竟然来给我们讲课了！而且讲的很好啊（宋老师：让学生听不懂才是一堂好课）</p></li><li><p>等我想到了再补吧······</p></li></ul><h2 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h2><p>第一次去外省培训，一次次被小学生和神仙们虐到自闭。菜死了的我深深地感受到了人外有人。被虐的同时我也学到了许多，数位dp,匈牙利算法,rmq问题,倍增求LCA······也收获了许多友谊。</p><p>在一天纪中，就做一天纪中人。有缘再见，纪中！</p><p>最后引用fch老师的一句话</p><blockquote><p>程序员之所以犯错误，不是因为他们不懂，而是因为他们自以为什么都懂。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;$Day 1$&quot;&gt;&lt;/a&gt;$Day 1$&lt;/h2&gt;&lt;p&gt;坐动车，去学校。&lt;del&gt;顺便去腾讯公司上了个厕所&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;（&lt;del&gt;这学校比我们学校大
      
    
    </summary>
    
    
      <category term="游记" scheme="http://zyx02.github.io/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF581B 【Luxurious Houses】</title>
    <link href="http://zyx02.github.io/2019/06/24/%E9%A2%98%E8%A7%A3-CF581B-%E3%80%90Luxurious-Houses%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/06/24/题解-CF581B-【Luxurious-Houses】/</id>
    <published>2019-06-24T01:56:55.000Z</published>
    <updated>2019-06-25T14:25:15.070Z</updated>
    
    <content type="html"><![CDATA[<p>不难看出，题目要求的是每一个房子后面最高的房子与它的高度差$+1$，（如果比它矮输出$0$）</p><p>我们定义</p><ul><li><p>$maxn[i]$表示第$i$到第$n$个房子高度的最大值（$n$为房子数）</p></li><li><p>$h[i]$表示第$i$个房子的高度</p></li></ul><p>因为$maxn[i+1]$存放的已经是第$i+1$到第$n$个房子的最大值了，所以第$i$到第$n$个房子的最大值只要让当前房子的高度与$maxn[i+1]$进行比较即可</p><p>即$maxn[i]=max(h[i],maxn[i+1])$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[MAXN] , maxn[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i --)</span><br><span class="line">   maxn[i] = max(h[i] , maxn[i + <span class="number">1</span>]); <span class="comment">//预处理最大值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; max(maxn[i + <span class="number">1</span>] - h[i] + <span class="number">1</span> , <span class="number">0</span>) &lt;&lt; <span class="string">" "</span>;<span class="comment">//如果没比它高要输出0！</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//最后一个后面已经没有房子了当然是0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不难看出，题目要求的是每一个房子后面最高的房子与它的高度差$+1$，（如果比它矮输出$0$）&lt;/p&gt;
&lt;p&gt;我们定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$maxn[i]$表示第$i$到第$n$个房子高度的最大值（$n$为房子数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$h[i]$
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
      <category term="动态规划（dp）" scheme="http://zyx02.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1152A 【Neko Finds Grapes】</title>
    <link href="http://zyx02.github.io/2019/05/19/%E9%A2%98%E8%A7%A3-CF1152A-%E3%80%90Neko-Finds-Grapes%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/05/19/题解-CF1152A-【Neko-Finds-Grapes】/</id>
    <published>2019-05-19T09:03:30.000Z</published>
    <updated>2019-06-25T14:26:08.799Z</updated>
    
    <content type="html"><![CDATA[<p>题目大意：</p><p>给出两组数，求两组中的两数之和为奇数的组数（不可重复选取）</p><p>思路：</p><p>我们知道奇数+偶数=奇数</p><p>所以先统计两组中奇数出现的个数和偶数出现的个数</p><p>将第一组数中奇数出现的个数与第二组中偶数进行配对，即取$min(lenji1,lenou2)$ </p><p>再将将第一组数中偶数出现的个数与第二组中奇数进行配对，即取$min(lenou1,lenji2)$</p><p>两个结果相加即可</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> lenji1,lenji2,lenou1,lenou2;<span class="comment">//分别表示第一组数中奇数个数、第二组数中奇数个数、第一组数中偶数个数、第二组中偶数个数</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//统计</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">a%<span class="number">2</span>==<span class="number">1</span>?lenji1++:lenou1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">b%<span class="number">2</span>==<span class="number">1</span>?lenji2++:lenou2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(lenji1,lenou2)+min(lenji2,lenou1);<span class="comment">//取min相加</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目大意：&lt;/p&gt;
&lt;p&gt;给出两组数，求两组中的两数之和为奇数的组数（不可重复选取）&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;我们知道奇数+偶数=奇数&lt;/p&gt;
&lt;p&gt;所以先统计两组中奇数出现的个数和偶数出现的个数&lt;/p&gt;
&lt;p&gt;将第一组数中奇数出现的个数与第二组中偶数进行配对，
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
      <category term="数论,数学" scheme="http://zyx02.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF17A 【Noldbach problem】</title>
    <link href="http://zyx02.github.io/2019/04/18/%E9%A2%98%E8%A7%A3-CF17A-%E3%80%90Noldbach-problem%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/04/18/题解-CF17A-【Noldbach-problem】/</id>
    <published>2019-04-18T15:26:25.000Z</published>
    <updated>2019-06-25T14:24:39.358Z</updated>
    
    <content type="html"><![CDATA[<p>题目要求的是一个素数与它相邻的素数之和$+1$为素数（注意这个素数要$\le n$）</p><p>思路：</p><ul><li><p>预处理$2$~$n$的素数</p></li><li><p>暴力枚举</p></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">1010</span>],len,n,sum,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> num)</span><span class="comment">//素数判断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">2</span> <span class="keyword">or</span> num==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num%<span class="number">6</span>!=<span class="number">5</span> <span class="keyword">and</span> num%<span class="number">6</span>!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i*i&lt;=num;i+=<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span> <span class="keyword">or</span> num%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//预处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime(i))</span><br><span class="line">          p[++len]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len;i++)<span class="comment">//枚举</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime(p[i<span class="number">-1</span>]+p[i]+<span class="number">1</span>) <span class="keyword">and</span> p[i<span class="number">-1</span>]+p[i]+<span class="number">1</span>&lt;=n)</span><br><span class="line">            sum++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(sum&gt;=k?<span class="string">"YES"</span>:<span class="string">"NO"</span>);<span class="comment">//相当于if(sum&gt;=k) cout&lt;&lt;"YES";else cout&lt;&lt;"NO";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用时：$1024ms$</p><p>我们可以在原来的程序做一些小小的优化</p><p>对枚举部分，我们加入一个边界条件</p><p>$p[i-1]+p[i] \le n$（$p[i]$为素数）</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">1010</span>],len,n,sum,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">2</span> <span class="keyword">or</span> num==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num%<span class="number">6</span>!=<span class="number">5</span> <span class="keyword">and</span> num%<span class="number">6</span>!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i*i&lt;=num;i+=<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span> <span class="keyword">or</span> num%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime(i))</span><br><span class="line">          p[++len]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len <span class="keyword">and</span> p[i<span class="number">-1</span>]+p[i]+<span class="number">1</span>&lt;=n;i++)<span class="comment">//边界条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime(p[i<span class="number">-1</span>]+p[i]+<span class="number">1</span>))</span><br><span class="line">            sum++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(sum&gt;=k?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用时：$994ms$ （$emmm$才快了$30ms$）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目要求的是一个素数与它相邻的素数之和$+1$为素数（注意这个素数要$\le n$）&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;预处理$2$~$n$的素数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;暴力枚举&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Code&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
      <category term="数论,数学" scheme="http://zyx02.github.io/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
      <category term="素数" scheme="http://zyx02.github.io/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1133A 【Middle of the Contest】</title>
    <link href="http://zyx02.github.io/2019/04/16/%E9%A2%98%E8%A7%A3-CF1133A-%E3%80%90Middle-of-the-Contest%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/04/16/题解-CF1133A-【Middle-of-the-Contest】/</id>
    <published>2019-04-15T16:02:48.000Z</published>
    <updated>2019-06-25T14:26:11.795Z</updated>
    
    <content type="html"><![CDATA[<p>一道字符串模拟题，思路如下：</p><ul><li><p>1 输入时将两个时间存储</p></li><li><p>2 将两个时间化为以分钟做单位</p></li><li><p>3 得到中间时间与第一个时间的差</p></li><li><p>4 输出</p></li></ul><p>注意：当时间或分钟数$&lt;=9$时，要用$0$补齐位数</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2; </span><br><span class="line"><span class="keyword">int</span> h1,h2,m1,m2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)<span class="comment">//将时间存储</span></span><br><span class="line">  h1+=(s1[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">1</span>-i),h2+=(s2[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">1</span>-i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">  m1+=(s1[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">4</span>-i),m2+=(s2[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">4</span>-i);</span><br><span class="line"><span class="keyword">int</span> ans=((h2*<span class="number">60</span>+m2)-(h1*<span class="number">60</span>+m1))/<span class="number">2</span>;<span class="comment">//求得中间时间与第一个时间的差</span></span><br><span class="line">h1+=ans/<span class="number">60</span>;<span class="comment">//加上时间差</span></span><br><span class="line">m1+=ans%<span class="number">60</span>;</span><br><span class="line"><span class="keyword">if</span>(m1&gt;=<span class="number">60</span>)<span class="comment">//如果分钟&gt;=60要进位</span></span><br><span class="line">&#123;</span><br><span class="line">h1++;</span><br><span class="line">m1%=<span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(h1&lt;=<span class="number">9</span>)<span class="comment">//输出，&lt;=9的用0补齐</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;h1&lt;&lt;<span class="string">":"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;h1&lt;&lt;<span class="string">":"</span>;</span><br><span class="line">   <span class="keyword">if</span>(m1&lt;=<span class="number">9</span>)</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;m1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;m1; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道字符串模拟题，思路如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1 输入时将两个时间存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 将两个时间化为以分钟做单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3 得到中间时间与第一个时间的差&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4 输出&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="字符串" scheme="http://zyx02.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="http://zyx02.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
  </entry>
  
  <entry>
    <title>一些好用的网站</title>
    <link href="http://zyx02.github.io/2019/04/14/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>http://zyx02.github.io/2019/04/14/一些好用的网站/</id>
    <published>2019-04-14T08:54:10.000Z</published>
    <updated>2019-09-29T14:26:37.915Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://www.luogu.org/blog/IowaBattleship/latex-gong-shi-tai-quan" target="_blank" rel="noopener">Latex公式大全</a></p></li><li><p><a href="https://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">Latex在线编辑器</a></p></li><li><p><a href="https://www.desmos.com/calculator" target="_blank" rel="noopener">函数图像绘制</a></p></li><li><p><a href="https://oi-wiki.org/" target="_blank" rel="noopener">OI Wiki</a></p></li><li><p><a href="https://csacademy.com/app/graph_editor/" target="_blank" rel="noopener">图论作图工具</a></p></li><li><p><a href="http://oeis.org/" target="_blank" rel="noopener">数列查询网站</a></p></li><li><p><a href="https://zh.numberempire.com/" target="_blank" rel="noopener">数学工具</a></p></li><li><p><a href="https://yutong.site/sam/" target="_blank" rel="noopener">画SAM</a></p></li><li><p><a href="http://bigjpg.com" target="_blank" rel="noopener">放大图片</a></p></li><li><p><a href="https://visualgo.net/zh" target="_blank" rel="noopener">数据结构与算法可视化</a></p></li><li><p><a href="https://vjudge.net/" target="_blank" rel="noopener">Virtual Judge</a></p></li><li><p><a href="https://bzoj.netlify.com/" target="_blank" rel="noopener">BZOJ离线</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/blog/IowaBattleship/latex-gong-shi-tai-quan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Latex公式大全&lt;/a&gt;&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
    
      <category term="工具" scheme="http://zyx02.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1118A 【Water Buying】</title>
    <link href="http://zyx02.github.io/2019/04/11/%E9%A2%98%E8%A7%A3-CF1118A-%E3%80%90Water-Buying%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/04/11/题解-CF1118A-【Water-Buying】/</id>
    <published>2019-04-11T13:43:57.000Z</published>
    <updated>2019-06-25T14:25:31.636Z</updated>
    
    <content type="html"><![CDATA[<p>题目大意：</p><p>你需要买$n$升水，现在有两种规格的水瓶：1升水的和2升水的，现给出1升水和2升水水瓶的单价，求最少需要花费多少钱。有$q$个询问。</p><p>思路：贪心</p><p>要使总花费最小，我们需要尽量多选取性价比高的规格。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,a,b;<span class="comment">//注意要开long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a*<span class="number">2</span>&lt;=b)<span class="comment">//买1升的性价比高于买2升的性价比</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n*a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n/<span class="number">2</span>*b+(n-n/<span class="number">2</span>*<span class="number">2</span>)*a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//题目要求的是刚好购买n升，所以不足2升的要买1升的补齐</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目大意：&lt;/p&gt;
&lt;p&gt;你需要买$n$升水，现在有两种规格的水瓶：1升水的和2升水的，现给出1升水和2升水水瓶的单价，求最少需要花费多少钱。有$q$个询问。&lt;/p&gt;
&lt;p&gt;思路：贪心&lt;/p&gt;
&lt;p&gt;要使总花费最小，我们需要尽量多选取性价比高的规格。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
      <category term="贪心" scheme="http://zyx02.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1092B 【Teams Forming】</title>
    <link href="http://zyx02.github.io/2019/04/10/%E9%A2%98%E8%A7%A3-CF1092B-%E3%80%90Teams-Forming%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/04/10/题解-CF1092B-【Teams-Forming】/</id>
    <published>2019-04-10T14:08:21.000Z</published>
    <updated>2019-06-25T14:25:25.543Z</updated>
    
    <content type="html"><![CDATA[<p>这题的基本思想就是贪心吧</p><p>题目就是让你两两分组，使得每组能力值的差值最小</p><p>设$a_{1},a_{2},···,a_{n}$表示每个学生的能力值</p><p>且满足：$a_{1} \le a_{2} \le ··· \le a_{n}$</p><p>则对于任意一个能力值$a_{i}$，它的最优匹配为$a_{i+1}$（$i$为奇数）</p><p>考虑到$a_{1}$，我们不取$a_{i-1}$（你想想$a_{1-1}$是什么）</p><p>假设存在一个能力值$a_{k}$ ($k&gt; i+1$)，使得$a_{k}-a_{i}&lt; a_{i+1}-a_{i}$</p><p>即: $a_{k}&lt;a_{i+1}$</p><p>∵ $a_{i+1}&lt;a_{k}$</p><p>∴ 不存在这样的$k$</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>],ans; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);<span class="comment">//要先排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>) <span class="comment">//i要为奇数</span></span><br><span class="line">&#123;    </span><br><span class="line">ans+=a[i+<span class="number">1</span>]-a[i];<span class="comment">//答案加上两个能力值的差</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这题的基本思想就是贪心吧&lt;/p&gt;
&lt;p&gt;题目就是让你两两分组，使得每组能力值的差值最小&lt;/p&gt;
&lt;p&gt;设$a_{1},a_{2},···,a_{n}$表示每个学生的能力值&lt;/p&gt;
&lt;p&gt;且满足：$a_{1} \le a_{2} \le ··· \le a_{n}$&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
      <category term="贪心" scheme="http://zyx02.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1145F 【Neat Words】</title>
    <link href="http://zyx02.github.io/2019/04/08/%E9%A2%98%E8%A7%A3-CF1145F-%E3%80%90Neat-Words%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/04/08/题解-CF1145F-【Neat-Words】/</id>
    <published>2019-04-08T13:30:27.000Z</published>
    <updated>2019-06-25T14:26:10.485Z</updated>
    
    <content type="html"><![CDATA[<p>这题其实是一道很水的字符串模拟，不要被难度骗了</p><p><del>CF恶意评分又不是一两天了（雾）</del></p><p>注意题目中说到的</p><blockquote><p>由直线或都是由曲线构成的</p></blockquote><p>是指该字母的笔画（我理解题目理解了半天$qwq$）</p><p>具体思路：</p><ul><li>1 应用$map$将由直线（或者曲线）构成的字母的映射值设为1</li></ul><ul><li>2 计算该字符串的所有对应的映射值之和，因为题目要求全为直线或全为曲线，所以当总和为$len$($len$为字符串长度)或$0$时，输出$YES$，否则输出$NO$</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">bool</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">p[<span class="string">'A'</span>]=<span class="number">1</span>;<span class="comment">//打表</span></span><br><span class="line">p[<span class="string">'E'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'F'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'H'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'I'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'K'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'L'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'M'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'N'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'T'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'V'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'W'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'X'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'Y'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'Z'</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++) sum+=p[s[i]];<span class="comment">//统计映射值之和</span></span><br><span class="line"><span class="keyword">if</span>(sum==s.size() <span class="keyword">or</span> sum==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>;<span class="comment">//判断</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这题其实是一道很水的字符串模拟，不要被难度骗了&lt;/p&gt;
&lt;p&gt;&lt;del&gt;CF恶意评分又不是一两天了（雾）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;注意题目中说到的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由直线或都是由曲线构成的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是指该字母的笔画
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="字符串" scheme="http://zyx02.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="http://zyx02.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
  </entry>
  
  <entry>
    <title>题解 P1794 【装备运输_NOI导刊2010提高（04）】</title>
    <link href="http://zyx02.github.io/2019/04/06/%E9%A2%98%E8%A7%A3-P1794-%E3%80%90%E8%A3%85%E5%A4%87%E8%BF%90%E8%BE%93-NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%EF%BC%8804%EF%BC%89%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/04/06/题解-P1794-【装备运输-NOI导刊2010提高（04）】/</id>
    <published>2019-04-06T06:15:59.000Z</published>
    <updated>2019-06-25T14:26:01.197Z</updated>
    
    <content type="html"><![CDATA[<p>一道01背包模板题吧。。。其实就是再增加了一个体积参数</p><p>状态转移方程：</p><p>$F_{j,k}=max(F_{j-v_{i},k-g_{i}}+t_{i},F_{j,k})$</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> V,G,n;<span class="comment">//V和G为最大体积和重量</span></span><br><span class="line"><span class="keyword">int</span> t[<span class="number">510</span>],v[<span class="number">510</span>],g[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V&gt;&gt;G;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;v[i]&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v[i];j--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=G;k&gt;=g[i];k--) </span><br><span class="line">      f[j][k]=max(f[j-v[i]][k-g[i]]+t[i],f[j][k]);<span class="comment">//状态转移方程</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[V][G];<span class="comment">//f[V][G]即为答案</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道01背包模板题吧。。。其实就是再增加了一个体积参数&lt;/p&gt;
&lt;p&gt;状态转移方程：&lt;/p&gt;
&lt;p&gt;$F_{j,k}=max(F_{j-v_{i},k-g_{i}}+t_{i},F_{j,k})$&lt;/p&gt;
&lt;p&gt;Code&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="动态规划（dp）" scheme="http://zyx02.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89/"/>
    
      <category term="背包" scheme="http://zyx02.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1043A 【Elections】</title>
    <link href="http://zyx02.github.io/2019/04/01/%E9%A2%98%E8%A7%A3-CF1043A-%E3%80%90Elections%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/04/01/题解-CF1043A-【Elections】/</id>
    <published>2019-04-01T15:41:41.000Z</published>
    <updated>2019-06-25T14:25:20.001Z</updated>
    
    <content type="html"><![CDATA[<p>一看数据范围， $1 \le n \le 100 $，此时不枚举更待何时？（雾）</p><p>注意获胜是指小$A$的票数大于小$B$的票数，而不是大于等于。（原谅作者语文不好$qwq$）</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> sum1,sum2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//自定义排序函数，从大到小排</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],sum1+=a[i];<span class="comment">//预处理小B的票数</span></span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,comp);<span class="comment">//因为k&gt;=max&#123;ai&#125;，所以考虑先排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=a[<span class="number">1</span>];;k++)</span><br><span class="line">&#123;</span><br><span class="line">sum2=<span class="number">0</span>;<span class="comment">//一定要初始化！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  sum2+=k-a[i];<span class="comment">//每个人投给小A的票数就是每个人可以投的票数减去每个人投给小B的票数</span></span><br><span class="line"><span class="keyword">if</span>(sum2&gt;sum1)<span class="comment">//是&gt;不是&gt;=</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察一下代码，我们发现可以在求小$A$的票数部分做一些小小的优化</p><p>观察可以发现，$sum2$=$\sum_{i=1}^{n}(k-a_{i})$</p><p>原式</p><p>$=$ $k\times n-\sum_{i=1}^{n}a_{i}$ </p><p>$=$ $k\times n-sum1$</p><p>于是在求小$A$的票数部分可以优化到$O(1)$复杂度</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> sum1,sum2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],sum1+=a[i];</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,comp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=a[<span class="number">1</span>];;k++)</span><br><span class="line">&#123;</span><br><span class="line">sum2=k*n-sum1;<span class="comment">//求小A的票数，当然你也可以不用再设一个变量直接比较</span></span><br><span class="line"><span class="keyword">if</span>(sum2&gt;sum1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再观察一下这个程序，我们发现，这个程序其实就要求最小的$k$，使得$k$满足$k\times n-sum1&gt;sum1$</p><p>这不就是一个不等式吗</p><p>移项： $k\times n&gt;2\times sum1$</p><p>系数化一: $k&gt;2\times sum1 /n$</p><p>于是在求答案的部分就可以优化到$O(1)$复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> sum1;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],sum1+=a[i];</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,comp);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>*sum1/n+<span class="number">1</span>&lt;a[<span class="number">1</span>]) <span class="built_in">cout</span>&lt;&lt;a[<span class="number">1</span>];<span class="comment">//因为k要&gt;=max a[i]，所以如果2*sum/n+1&lt;a[1]要输出a[1]</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>*sum1/n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一看数据范围， $1 \le n \le 100 $，此时不枚举更待何时？（雾）&lt;/p&gt;
&lt;p&gt;注意获胜是指小$A$的票数大于小$B$的票数，而不是大于等于。（原谅作者语文不好$qwq$）&lt;/p&gt;
&lt;h3 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
      <category term="枚举" scheme="http://zyx02.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>set学习笔记</title>
    <link href="http://zyx02.github.io/2019/03/31/set%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyx02.github.io/2019/03/31/set学习笔记/</id>
    <published>2019-03-30T17:25:40.000Z</published>
    <updated>2019-06-25T14:24:07.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是set-和-set的好处"><a href="#1-什么是set-和-set的好处" class="headerlink" title="1.什么是set 和 set的好处"></a>1.什么是set 和 set的好处</h2><p>$set$的翻译为集合，是一个内部自动有序且不含重复元素(即满足集合的互异性)的$STL$容器，其内部采用“红黑树”实现。</p><p>什么是集合？<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117?fr=aladdin" target="_blank" rel="noopener">点这</a></p><p>$set$的好处在于自动完成去重和按升序排序</p><h2 id="2-举个栗子"><a href="#2-举个栗子" class="headerlink" title="2.举个栗子"></a>2.举个栗子</h2><p>比如<a href="https://www.luogu.org/problemnew/show/P1059" target="_blank" rel="noopener">这题</a></p><h4 id="1-普通作法"><a href="#1-普通作法" class="headerlink" title="1.普通作法"></a>1.普通作法</h4><p>看到数据范围这么水肯定想到用桶排</p><p>Code<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">1001</span>],n,i,j,m=<span class="number">0</span>,x;</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(b[x]==<span class="number">0</span>) m++;</span><br><span class="line">        b[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">      <span class="keyword">if</span>(b[i]&gt;<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-set"><a href="#2-set" class="headerlink" title="2.set"></a>2.set</h4><p>如果你会了$set$，这道题就可以这么打</p><p>Code<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        st.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.size()); </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it= st.begin(); it!=st.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果数据范围大了话，明显不能用桶排解决，这时候$set$的好处就可以体现出来。</p><p>领会了$set$的好处之后，接下来让我们了解</p><h2 id="3-set的定义"><a href="#3-set的定义" class="headerlink" title="3.set的定义"></a>3.set的定义</h2><p>使用$set$之前，必须添加$set$头文件，即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>也可以打好我们的$bits/stdc++.h$</p><p>同时必须要有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>定义一个$set$的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>其中$typename$为任何基本类型或者容器，$name$为这个集合的名字</p><p>同时$set$也支持定义数组，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;typename&gt; name[MAXN]</span><br></pre></td></tr></table></figure><p>即定义了$MAXN$个$set$容器</p><h2 id="4-set的访问"><a href="#4-set的访问" class="headerlink" title="4.set的访问"></a>4.set的访问</h2><p>一大坑点是$set$只能通过迭代器访问</p><h3 id="1-定义一个迭代器"><a href="#1-定义一个迭代器" class="headerlink" title="1.定义一个迭代器"></a>1.定义一个迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>即定义一个名为$it$的迭代器</p><h3 id="2-通过迭代器访问"><a href="#2-通过迭代器访问" class="headerlink" title="2.通过迭代器访问"></a>2.通过迭代器访问</h3><p>注意事项：</p><ul><li><p>1 $set$不支持类似*$(it+i)$的访问</p></li><li><p>2 $set$也不支持$it&lt;name.end()$这种访问</p></li></ul><p>我们需要使用*$it$来访问$set$中的元素</p><h2 id="5-set的常用函数"><a href="#5-set的常用函数" class="headerlink" title="5.set的常用函数"></a>5.set的常用函数</h2><h3 id="1-insert"><a href="#1-insert" class="headerlink" title="1.insert()"></a>1.insert()</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><p>$insert()$用来插入一个数到$set$中，并自动排序+去重</p><h4 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(log_{2}n)$</p><h4 id="3-用法"><a href="#3-用法" class="headerlink" title="3.用法"></a>3.用法</h4><p>例如，以下一段代码输出$1$ $2$ $3 $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-begin-和end"><a href="#2-begin-和end" class="headerlink" title="2.begin()和end()"></a>2.begin()和end()</h3><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1.作用"></a>1.作用</h4><p>分别用来获取$set$容器的首地址和尾地址</p><p>用法跟其他$STL$容器一样这里不再赘述</p><h3 id="3-size"><a href="#3-size" class="headerlink" title="3.size()"></a>3.size()</h3><h4 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用"></a>1.作用</h4><p>用于获取$set$容器中元素的个数</p><h4 id="2-时间复杂度-1"><a href="#2-时间复杂度-1" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(1)$</p><h4 id="3-用法-1"><a href="#3-用法-1" class="headerlink" title="3.用法"></a>3.用法</h4><p>例如，以下一段代码输出$3$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.insert(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size();</span><br></pre></td></tr></table></figure><h3 id="4-clear"><a href="#4-clear" class="headerlink" title="4.clear()"></a>4.clear()</h3><h4 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用"></a>1.作用</h4><p>用于清空$set$容器中的所有元素</p><h4 id="2-时间复杂度-2"><a href="#2-时间复杂度-2" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(n)$ ($n$为$set$中的元素个数)</p><h4 id="3-用法-2"><a href="#3-用法-2" class="headerlink" title="3.用法"></a>3.用法</h4><p>例如，以下一段代码输出$1$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.clear();</span><br><span class="line">a.insert(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size();</span><br></pre></td></tr></table></figure><h3 id="5-erase"><a href="#5-erase" class="headerlink" title="5.erase()"></a>5.erase()</h3><h4 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用"></a>1.作用</h4><p>可以用来删除单个元素也可以用来删除一段区间的元素</p><p>1.删除单个元素</p><h5 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h5><p>$O(1)$ (使用迭代器)</p><p>$O(log_{2}n)$ (使用欲删除元素的值)</p><h5 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h5><p>1.$erase(it)$</p><p>$it$为欲删除的元素的迭代器</p><p>例如，以下一段代码输出$2$ $3$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.erase(a.begin());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.$erase(value)$</p><p>$value$为欲删除元素的值</p><p>例如以下一段代码输出$1$ $3$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.erase(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.删除一个区间的元素</p><h5 id="1-时间复杂度-1"><a href="#1-时间复杂度-1" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h5><p>$O(right-left)$ $(左闭右开区间[left,right))$</p><h5 id="2-用法-1"><a href="#2-用法-1" class="headerlink" title="2.用法"></a>2.用法</h5><p>$erase(left,right)$用来删除左闭右开区间[$left$,$right$)之间的元素</p><p>例如，以下一段代码输出$1$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.find(<span class="number">2</span>);</span><br><span class="line">a.erase(it,a.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-find"><a href="#6-find" class="headerlink" title="6.find()"></a>6.find()</h3><h4 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1.作用"></a>1.作用</h4><p>返回元素在$set$中的迭代器</p><h4 id="2-时间复杂度-3"><a href="#2-时间复杂度-3" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(log_{2}n)$ ($n$为$set$中的元素个数)</p><h4 id="3-用法-3"><a href="#3-用法-3" class="headerlink" title="3.用法"></a>3.用法</h4><p>例如，以下一段代码输出$2$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*a.find(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="6-推荐例题"><a href="#6-推荐例题" class="headerlink" title="6.推荐例题"></a>6.推荐例题</h2><ul><li>1 <a href="https://www.luogu.org/problemnew/show/P1059" target="_blank" rel="noopener">洛谷P1059 明明的随机数</a></li></ul><p>之后还会继续放上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是set-和-set的好处&quot;&gt;&lt;a href=&quot;#1-什么是set-和-set的好处&quot; class=&quot;headerlink&quot; title=&quot;1.什么是set 和 set的好处&quot;&gt;&lt;/a&gt;1.什么是set 和 set的好处&lt;/h2&gt;&lt;p&gt;$set$的翻译为集
      
    
    </summary>
    
    
      <category term="set" scheme="http://zyx02.github.io/tags/set/"/>
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="学习笔记" scheme="http://zyx02.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1130A 【Be Positive】</title>
    <link href="http://zyx02.github.io/2019/03/30/%E9%A2%98%E8%A7%A3-CF1130A-%E3%80%90Be-Positive%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/03/30/题解-CF1130A-【Be-Positive】/</id>
    <published>2019-03-29T16:47:02.000Z</published>
    <updated>2019-06-25T14:26:13.558Z</updated>
    
    <content type="html"><![CDATA[<p>一看数据范围：</p><p>$-10^{3}\le d \le 10^{3}$，$1 \le n \le 100$</p><p>这是让我们<del>打表</del>枚举的节奏啊（雾）</p><p>思路很简单，枚举每一个$d$，判断是否满足条件即可</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">-1000</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//d不能为0</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[j]*i&gt;<span class="number">0</span>) sum++;<span class="comment">//a[i]/d与a[i]*d同正负</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>*sum&gt;=n) <span class="comment">//满足条件</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一看数据范围：&lt;/p&gt;
&lt;p&gt;$-10^{3}\le d \le 10^{3}$，$1 \le n \le 100$&lt;/p&gt;
&lt;p&gt;这是让我们&lt;del&gt;打表&lt;/del&gt;枚举的节奏啊（雾）&lt;/p&gt;
&lt;p&gt;思路很简单，枚举每一个$d$，判断是否满足条件即可&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
      <category term="枚举" scheme="http://zyx02.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>A+B problem(高精)python</title>
    <link href="http://zyx02.github.io/2019/03/27/A-B-problem-%E9%AB%98%E7%B2%BE-python/"/>
    <id>http://zyx02.github.io/2019/03/27/A-B-problem-高精-python/</id>
    <published>2019-03-27T15:17:25.000Z</published>
    <updated>2019-06-25T14:23:51.898Z</updated>
    
    <content type="html"><![CDATA[<p>自带高精就是好呢，代码好简单/QwQ<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=input()</span><br><span class="line">b=input()</span><br><span class="line">a=int(a)</span><br><span class="line">b=int(b)</span><br><span class="line">print(a+b)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自带高精就是好呢，代码好简单/QwQ&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
      <category term="python" scheme="http://zyx02.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF102A 【Clothes】</title>
    <link href="http://zyx02.github.io/2019/03/27/%E9%A2%98%E8%A7%A3-CF102A-%E3%80%90Clothes%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/03/27/题解-CF102A-【Clothes】/</id>
    <published>2019-03-27T12:51:31.000Z</published>
    <updated>2019-06-25T14:25:04.508Z</updated>
    
    <content type="html"><![CDATA[<p>本萌新来介绍一种$dfs$思路：</p><ul><li><p>1 如果件数已经$=$3，那么判断，如果符合条件，则更新答案</p></li><li><p>2 如果件数$&lt;$3，那么枚举$1$~$n$,如果该件衣服没被取过，则标记为已取并$dfs$下一件</p></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,money[<span class="number">110</span>],minx=INT_MAX;</span><br><span class="line"><span class="keyword">bool</span> p[<span class="number">110</span>][<span class="number">110</span>],f,use[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">()</span><span class="comment">//判断是否符合条件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p[s[<span class="number">1</span>]][s[<span class="number">2</span>]] <span class="keyword">and</span> p[s[<span class="number">1</span>]][s[<span class="number">3</span>]] <span class="keyword">and</span> p[s[<span class="number">2</span>]][s[<span class="number">3</span>]]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t&gt;<span class="number">3</span>)<span class="comment">//件数&gt;3判断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(comp())</span><br><span class="line">    &#123;</span><br><span class="line">    f=<span class="number">1</span>;<span class="comment">//标记为有方案</span></span><br><span class="line">    minx=min(minx,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!use[i])<span class="comment">//该件衣服没被取过</span></span><br><span class="line">&#123;</span><br><span class="line">s[t]=i;<span class="comment">//保存答案编号用于之后判断</span></span><br><span class="line">use[i]=<span class="number">1</span>;<span class="comment">//标记为已取</span></span><br><span class="line">dfs(t+<span class="number">1</span>,sum+money[i]);</span><br><span class="line">use[i]=<span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;money[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    p[x][y]=<span class="number">1</span>;<span class="comment">//建有向图</span></span><br><span class="line">    p[y][x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(f) <span class="built_in">cout</span>&lt;&lt;minx;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本萌新来介绍一种$dfs$思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1 如果件数已经$=$3，那么判断，如果符合条件，则更新答案&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 如果件数$&amp;lt;$3，那么枚举$1$~$n$,如果该件衣服没被取过，则标记为已取并$dfs$下一件&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
      <category term="深度优先搜索（dfs）" scheme="http://zyx02.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88dfs%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>string学习笔记</title>
    <link href="http://zyx02.github.io/2019/03/24/string%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyx02.github.io/2019/03/24/string学习笔记/</id>
    <published>2019-03-23T16:02:40.000Z</published>
    <updated>2019-06-25T14:24:15.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-What’s-string"><a href="#1-What’s-string" class="headerlink" title="1.What’s string"></a>1.What’s string</h2><p>$string$ 是一种$STL$的容器，支持多种字符串操作。</p><h2 id="2-string的定义"><a href="#2-string的定义" class="headerlink" title="2.string的定义"></a>2.string的定义</h2><p>使用$string$需要添加头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure><p>或者打好万能库，胜过<del>zhw</del></p><p>同时必须要有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>定义$string$的方法非常简单，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name;<span class="comment">//name为字符串名称</span></span><br></pre></td></tr></table></figure><p>同时也可以定义$string$数组，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name[MAXN];<span class="comment">//name为数组名，MAXN为数组大小</span></span><br></pre></td></tr></table></figure><p>即这个数组中的每一个元素都是$string$类型</p><h2 id="3-string初始化"><a href="#3-string初始化" class="headerlink" title="3.string初始化"></a>3.string初始化</h2><p>可以直接在定义的时候初始化，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name=<span class="string">"I love C++!"</span>;</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> name;</span><br><span class="line">name=<span class="string">"I love C++!"</span>;</span><br></pre></td></tr></table></figure><p>也可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"I love C++!"</span>)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="4-string的访问"><a href="#4-string的访问" class="headerlink" title="4.string的访问"></a>4.string的访问</h2><h3 id="1-通过下标访问"><a href="#1-通过下标访问" class="headerlink" title="1.通过下标访问"></a>1.通过下标访问</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C++!"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,s[<span class="number">0</span>]);<span class="comment">//输出I</span></span><br></pre></td></tr></table></figure><h3 id="2-通过迭代器访问"><a href="#2-通过迭代器访问" class="headerlink" title="2.通过迭代器访问"></a>2.通过迭代器访问</h3><h4 id="1-迭代器的定义"><a href="#1-迭代器的定义" class="headerlink" title="1.迭代器的定义"></a>1.迭代器的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::iterator node;<span class="comment">//定义一个名为node的迭代器</span></span><br></pre></td></tr></table></figure><h4 id="2-访问"><a href="#2-访问" class="headerlink" title="2.访问"></a>2.访问</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C++"</span>;</span><br><span class="line"><span class="built_in">string</span>::iterator node=s.begin()<span class="comment">//获取s的首地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,*node);<span class="comment">//输出I(因为是迭代器所以前面要加上*)</span></span><br></pre></td></tr></table></figure><h2 id="5-string的基本运算"><a href="#5-string的基本运算" class="headerlink" title="5.string的基本运算"></a>5.string的基本运算</h2><h3 id="1-加法运算"><a href="#1-加法运算" class="headerlink" title="1.加法运算"></a>1.加法运算</h3><p>加法运算可以将两个字符串拼接在一起，但加号两边必须至少有一个为$string$类型</p><p>如，下列程序是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">"I love "</span>;</span><br><span class="line"><span class="built_in">string</span> s2=<span class="string">"C++"</span>;</span><br><span class="line">s1+=s2;<span class="comment">//等价于s1=s1+s2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;<span class="comment">//输出I love C++</span></span><br></pre></td></tr></table></figure><p>但下列程序是不合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">"I love "</span>+<span class="string">"C++"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>下列程序依然合法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s2=<span class="string">"C"</span>;</span><br><span class="line"><span class="built_in">string</span> s1=<span class="string">"I love "</span>+s2+<span class="string">"++"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出I love C++</span></span><br></pre></td></tr></table></figure><h3 id="2-关系运算"><a href="#2-关系运算" class="headerlink" title="2.关系运算"></a>2.关系运算</h3><p>关系运算可以按字典序比较两个字符串的大小，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">"abcde"</span>;</span><br><span class="line"><span class="built_in">string</span> s2=<span class="string">"bcdef"</span>;</span><br><span class="line"><span class="keyword">if</span>(s1&lt;s2) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Winner!"</span>;<span class="comment">//输出Winner!</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Lose!"</span>;</span><br></pre></td></tr></table></figure><h2 id="6-string的输入与输出"><a href="#6-string的输入与输出" class="headerlink" title="6.string的输入与输出"></a>6.string的输入与输出</h2><h3 id="1-利用cin和cout输入输出"><a href="#1-利用cin和cout输入输出" class="headerlink" title="1.利用cin和cout输入输出"></a>1.利用cin和cout输入输出</h3><p>$cin$在读到空格时将会停止读入，例如以下一段程序输入$123$ $456$后，仅会输出$123$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;</span><br></pre></td></tr></table></figure><h3 id="2-利用getline输入"><a href="#2-利用getline输入" class="headerlink" title="2.利用getline输入"></a>2.利用getline输入</h3><p>$getline$可以用来读整行的字符串(包括空格)，例如以下一段程序输入$123$ $456$后，输出$123$ $456$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line">getline(<span class="built_in">cin</span>,s);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;</span><br></pre></td></tr></table></figure><h3 id="3-将string转换为字符数组输入输出"><a href="#3-将string转换为字符数组输入输出" class="headerlink" title="3.将string转换为字符数组输入输出"></a>3.将string转换为字符数组输入输出</h3><p>$c$_$str()$可以将$string$转换为字符数组，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s.c_str());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,s.c_str());</span><br></pre></td></tr></table></figure><p>输入$123$ $456$ 输出$123$ </p><h2 id="7-string的常用函数"><a href="#7-string的常用函数" class="headerlink" title="7.string的常用函数"></a>7.string的常用函数</h2><h3 id="1-length-和size"><a href="#1-length-和size" class="headerlink" title="1.length()和size()"></a>1.length()和size()</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><p>用来获取字符串的长度，即字符个数</p><h4 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(1)$</p><h4 id="3-用法"><a href="#3-用法" class="headerlink" title="3.用法"></a>3.用法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"abcd"</span>;</span><br><span class="line"><span class="keyword">int</span> len=s.size();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;len;<span class="comment">//输出4</span></span><br></pre></td></tr></table></figure><h3 id="2-begin-和end"><a href="#2-begin-和end" class="headerlink" title="2.begin()和end()"></a>2.begin()和end()</h3><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1.作用"></a>1.作用</h4><p>分别用来获取字符串的首地址和尾地址，一般与迭代器配合使用</p><h4 id="2-时间复杂度-1"><a href="#2-时间复杂度-1" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(1)$?</p><h4 id="3-用法-1"><a href="#3-用法-1" class="headerlink" title="3.用法"></a>3.用法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C++!"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=s.begin()+<span class="number">2</span>;it!=s.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,*it);<span class="comment">//输出love C++! </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-clear"><a href="#3-clear" class="headerlink" title="3.clear()"></a>3.clear()</h3><h4 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用"></a>1.作用</h4><p>用来清空字符串中的所有元素</p><h4 id="2-时间复杂度-2"><a href="#2-时间复杂度-2" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(1)$</p><h4 id="3-用法-2"><a href="#3-用法-2" class="headerlink" title="3.用法"></a>3.用法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C++!"</span>;</span><br><span class="line">s.clear();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//输出为空</span></span><br></pre></td></tr></table></figure><h3 id="4-substr"><a href="#4-substr" class="headerlink" title="4.substr()"></a>4.substr()</h3><h4 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用"></a>1.作用</h4><p>返回字符串的字串</p><h4 id="2-时间复杂度-3"><a href="#2-时间复杂度-3" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(n)$ ($n$为字符串长度)</p><h4 id="3-用法-3"><a href="#3-用法-3" class="headerlink" title="3.用法"></a>3.用法</h4><p>$s.substr(node,len)$返回从$node$位置开始，长度为$len$的字串</p><p>如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C++!"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.substr(<span class="number">2</span>,<span class="number">4</span>);<span class="comment">//输出love</span></span><br></pre></td></tr></table></figure><h3 id="5-insert"><a href="#5-insert" class="headerlink" title="5.insert()"></a>5.insert()</h3><h4 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用"></a>1.作用</h4><p>插入字符串</p><h4 id="2-时间复杂度-4"><a href="#2-时间复杂度-4" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(n)$ ($n$为字符串长度)</p><h4 id="3-用法-4"><a href="#3-用法-4" class="headerlink" title="3.用法"></a>3.用法</h4><p>$insert$有多种写法</p><p>1.$insert(node,s)$ 在$node$号位置插入字符串$s$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I  C++!"</span>;</span><br><span class="line">s.insert(<span class="number">2</span>,<span class="string">"love"</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//输出I love C++!</span></span><br></pre></td></tr></table></figure><p>2.$insert(node,s,sum)$ 在$node$号位置插入字符串$s$的前$sum$个字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I  C++!"</span>;</span><br><span class="line">s.insert(<span class="number">2</span>,<span class="string">"love python"</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//输出I love C++!</span></span><br></pre></td></tr></table></figure><p>3.$insert(it,it2,it3)$ $it$为原字符串的欲插入位置，$it1$,$it2$为待插入字符串的首尾迭代器(左闭右开)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I  C++!"</span>;</span><br><span class="line"><span class="built_in">string</span> ss=<span class="string">"love python"</span>;</span><br><span class="line">s.insert(s.begin()+<span class="number">2</span>,ss.begin(),ss.begin()+<span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//输出I love C++!</span></span><br></pre></td></tr></table></figure><p>4.$insert(node,sum,c)$ 在$node$号位置插入$sum$个字符$c$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C!"</span>;</span><br><span class="line">s.insert(<span class="number">8</span>,<span class="number">2</span>,<span class="string">'+'</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//输出I love C++!</span></span><br></pre></td></tr></table></figure><h3 id="6-erase"><a href="#6-erase" class="headerlink" title="6.erase()"></a>6.erase()</h3><h4 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1.作用"></a>1.作用</h4><p>$erase()$可以删除单个字符或一个区间内的字符</p><h4 id="2-时间复杂度-5"><a href="#2-时间复杂度-5" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(n)$ ($n$为字符串长度)</p><h4 id="3-用法-5"><a href="#3-用法-5" class="headerlink" title="3.用法"></a>3.用法</h4><p>1.$erase(it)$ $it$为欲删除元素的迭代器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C+++!"</span>;</span><br><span class="line">s.erase(s.begin()+<span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//输出I love C++!</span></span><br></pre></td></tr></table></figure><p>2.$erase(left,right)$ $left$为区间的起始迭代器，$right$为区间末尾迭代器的下一个地址。左闭右开区间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C++++!"</span>;</span><br><span class="line">s.erase(s.begin()+<span class="number">10</span>,s.begin()+<span class="number">12</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//输出I love C++!</span></span><br></pre></td></tr></table></figure><p>3.$erase(node,len)$ 删除从$node$号位置开始$len$个字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C++++!"</span>;</span><br><span class="line">s.erase(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//输出I love C++!</span></span><br></pre></td></tr></table></figure><h3 id="7-find"><a href="#7-find" class="headerlink" title="7.find()"></a>7.find()</h3><h4 id="1-作用-6"><a href="#1-作用-6" class="headerlink" title="1.作用"></a>1.作用</h4><p>返回子串第一次出现的位置，如果找不到返回string::npos</p><h4 id="2，时间复杂度"><a href="#2，时间复杂度" class="headerlink" title="2，时间复杂度"></a>2，时间复杂度</h4><p>$O(nm)$ $n,m$分别为第一个，第二个字符串的长度</p><h4 id="3，用法"><a href="#3，用法" class="headerlink" title="3，用法"></a>3，用法</h4><p>1.$find(s)$，返回$s$在原字符串第一次出现的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C++!"</span>;</span><br><span class="line"><span class="keyword">if</span>(s.find(<span class="string">"C++"</span>)!=<span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.find(<span class="string">"C++"</span>)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">if</span>(s.find(<span class="string">"python"</span>)!=<span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.find(<span class="string">"python"</span>)&lt;&lt;<span class="string">" "</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="string">" "</span>;<span class="comment">//输出7 -1</span></span><br></pre></td></tr></table></figure><p>2.$find(s,node)$ 返回原字符串从$node$号位置开始$s$第一次出现的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love C++!"</span>;</span><br><span class="line"><span class="keyword">if</span>(s.find(<span class="string">"C++"</span>)!=<span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.find(<span class="string">"C++"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span>(s.find(<span class="string">"C++"</span>,<span class="number">8</span>)!=<span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.find(<span class="string">"python"</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//输出7 -1</span></span><br></pre></td></tr></table></figure><h3 id="8-replace"><a href="#8-replace" class="headerlink" title="8.replace()"></a>8.replace()</h3><h4 id="1-作用-7"><a href="#1-作用-7" class="headerlink" title="1.作用"></a>1.作用</h4><p>替换字符串</p><h4 id="2-时间复杂度-6"><a href="#2-时间复杂度-6" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(n)$ ($n$为要替换的字符串长度)</p><h4 id="3-用法-6"><a href="#3-用法-6" class="headerlink" title="3.用法"></a>3.用法</h4><p>1.$replace(node,len,s)$ 把原字符串从$node$号位置长度为$len$的子串替换为$s$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love python!"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.replace(<span class="number">7</span>,<span class="number">6</span>,<span class="string">"C++"</span>);<span class="comment">//输出I love C++!</span></span><br></pre></td></tr></table></figure><p>2.$replace(it1,it2,s)$ 表示把原字符串的迭代器$it1$~$it2$范围内(左闭右开区间)的子串替换为$s$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"I love python!"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.replace(s.begin()+<span class="number">7</span>,s.begin()+<span class="number">13</span>,<span class="string">"C++"</span>);<span class="comment">//输出I love C++!</span></span><br></pre></td></tr></table></figure><h2 id="8-字符串数字互化"><a href="#8-字符串数字互化" class="headerlink" title="8.字符串数字互化"></a>8.字符串数字互化</h2><p>可以用$sscanf$和$sprintf$实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"19260817"</span>;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">sscanf</span>(s.c_str(),<span class="string">"%d"</span>,&amp;a);<span class="comment">//把s以整数的形式输入到a(s要为字符数组)</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a;<span class="comment">//输出19260817</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">19260817</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(s,<span class="string">"%d"</span>,a);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;<span class="comment">//输出19260817</span></span><br></pre></td></tr></table></figure><p>同时我们也可以用一个神奇的东西——$stringstream$</p><p>友情提示：这个东西十分耗时!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line"><span class="built_in">string</span> s=<span class="string">"19260817"</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ss&lt;&lt;s;<span class="comment">//将s传入ss</span></span><br><span class="line">ss&gt;&gt;n;<span class="comment">//将ss传入n</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n;<span class="comment">//输出19260817</span></span><br></pre></td></tr></table></figure><p>如果要多次调用$stringstream$,记住在每一次使用前都要$clear()$</p><h2 id="9-推荐例题"><a href="#9-推荐例题" class="headerlink" title="9.推荐例题"></a>9.推荐例题</h2><ul><li><p>1 <del><a href="https://www.luogu.org/problemnew/show/P2482" target="_blank" rel="noopener">猪国杀</a></del></p></li><li><p>2 <a href="https://www.luogu.org/problemnew/show/P1308" target="_blank" rel="noopener">洛谷P1308 统计单词数</a></p></li></ul><p>思路点拨：运用$find$函数实现</p><ul><li>3 <a href="https://www.luogu.org/problemnew/show/P1079" target="_blank" rel="noopener">洛谷P1079 Vigenère 密码</a></li></ul><p>思路点拨：按照题意模拟即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-What’s-string&quot;&gt;&lt;a href=&quot;#1-What’s-string&quot; class=&quot;headerlink&quot; title=&quot;1.What’s string&quot;&gt;&lt;/a&gt;1.What’s string&lt;/h2&gt;&lt;p&gt;$string$ 是一种$STL$的
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="学习笔记" scheme="http://zyx02.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="字符串" scheme="http://zyx02.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>题解 P5269 【欧稳欧再次学车】</title>
    <link href="http://zyx02.github.io/2019/03/23/%E9%A2%98%E8%A7%A3-P5269-%E3%80%90%E6%AC%A7%E7%A8%B3%E6%AC%A7%E5%86%8D%E6%AC%A1%E5%AD%A6%E8%BD%A6%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/03/23/题解-P5269-【欧稳欧再次学车】/</id>
    <published>2019-03-23T11:29:21.000Z</published>
    <updated>2019-06-25T14:25:59.254Z</updated>
    
    <content type="html"><![CDATA[<p><del>三年OI一场空，不开long long 见祖宗</del></p><p>一道模拟题，具体解释在代码里：</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t,n,l,r,x,k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dang,zhuan;<span class="comment">//一定要开long long !!!</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//freopen("1.out","w",stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d"</span>,&amp;t,&amp;n,&amp;l,&amp;r,&amp;x,&amp;k);</span><br><span class="line">    zhuan=l;<span class="comment">//zhuan存放转速</span></span><br><span class="line">    dang=<span class="number">1</span>;<span class="comment">//dang存放档位</span></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> xx,yy;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;xx,&amp;yy);</span><br><span class="line">    <span class="keyword">if</span>(xx==<span class="number">0</span>)<span class="comment">//升档</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(dang==n) <span class="comment">//如果dang已经到达了n，那么是非法序列</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    dang++;</span><br><span class="line">    zhuan=l;<span class="comment">//转速调整为l</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(xx==<span class="number">1</span>)<span class="comment">//降档</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dang==<span class="number">1</span>) <span class="comment">//如果dang是1，那么是非法序列</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dang--;</span><br><span class="line">zhuan=r;<span class="comment">//转速调整为r</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(yy==<span class="number">1</span>)<span class="comment">//踩油门</span></span><br><span class="line">&#123;</span><br><span class="line">zhuan+=x;<span class="comment">//转速加上x</span></span><br><span class="line"><span class="keyword">if</span>(zhuan&gt;r) zhuan=r;<span class="comment">//对r取min</span></span><br><span class="line">&#125;</span><br><span class="line">ans+=zhuan*dang <span class="comment">//一定要在发动机有没有爆炸前加</span></span><br><span class="line"><span class="keyword">if</span>(zhuan==r)</span><br><span class="line">&#123;</span><br><span class="line">flag++;</span><br><span class="line"><span class="keyword">if</span>(flag==k)<span class="comment">//爆炸</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;del&gt;三年OI一场空，不开long long 见祖宗&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;一道模拟题，具体解释在代码里：&lt;/p&gt;
&lt;h3 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;headerlink&quot; title=&quot;Code&quot;&gt;&lt;/a&gt;Code&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="http://zyx02.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>题解CF96A【Football】</title>
    <link href="http://zyx02.github.io/2019/03/19/%E9%A2%98%E8%A7%A3CF96A%E3%80%90Football%E3%80%91/"/>
    <id>http://zyx02.github.io/2019/03/19/题解CF96A【Football】/</id>
    <published>2019-03-19T15:35:10.000Z</published>
    <updated>2019-06-25T14:24:59.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一道字符串模拟，直接暴力枚举即可"><a href="#一道字符串模拟，直接暴力枚举即可" class="headerlink" title="一道字符串模拟，直接暴力枚举即可"></a>一道字符串模拟，直接暴力枚举即可</h3><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = s[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span> ; j &lt; s.size(); j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[j] != c)<span class="comment">//不一样直接退出</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans == <span class="number">7</span>)<span class="comment">//有七个一样的输出YES</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"NO"</span>);<span class="comment">//不危险输出NO</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一道字符串模拟，直接暴力枚举即可&quot;&gt;&lt;a href=&quot;#一道字符串模拟，直接暴力枚举即可&quot; class=&quot;headerlink&quot; title=&quot;一道字符串模拟，直接暴力枚举即可&quot;&gt;&lt;/a&gt;一道字符串模拟，直接暴力枚举即可&lt;/h3&gt;&lt;h2 id=&quot;Code&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/tags/C/"/>
    
      <category term="字符串" scheme="http://zyx02.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="http://zyx02.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/tags/CodeForces/"/>
    
  </entry>
  
</feed>
