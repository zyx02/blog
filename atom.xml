<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WKAHPM的博客</title>
  
  <subtitle>「深藏不露是一种卓越的才能」</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://zyx02.github.io/blog/"/>
  <updated>2019-12-28T16:11:21.410Z</updated>
  <id>http://zyx02.github.io/blog/</id>
  
  <author>
    <name>WKAHPM</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019CSP-J游记</title>
    <link href="http://zyx02.github.io/blog/2019/12/13/2019CSP-J%E6%B8%B8%E8%AE%B0/"/>
    <id>http://zyx02.github.io/blog/2019/12/13/2019CSP-J游记/</id>
    <published>2019-12-13T15:11:47.000Z</published>
    <updated>2019-12-28T16:11:21.410Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Day-6"><a href="#Day-6" class="headerlink" title="$Day-6$"></a>$Day-6$</h3><p>听说今年不能去福州<del>玩狼人杀</del>比赛了，在本市考，有点难受</p><p>机房颓颓颓，日常被神仙们虐</p><h3 id="Day-5"><a href="#Day-5" class="headerlink" title="$Day-5$"></a>$Day-5$</h3><p>下午去东海一中参加模拟赛（密码是怀念NOIP），$t1t2$有点太水了，秒切。$t3t4$拿暴力分滚粗。</p><p>考场出来听一堆人讨论$t3t4$正解，心里慌得一匹。才发现$t3$正解就是在暴力（差分）的基础上加上一个离散化。。。我$dzm$了，$t4$正解线段树+$dp$?什么神仙操作。。。</p><p>最后$100+100+50+70=320$自闭了/kk</p><h3 id="Day-4-Day-1"><a href="#Day-4-Day-1" class="headerlink" title="$Day-4$~$Day-1$"></a>$Day-4$~$Day-1$</h3><p>日常改题，颓废，被神仙们吊打，不用上文化课的感觉真好。</p><p>这几天晚上都在公安局吃饭，没想到<del>牢饭</del>公安局的饭还是挺好吃的。</p><p>吃完饭在小七的操场散散步，才发现小七竟有如此美丽的景色。傍晚的微风吹拂在脸颊上，望着操场上挥洒汗水的跑步者，与周围的好友开几个玩笑，一天的疲惫也随之而去。</p><p><del><strong>以上均为想象</strong></del></p><p>吃完饭偶尔去嘲讽一下还在上课的同学，<del>真是快乐</del>。</p><h3 id="Day0"><a href="#Day0" class="headerlink" title="$Day0$"></a>$Day0$</h3><p>明天就是$CSP$了，按照以往的惯例都会由初三大佬来给我这种蒟蒻分享心得，但是今年由于某些不可抗力因素比如<del>wxn</del>，导致初三参赛人数较少。所以今年就由我们这届来分享心得</p><p>传送门:<a href="https://www.luogu.com.cn/blog/Computer2020/qian-tan-manacher-suan-fa-zai-oi-zhong-di-ying-yong-by-wkahpm" target="_blank" rel="noopener">蒟蒻的总结报告</a> | <a href="https://zyx02.github.io/blog/2019/11/15/%E6%B5%85%E8%B0%88Manacher%E7%AE%97%E6%B3%95%E5%9C%A8OI%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-CSP%E8%B5%9B%E5%89%8D%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94by-WKAHPM/#more">在hexo博客上查看</a></p><p>讲的好紧张啊，感觉是讲的最烂的一个了/kk。</p><h3 id="Day1"><a href="#Day1" class="headerlink" title="$Day1$"></a>$Day1$</h3><p>今天就是$CSP$了！</p><p>早上起来打了道<a href="https://www.luogu.com.cn/problem/P3952" target="_blank" rel="noopener">大模拟</a>，感觉良好（<del>然后下午就爆零了</del>）</p><p>来到一中，日常膜神仙。</p><p>进考场，打开一看——一脸懵逼</p><p>感觉$t1$越来越水了，秒切。到$9012$是不是$t1$出个输出$Hello,world!$?</p><p>$t2$第一眼看跟海港貌似有点类似，于是开始打队列。结果发现审错题意了，推到重来，这次用了个手工队。一直怕时间复杂度是$O(N^2)$结果想想发现其实是$O(45N)$的。。。害我担心了这么久。</p><p>手打队列完，小数据都过了，到了大数据，答案不一样？！内心直接崩掉。</p><p>于是开始乱搞，吧手工队换成$stl$就过了？$stl$好啊！</p><p>有了去年的经验，今年先开$t4$，考场发现了一个奇偶性质但是不知道怎么用，难受。只能拿$40$部分分滚粗。</p><p>$t3$一脸懵逼，$10$分特判滚粗。</p><p>预估$100+100+10+40=250$自闭了/kk</p><p>出考场后发现$t3t4$都是原题？？？（$CCF$是懒得出题了）</p><p>$t3$是多次的完全背包，$t4$是根据奇偶性广搜，当场自闭。</p><h3 id="Few-Days-Later"><a href="#Few-Days-Later" class="headerlink" title="$Few$ $Days$ $Later$"></a>$Few$ $Days$ $Later$</h3><p>在各个$OJ$上自测了,基本上都是在$250-260$之间，看来$250$实锤了。</p><h3 id="Day-N"><a href="#Day-N" class="headerlink" title="$Day N$"></a>$Day N$</h3><p>出成绩了，果然$100+100+10+40=250$，自闭/kk</p><p>分数线是$210$，终于拿了一次<del>省一</del>了(虽然现在好像叫评级？）</p><p>希望明年能取得更好的成绩吧</p><p>$the$ $end.$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Day-6&quot;&gt;&lt;a href=&quot;#Day-6&quot; class=&quot;headerlink&quot; title=&quot;$Day-6$&quot;&gt;&lt;/a&gt;$Day-6$&lt;/h3&gt;&lt;p&gt;听说今年不能去福州&lt;del&gt;玩狼人杀&lt;/del&gt;比赛了，在本市考，有点难受&lt;/p&gt;
&lt;p&gt;机房颓颓颓，日常被
      
    
    </summary>
    
    
      <category term="游记" scheme="http://zyx02.github.io/blog/tags/%E6%B8%B8%E8%AE%B0/"/>
    
      <category term="CSP" scheme="http://zyx02.github.io/blog/tags/CSP/"/>
    
  </entry>
  
  <entry>
    <title>题解 P3115 【[USACO15JAN]牛路线Cow Routing】</title>
    <link href="http://zyx02.github.io/blog/2019/12/11/%E9%A2%98%E8%A7%A3-P3115-%E3%80%90-USACO15JAN-%E7%89%9B%E8%B7%AF%E7%BA%BFCow-Routing%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/12/11/题解-P3115-【-USACO15JAN-牛路线Cow-Routing】/</id>
    <published>2019-12-11T14:10:37.000Z</published>
    <updated>2019-12-11T14:12:18.143Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="-1.前置知识"></a>-1.前置知识</h4><p>最短路，图论</p><h4 id="0-大体思路"><a href="#0-大体思路" class="headerlink" title="0.大体思路"></a>0.大体思路</h4><p>对每条航线进行<strong>建边</strong>处理，同时记录两个城市之间的城市数(这里题目中的经过多少城市指从$u$到$v$<strong>不包括首/尾</strong>的城市数)，然后跑$Dijkstra$即可</p><h4 id="1-建边"><a href="#1-建边" class="headerlink" title="1.建边"></a>1.建边</h4><p>本题由于边数较多，采用邻接矩阵存图较为合适。</p><p>定义$cost[i][j]$表示从$i$到$j$的最少费用，$to[i][j]$表示<strong>在费用最少的情况下</strong>从$i$到$j$所经过的最少城市数</p><p>假设一条航线的费用是$money$,有$len$个城市，对应的编号分别为$x_{1},x_{2},···,x_{len}$</p><p>首先要明确一个常识性问题：在一条航线上，一个城市<strong>不能飞到它之前的城市</strong></p><p>所以我们可以得到一个显然的建边方法，对于一条航线的$x_{i}$，向$x_{j}(i&lt;j&lt;=len)$建一条长度为$money$的边。需要注意的是，如果之前$cost[i][j]$已赋值，则</p><ul><li><p>如果$money&lt;cost[i][j]$，需要更新$cost[i][j],to[i][j]$</p></li><li><p>如果$money=cost[i][j]$，则如果$i$到$j$之间的城市数$&lt;to[i][j]$，更新$to[i][j]$</p></li></ul><p>这样就可以满足<strong>在花费最少的情况下</strong>经过的城市数最少</p><h4 id="2-Dijkstra"><a href="#2-Dijkstra" class="headerlink" title="2.Dijkstra"></a>2.Dijkstra</h4><p>定义$c[i]$为起点到$i$的最少花费，$ans[i]$为起点到$i$之间经过的城市数</p><p>假设当前从城市$k$开始拓展。</p><p>如果$k$与某个城市$i$有连边$cost[k][i]$，我们可以类比之前建边的方法进行更新。</p><ul><li><p>如果$c[k]+cost[k][i]&lt;c[i]$，更新$c[i],ans[i]$</p></li><li><p>如果$c[k]+cost[k][i]=c[i]$，如果$ans[k]+to[k][i]&lt;ans[i]$，更新$ans[i]$</p></li></ul><p>其中$ans[i]$的更新是指$ans[i]=ans[k]+to[k][i]$</p><p>根据定义，$ans[i]$表示起点到$i$的城市数，$ans[k]$表示起点到$k$的城市数，$to[k][i]$表示$k$到$i$之间的城市数，所以很明显有$ans[i]=ans[k]+to[k][i]$</p><h4 id="3-Code"><a href="#3-Code" class="headerlink" title="3.Code"></a>3.Code</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span><span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c = getchar();</span><br><span class="line">        <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">                c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                sum = (sum &lt;&lt; <span class="number">1</span>) + (sum &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">                c = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a, b, n, len, maxn;</span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">1010</span>][<span class="number">1010</span>], x[<span class="number">10010</span>], to[<span class="number">1010</span>][<span class="number">1010</span>], money, ans[<span class="number">1010</span>];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> c[<span class="number">1010</span>];<span class="comment">//别忘了开long long</span></span><br><span class="line">priority_queue&lt;pair &lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span><span class="comment">//堆优化Dij</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++) c[i] = LONG_LONG_MAX;</span><br><span class="line">        c[a] = <span class="number">0</span>;</span><br><span class="line">        q.push(make_pair(<span class="number">0</span>, a));</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">int</span> k = q.top().second;</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(vis[k]) <span class="keyword">continue</span>;</span><br><span class="line">                vis[k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= maxn; i++)</span><br><span class="line">                        <span class="keyword">if</span>(cost[k][i] != <span class="number">1e9</span> + <span class="number">10</span>)<span class="comment">//有连边</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">if</span>(c[i] &gt; c[k] + cost[k][i])</span><br><span class="line">                                &#123;</span><br><span class="line">                                        c[i] = c[k] + cost[k][i];</span><br><span class="line">                                        ans[i] = ans[k] + to[k][i];</span><br><span class="line">                                        q.push(make_pair(-c[i], i));</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(c[i] == c[k] + cost[k][i])</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                <span class="keyword">if</span>(ans[i] &gt; ans[k] + to[k][i]) ans[i] = ans[k] + to[k][i];</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">1010</span>; j++)</span><br><span class="line">                        cost[i][j] = <span class="number">1e9</span> + <span class="number">10</span>;<span class="comment">//赋初值</span></span><br><span class="line">        <span class="built_in">memset</span>(to, <span class="number">127</span>, <span class="keyword">sizeof</span>(to));<span class="comment">//赋初值</span></span><br><span class="line">        a = read(), b = read(), n = read();</span><br><span class="line">        <span class="comment">//建边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                money = read(), len = read();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)</span><br><span class="line">                        x[j] = read(), maxn = max(maxn, x[j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt;= len; k++)</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">if</span>(cost[x[j]][x[k]] &gt; money)</span><br><span class="line">                                        cost[x[j]][x[k]] = money, to[x[j]][x[k]] = k - j;<span class="comment">//k-j就是j到k之间的城市数（不包含首尾）</span></span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                <span class="keyword">if</span>(cost[x[j]][x[k]] == money)</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(k - j &lt; to[x[j]][x[k]])</span><br><span class="line">                                        &#123;</span><br><span class="line">                                                to[x[j]][x[k]] = k - j;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Dijkstra();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(c[b] != LONG_LONG_MAX)<span class="comment">//判断是否能到达</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld %d"</span>, c[b], ans[b]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1 -1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-前置知识&quot;&gt;&lt;a href=&quot;#1-前置知识&quot; class=&quot;headerlink&quot; title=&quot;-1.前置知识&quot;&gt;&lt;/a&gt;-1.前置知识&lt;/h4&gt;&lt;p&gt;最短路，图论&lt;/p&gt;
&lt;h4 id=&quot;0-大体思路&quot;&gt;&lt;a href=&quot;#0-大体思路&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="http://zyx02.github.io/blog/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://zyx02.github.io/blog/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Manacher算法在OI中的应用&amp;CSP赛前总结——by WKAHPM</title>
    <link href="http://zyx02.github.io/blog/2019/11/15/%E6%B5%85%E8%B0%88Manacher%E7%AE%97%E6%B3%95%E5%9C%A8OI%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8-CSP%E8%B5%9B%E5%89%8D%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94by-WKAHPM/"/>
    <id>http://zyx02.github.io/blog/2019/11/15/浅谈Manacher算法在OI中的应用-CSP赛前总结——by-WKAHPM/</id>
    <published>2019-11-15T13:47:40.000Z</published>
    <updated>2019-11-20T12:09:47.578Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-什么是Manacher"><a href="#0-什么是Manacher" class="headerlink" title="0.什么是Manacher"></a>0.什么是Manacher</h4><blockquote><p>Manachar算法主要是处理字符串中关于回文串的问题的，它可以在 O（n） 的时间处理出以字符串中每一个字符为中心的回文串半径——摘自百度百科</p></blockquote><h4 id="1-从暴力谈起"><a href="#1-从暴力谈起" class="headerlink" title="1.从暴力谈起"></a>1.从暴力谈起</h4><p>先看一道例题<a href="https://www.luogu.org/problem/P3805" target="_blank" rel="noopener">洛谷P3805</a></p><p>题意十分简单明了，求一个字符串$S$中的最大回文子串长度</p><p>很容易想到一种$O(N^3)$算法，枚举子串的左边界$l$右边界$r$,判断该子串是否回文即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; len; l ++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> r = l; r &lt; len; r ++)</span><br><span class="line">    <span class="keyword">if</span>(check(l , r)) ans = max(ans , r - l + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在此算法上加入<del>亿</del>一点简单优化可以优化到$O(N^2)$,<strong>对于长度为奇数的回文字符串，回文子串的中心一定是某个字符，对于长度为偶数的回文字符串，回文子串的中心一定是两个字符之间的空隙</strong>，一种显然的作法是枚举这些回文中心，向两边拓展直到字符不相等或到达边界</p><p>由于$WKAHPM$比较懒,所以就不贴代码了。</p><p>暴力的缺点：</p><ul><li>1.需要分类讨论</li><li>2.枚举了很多没用的子串</li></ul><p>这时候我们就需要再加入<del>亿</del>一点优化。</p><h4 id="2-Manacher的初始化"><a href="#2-Manacher的初始化" class="headerlink" title="2.Manacher的初始化"></a>2.Manacher的初始化</h4><blockquote><p>暴力的缺点——需要分类讨论</p></blockquote><p>如何解决这个问题？一种作法是在每个字符之间再加入一个分隔字符（<strong>当然这个字符不能存在在原本的字符串中</strong>），举个栗子,比如字符串$ababac$：</p><div class="table-container"><table><thead><tr><th></th><th>a</th><th></th><th>b</th><th></th><th>a</th><th></th><th>b</th><th></th><th>a</th><th></th><th>c</th><th></th></tr></thead><tbody><tr><td>#</td><td>a</td><td>#</td><td>b</td><td>#</td><td>a</td><td>#</td><td>b</td><td>#</td><td>a</td><td>#</td><td>c</td><td>#</td></tr></tbody></table></div><p>这个方法有效地避免了分类讨论，容易发现我们插入了$N+1$个#号，字符串的长度变为$2N+1$，为奇数，<del>是不是很神奇呢</del></p><p>为了防止越界情况，我们在开头和结尾再加入一个字符，比如$@$，这部分的代码可以这么写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">news</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s_new += <span class="string">"@#"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">s_new += s[i];</span><br><span class="line">s_new += <span class="string">'#'</span>; </span><br><span class="line">&#125;</span><br><span class="line">s_new += <span class="string">'@'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Manacher的原理"><a href="#3-Manacher的原理" class="headerlink" title="3.Manacher的原理"></a>3.Manacher的原理</h4><p> 定义$p[i]$表示以$i$为对称中心能扩展的<strong>最大回文子串半径</strong>，即左/右边界到对称中心的距离。</p><p>$Manacher$的算法思想就是快速求出$p$数组。</p><p>我们来看看$p$数组与答案的关系(这里省略@)</p><div class="table-container"><table><thead><tr><th>s</th><th>#</th><th>a</th><th>#</th><th>b</th><th>#</th><th>a</th><th>#</th><th>b</th><th>#</th><th>a</th><th>#</th><th>c</th><th>#</th></tr></thead><tbody><tr><td><strong>ans</strong></td><td>0</td><td>1</td><td>0</td><td>3</td><td>0</td><td>5</td><td>0</td><td>3</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td><strong>p</strong></td><td>1</td><td>2</td><td>1</td><td>4</td><td>1</td><td>6</td><td>1</td><td>4</td><td>1</td><td>2</td><td>1</td><td>2</td><td>1</td></tr></tbody></table></div><p>显然有$ans[i]=p[i]-1$</p><p>证明：</p><p>设回文子串$s$原来的长度为$len$，对称中心为$i$；</p><p>则$s$插入字符后的长度变为$2\times len+1$；</p><p>此时$p[i]=(2\times len+1+1)/2=len+1$,所以$p[i]-1$即为答案</p><p>所以求出$p[i]$就可以求出答案</p><h4 id="4-Manacher的实现"><a href="#4-Manacher的实现" class="headerlink" title="4.Manacher的实现"></a>4.Manacher的实现</h4><p>$Manacher$的实现用到了回文子串的一个性质——对称性</p><p>利用该性质可以有效地避免重复枚举，通过之前枚举过的子串来确定这个点<strong>至少</strong>能扩展的长度</p><p>设$mr$为之前找到的回文子串的最右边，$mid$为该回文子串的对称中心。</p><p>假设当前枚举到第$i$位，因为枚举过$mid$了，所以显然有$i&gt;mid$，接下来需要分类讨论两种情况来快速求出$p[i]$：</p><p>为了方便讨论，设$j$为$i$以$mid$为对称中心的对称点，$s_{i}$是以$i$为对称中心的回文子串，$s_{j}$是以$j$为对称中心的回文子串</p><h5 id="1-i-lt-mr"><a href="#1-i-lt-mr" class="headerlink" title="(1)i &lt; mr"></a>(1)i &lt; mr</h5><p>这时候我们又能分2种情况</p><ul><li>1 $s_{i}$的右边界<strong>不大于</strong>$mr$</li></ul><p>如图</p><p><img src="https://i.loli.net/2019/11/15/fROsdocQh2aIuX8.png" alt="TIM截图20191115112913.png"></p><p>由对称性知，此时$p[i]=p[j]$</p><ul><li>2 $s_{i}$的右边界<strong>大于</strong>$mr$</li></ul><p>如图</p><p><img src="https://i.loli.net/2019/11/15/aoX7wxyB9RrE4md.png" alt="TIM截图20191115132136.png"></p><p>这时我们只能<strong>确定α段是具有对称性的</strong>，此时$p[i]=mr-i$</p><p>也就是说，当$i$在$mr$左边，那么$p[i]$肯定是$mr-i$与$p[j]$的<strong>最小值</strong>。因为$j$与$i$关于$mid$对称，所以在$[i,mr]$这一段内可以<strong>直接使用$p[j]$的值</strong>，但是$i$已知的回文串长度<strong>不能到$mr$后面去</strong>，所以跟$mr-i$取$min$。</p><h5 id="2-i-gt-mr"><a href="#2-i-gt-mr" class="headerlink" title="(2) i &gt;= mr"></a>(2) i &gt;= mr</h5><p>此时我们无法通过对称性得到$p[i]$，所以$p[i]=1$</p><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Manacher</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s_new.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;mx)<span class="comment">//情况1</span></span><br><span class="line">  ans[i]=min(ans[<span class="number">2</span>*id-i],mx-i);</span><br><span class="line"><span class="keyword">else</span><span class="comment">//情况2</span></span><br><span class="line">  ans[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(s_new[i-ans[i]]==s_new[i+ans[i]]) ans[i]++;<span class="comment">//扩展</span></span><br><span class="line"><span class="keyword">if</span>(mx&lt;i+ans[i])<span class="comment">//更新右边界</span></span><br><span class="line">&#123;</span><br><span class="line">id=i;</span><br><span class="line">mx=i+ans[i];</span><br><span class="line">&#125;</span><br><span class="line">maxn=max(maxn,ans[i]<span class="number">-1</span>);<span class="comment">//更新答案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h4><p><a href="https://www.luogu.org/problem/P5018" target="_blank" rel="noopener">洛谷P5018对称二叉树</a></p><p>这题可以用$Manacher$来解决。</p><p>可以先用中序遍历对每个节点编号，利用$a$和$size$数组存放每个节点的权值和以这个节点为根节点的二叉树的节点数，对每个数组进行$Manacher$，将先后两次的以第$i$个点为对称中心的最大回文子串半径存放在$p1[i],p2[i]$中。</p><p>另外本题不需要初始化，$Manacher$初始化的原因是可能存在偶数长度的回文子串，但在对称二叉树中不可能存在偶数长度的回文子串，因为在对称二叉树中，除根节点以外每一个左儿子都有一个右儿子与之对应，所以节点数为奇数个。</p><p>求出$p1,p2$后，枚举编号$1$~$N$，判断以$i$为根节点的二叉树是否为对称二叉树，如果是则对$ans$和$size[i]$取$max$，对称二叉树需要满足两个条件：</p><ul><li><p>1 权值对称</p></li><li><p>2 结构对称</p></li></ul><p>体现在程序中就是$p1[i] \times 2 - 1 &gt;= size[i]$并且$p2[i] \times 2 - 1 == size[i]$</p><p>首先解释一下为什么是$p1[i] \times 2 - 1$而不是$p1[i]-1$</p><p>$p1[i] \times 2 - 1$是因为之前的$Manacher$我们没有进行初始化，所以此时的$p1[i]$要乘2</p><p>接着解释一下为什么是$p1[i] \times 2 - 1 &gt;= size[i]$</p><p>如图</p><p><img src="https://i.loli.net/2019/11/15/myUHdKNTeh6Ltbr.png" alt="TIM截图20191115154337.png"></p><p>如果写成$p1[i] \times 2 - 1 == size[i]$的话，则对于编号为$5$的节点，$p1[5] \ times 2 - 1 =5$,而$size[5]=3$，所以当节点权值相等时，可能出现$p1[i] \times 2 - 1 &gt; size[i]$的情况。</p><h4 id="6-结语"><a href="#6-结语" class="headerlink" title="6.结语"></a>6.结语</h4><p>明天就是$CSP$了，大家调整好心态，多背背模板，基本上$t1t2$过了$t3t4$打一下暴力就省一了，祝各位$RP++$(<del>这不是毒奶</del>)</p><p>愿<img src="https://i.loli.net/2019/11/15/2ucSPiy8Qrl3WHz.png" alt="TIM截图20191115171839.png">降临到你身边</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-什么是Manacher&quot;&gt;&lt;a href=&quot;#0-什么是Manacher&quot; class=&quot;headerlink&quot; title=&quot;0.什么是Manacher&quot;&gt;&lt;/a&gt;0.什么是Manacher&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Manachar算法主要是
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://zyx02.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Manacher" scheme="http://zyx02.github.io/blog/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>浅谈OI中的骗分技巧——by WKAHPM</title>
    <link href="http://zyx02.github.io/blog/2019/10/21/%E6%B5%85%E8%B0%88OI%E4%B8%AD%E7%9A%84%E9%AA%97%E5%88%86%E2%80%94%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94by-WKAHPM/"/>
    <id>http://zyx02.github.io/blog/2019/10/21/浅谈OI中的骗分—技巧——by-WKAHPM/</id>
    <published>2019-10-21T14:23:26.000Z</published>
    <updated>2019-11-01T10:01:21.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0.写在前面"></a>0.写在前面</h2><p>在<del>NOIP</del>$CSP$的考场上，很多题目我们在考场上往往无法想到正解（<del>当然大佬除外</del>）。这时候我们就需要一些骗分技巧来为自己争取一些部分分。</p><h2 id="1-骗分的意义"><a href="#1-骗分的意义" class="headerlink" title="1.骗分的意义"></a>1.骗分的意义</h2><p>首先我们要了解什么是子任务。</p><p>对于一道题，它可能存在多个子任务。这些子任务的数据往往具有某些特点或者在某个小范围内，骗分的意义就是在打不出正解的情况下拿到这些子任务的分数。</p><p>例如$2018NOIP$ $T2$中的<a href="https://www.luogu.org/problem/P5016" target="_blank" rel="noopener">龙虎斗</a>，它的子任务分布是这样的</p><p>【数据规模与约定】</p><p>$1 &lt; m &lt; n,1 ≤ p1 ≤ n.$</p><p>对于$20$%的数据,$n = 3, m = 2, ci = 1, s1,s2 ≤ 100$.</p><p>另有$20$%的数据,$n ≤ 10, p1 = m, ci = 1, s1,s2 ≤ 100$.</p><p>对于$20$%的数据,$n = 3, m = 2, ci = 1,s1,s2 ≤ 100$.</p><p>对于$60$%的数据,$n ≤ 100, ci = 1,s1,s2 ≤ 100$.</p><p>对于$80$%的数据,$n ≤ 100, ci,s1,s2 ≤ 100$.</p><p>对于$100$%的数据,$n ≤ 10^5, ci = 1, s1,s2 ≤ 10^9$.</p><p>观察可以发现,$80$%的数据都很小，这时候我们就可以用暴力来拿到这$80$分。</p><h2 id="2-基础的骗分"><a href="#2-基础的骗分" class="headerlink" title="2.基础的骗分"></a>2.基础的骗分</h2><h4 id="1-输样例"><a href="#1-输样例" class="headerlink" title="1.输样例"></a>1.输样例</h4><p>一道题目都会给你输入输出样例，如果你想不出其他解决该问题的方法，可以尝试直接输出样例，这就是考验你$rp$的时候了</p><p>例题：$2018NOIP$ $T4$<a href="https://www.luogu.org/problem/P5018" target="_blank" rel="noopener">对称二叉树</a></p><p>输出第二个样例即$3$可以拿到32分</p><p>没错就是这段代码可以为你拿到32分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen("tree.in", "r", stdin);</span></span><br><span class="line">    <span class="comment">//freopen("tree.out", "w" ,stdout);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一道题目包含无解的情况时，也可以通过输出无解来获得部分分</p><h4 id="2-输出随机数"><a href="#2-输出随机数" class="headerlink" title="2.输出随机数"></a>2.输出随机数</h4><p>这个也是考验$rp$的，根据数据范围输出随机数。</p><p>随机数生成代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand(time(<span class="number">0</span>)); <span class="comment">//随机种子</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span> , rand()%b + a) <span class="comment">//输出一个范围在a~a+b-1的随机数 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是随机数的生成范围在不同操作系统下是不一样的，在Windows下是$0$~$32767$</p><p>由于篇幅限制，基础的骗分技巧不再赘述。</p><h2 id="3-高级骗分技巧"><a href="#3-高级骗分技巧" class="headerlink" title="3.高级骗分技巧"></a>3.高级骗分技巧</h2><h4 id="1-打表"><a href="#1-打表" class="headerlink" title="1.打表"></a>1.打表</h4><p>很多人可能认为打表是最基础的骗分技巧，但是打表也是有艺术的。</p><p>打表的用处很多，例如</p><ul><li><p>1 减小时间复杂度</p></li><li><p>2 找规律</p></li><li><p>3 ······</p></li></ul><p>先说说如何减小时间复杂度。</p><p>当一些题目数据范围很小时，我们可以考虑通过打表使程序运行效率提高，例如$2008NOIP$ $T3$<a href="https://www.luogu.org/problem/P1057" target="_blank" rel="noopener">传球游戏</a></p><p>这是我$90$分的程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">31</span>][<span class="number">31</span>],n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> f[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> f[x][y]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> f[x][y]=dfs(x<span class="number">-1</span>,y<span class="number">-1</span>)+dfs(<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> f[x][y]=dfs(n,y<span class="number">-1</span>)+dfs(x+<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> f[x][y]=dfs(x<span class="number">-1</span>,y<span class="number">-1</span>)+dfs(x+<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dfs(<span class="number">1</span>,m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个程序会被$10$ $29$这个数据给卡超时</p><p>这个时候加入打表就可以完美$AC$这道题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">31</span>][<span class="number">31</span>],n,m;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[x][y]) <span class="keyword">return</span> f[x][y];</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span> f[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> f[x][y]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x==n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> f[x][y]=dfs(x<span class="number">-1</span>,y<span class="number">-1</span>)+dfs(<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">return</span> f[x][y]=dfs(n,y<span class="number">-1</span>)+dfs(x+<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> f[x][y]=dfs(x<span class="number">-1</span>,y<span class="number">-1</span>)+dfs(x+<span class="number">1</span>,y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">10</span>&amp;&amp;m==<span class="number">29</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dfs(<span class="number">1</span>,m));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序比上一段程序多出来的部分就是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n==<span class="number">10</span>&amp;&amp;m==<span class="number">29</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于一些对素数判断存在要求的题目，我们可以预处理出素数表，减少判断的时间。</p><p>大致是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> num)</span> <span class="comment">//快速判断素数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == <span class="number">2</span> || num == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; num % <span class="number">6</span> != <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i*i &lt;= num; i += <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (num % i == <span class="number">0</span> || num % (i+<span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">                              </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   freopen(<span class="string">"prime.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);<span class="comment">//将表输出到文件里，方便复制</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">      <span class="keyword">if</span>(prime(i)) <span class="built_in">cout</span> &lt;&lt; <span class="string">"i,"</span><span class="comment">//加入逗号方便复制</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候将prime.out里的数字复制到表里就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Prime[LEN]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,···&#125;</span><br></pre></td></tr></table></figure><p>再来说说找规律。</p><p>对于一些题目，我们可以输出一些小数据的答案，观察答案与输入数据的关系，这种方法一般适用于数论题。</p><p>如$1999NOIP$ $T1$? <a href="https://www.luogu.org/problem/P1014" target="_blank" rel="noopener">Cantor表</a></p><p>可以通过行列和答案的关系找出某种规律。</p><p>打表的方式千变万化，所以有着”打表出省一”之说（笑），当然也不能过分依赖打表，造成思维惰性。</p><p><img src="https://i.loli.net/2019/11/01/325E1a4NVZvBecM.jpg" alt="你的NOIP.png"></p><h4 id="2-dfs"><a href="#2-dfs" class="headerlink" title="2.dfs"></a>2.dfs</h4><p>如果你熟练掌握了$dfs$（深度优先搜索），你会发现“万物皆可搜”。</p><p>当一个题目打不出来怎么办？先打个$dfs$，可能这不是最优解，但是$dfs$思路清晰，码量小，可以拿到部分分。而且有时它也可以便于你想出正解。动态规划的思想有部分就来自于搜索。</p><p>例如$2018NOIP$ $T4$<a href="https://www.luogu.org/problem/P5018" target="_blank" rel="noopener">对称二叉树</a></p><p>如果你熟练掌握了二叉树的知识，你会很容易写出一个$dfs$，而$dfs$就是这道题目的正解。。。</p><p>所以万物皆可搜 万物皆可搜 万物皆可搜</p><h4 id="3-灵活运用子任务的数据范围或数据特点"><a href="#3-灵活运用子任务的数据范围或数据特点" class="headerlink" title="3.灵活运用子任务的数据范围或数据特点"></a>3.灵活运用子任务的数据范围或数据特点</h4><p>数据范围往往不是无意义的，它存在的意义就是卡掉某些错解。</p><p>先上张图</p><p><img src="https://i.loli.net/2019/10/21/ipIwRUbVNxaZl6J.jpg" alt="时间复杂度.png"></p><p>数据范围对选择算法非常重要，算法的选择将会决定你是否能做出这道题。</p><p>根据子任务的数据范围，我们可以通过它来选择不同子任务用的算法。</p><p>如开头提到的龙虎斗，对于$80$分的数据$n&lt;=100$,用$O(n^2)$的算法是肯定不会超时的。所以可以这么写代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">   ····<span class="comment">//暴力代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n &gt; <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ····<span class="comment">//瞎搞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如$2018NOIP$ $T3$<a href="https://www.luogu.org/problem/P5017" target="_blank" rel="noopener">摆渡车</a></p><p>对于$10$%的数据，满足$m=1$</p><p>这时意味着每个人的等待时间都为0，所以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以拿到10分</p><h2 id="4-对拍"><a href="#4-对拍" class="headerlink" title="4.对拍"></a>4.对拍</h2><p>在你写出骗分程序后，如果你所有题目都做完了且检验后，这时你就可以返回之前通过骗分做的题目，想一些正解。</p><p>还是以龙虎斗为例，在你打出一个可以满足$100$%数据范围的时间复杂度的程序后，你想检验它的正确性，这时候运用对拍可以十分方便地检验。</p><p>对拍模板：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:loop</span><br><span class="line">shuju.exe</span><br><span class="line">baoli.exe</span><br><span class="line">shiyan.exe</span><br><span class="line">fc fan.out fan1.out</span><br><span class="line">if %errorlevel%==0 goto loop</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>新建一个.txt文件，将上面的代码复制进去。再将后缀名改为.bat，文件名任意。</p><p>其中shuju.exe是你出数据的程序，shiyan.exe是你想的“正解”，baoli.exe是你打的暴力程序。</p><p>fan.out和fan1.out分别是你baoli和shiyan的输出文件。</p><p>这些东西需要放在同一个文件夹里，然后双击这个文件名.bat就可以开始愉快的对拍了。</p><h2 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h2><h4 id="1-最大连续和"><a href="#1-最大连续和" class="headerlink" title="1.最大连续和"></a>1.<a href="https://www.luogu.org/problem/U92940" target="_blank" rel="noopener">最大连续和</a></h4><p>首先看到$10$%的数据所有数都是正数，这是只要把所有数加起来就是结果。</p><p>对于$30$%的数据，我们很容易可以写出一个暴力。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ans = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j ++)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k ++)&#123;</span><br><span class="line">  sum += a[k];</span><br><span class="line">  &#125;</span><br><span class="line">ans = max(ans , sum);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对于$50$%的数据，在$30$%的程序基础上加入前缀和优化。</p><p>对于$80$%的数据，可以考虑进行二分（数据过水，在洛谷上被水过去了）</p><p>对于$100$%的数据，定义$dp[i]$为$1$~$i$的最大连续和。</p><p>对于$a[i]$，明显有两种选择，一种是取之前的最大连续和，一种是不取之前的最大连续和，以这个数为开头。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(a[i] , dp[i - <span class="number">1</span>] + a[i]);</span><br></pre></td></tr></table></figure><h4 id="2-2017NOIP-T4-跳房子"><a href="#2-2017NOIP-T4-跳房子" class="headerlink" title="2.$2017NOIP$ $T4$ 跳房子"></a>2.$2017NOIP$ $T4$ <a href="https://www.luogu.org/problem/P3957" target="_blank" rel="noopener">跳房子</a></h4><p>首先观察题目，发现题目中存在无解的情况，所以可以先加入特判是否存在答案。判断条件就是所有格子的最大和未超过$k$的话，输出无解。</p><p>接下来观察数据范围，发现$1,2$组数据$n$的范围较小，可以考虑$dfs$(见题目目录下1.cpp)</p><p>可以在该程序的基础上加上二分进行优化(见题目目录下2.cpp)</p><p>继续观察数据范围，发现前$5$组数据$n&lt;=500$，可以考虑用朴素$dp$求解</p><p>定义$dp[pos]$为从起点到$pos$格能获得的最大分数，</p><p>不难发现$dp[pos]$可以由某个格$i$跳$j$步到达</p><p>所以有方程$dp[pos]=max(dp[pos],dp[i]+s[i+j])$</p><p>其中$0&lt;=i&lt;n,left&lt;=j&lt;=right,pos = i + j$，$left,right$分别是能跳的步数的左边界和右边界。时间复杂度$O(n^2)$（见题目目录下3.cpp）</p><p>这样本题就可以拿到$50$分了</p><p>如果想拿到满分需要加入单调队列优化$dp$，这里不再赘述（<del>其实是我不会</del>）</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>骗分是种艺术，在考场上灵活运用骗分技巧可以为你争取部分分。但是这并不意味着你不用去思考这道题目的正解，要知道思考正解远比想尽办法骗分更有意义。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0.写在前面&quot;&gt;&lt;/a&gt;0.写在前面&lt;/h2&gt;&lt;p&gt;在&lt;del&gt;NOIP&lt;/del&gt;$CSP$的考场上，很多题目我们在考场上往往无法想到正解（&lt;del&gt;当然大佬
      
    
    </summary>
    
    
      <category term="CSP" scheme="http://zyx02.github.io/blog/tags/CSP/"/>
    
      <category term="骗分" scheme="http://zyx02.github.io/blog/tags/%E9%AA%97%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>电脑如何进入pixiv</title>
    <link href="http://zyx02.github.io/blog/2019/10/10/%E7%94%B5%E8%84%91%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5pixiv/"/>
    <id>http://zyx02.github.io/blog/2019/10/10/电脑如何进入pixiv/</id>
    <published>2019-10-10T14:56:14.000Z</published>
    <updated>2019-10-10T14:56:56.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Pixiv，是一个主要由日本艺术家所组成的虚拟社群，主体为由pixiv股份制有限公司所运营的为插画艺术特化的社交网络服务网站。新兴的日本同人画、插画作品分享站点。采用了web2.0的方式，每个参与者都有自己的主页并可以对作品评价打分。——百度百科</p></blockquote><p>当你想进入$pixiv$时，你可能遇到这种情况</p><p><img src="https://i.loli.net/2019/10/10/AL5MwHr6vVpbI7q.png" alt></p><p>一开始是进不去$pixiv$的（除非你挂了$VPN$）</p><h2 id="Step0-准备工作"><a href="#Step0-准备工作" class="headerlink" title="Step0.准备工作"></a>Step0.准备工作</h2><ul><li>pixiv-nginx</li></ul><p><a href="https://pan.baidu.com/s/1xIjFWHykeKDzKZzoDzVPBA?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=" target="_blank" rel="noopener">链接</a> 提取码：apz7</p><h2 id="Step1-解压文件"><a href="#Step1-解压文件" class="headerlink" title="Step1.解压文件"></a>Step1.解压文件</h2><p>将压缩包解压，把文件夹放在C盘</p><p><img src="https://i.loli.net/2019/10/10/PlJG5FxpS8BEsfg.png" alt="TIM截图20191010222508.png"></p><h2 id="Step2-安装证书"><a href="#Step2-安装证书" class="headerlink" title="Step2.安装证书"></a>Step2.安装证书</h2><p>打开pixiv-nginx-1.15.3，双击ca.cer<br><img src="https://i.loli.net/2019/10/10/MfNo1QAjd5rmneE.png" alt="TIM截图20191010222657.png"></p><p>点击安装证书</p><p><img src="https://i.loli.net/2019/10/10/hqV34tZ8oyz6Rg2.png" alt="TIM截图20191010222739.png"></p><p>存储位置选择当前用户</p><p><img src="https://i.loli.net/2019/10/10/TYOxFQUetXucWCV.png" alt="TIM截图20191010223300.png"></p><p>选择将所有的证书都放入下列储存</p><p><img src="https://i.loli.net/2019/10/10/VUBqtgz5GRkKSfT.png" alt="TIM截图20191010222900.png"></p><p>选择受信任的根证书颁发机构</p><p><img src="https://i.loli.net/2019/10/10/pcBEF49kQxDagot.png" alt="TIM截图20191010222957.png"></p><p>然后点击完成即可</p><h2 id="Step3-修改hosts"><a href="#Step3-修改hosts" class="headerlink" title="Step3.修改hosts"></a>Step3.修改hosts</h2><p>复制pixiv-nginx-1.15.3内的hosts到C:\Windows\System32\drivers\etc内替换原hosts</p><p><img src="https://i.loli.net/2019/10/10/8qrwT79cpmdtVHB.png" alt="TIM截图20191010223515.png"></p><h3 id="Step4-开启Nginx"><a href="#Step4-开启Nginx" class="headerlink" title="Step4.开启Nginx"></a>Step4.开启Nginx</h3><p>到pixiv-nginx-1.15.3,打开4.可视化工具（这个操作简单）</p><p><img src="https://i.loli.net/2019/10/10/FBwm6IP9zS4r8nu.png" alt="TIM截图20191010223649.png"></p><p>打开后是如下界面</p><p><img src="https://i.loli.net/2019/10/10/W8UqdkNDHLZJhvi.png" alt="TIM截图20191010223721.png"></p><p>点Nginx后面的Start，看到打钩出现即为成功</p><p><img src="https://i.loli.net/2019/10/10/yE1fgPzx3U5LXYQ.png" alt="TIM截图20191010223803.png"></p><p>接下来就可以打开pixiv了！</p><p><img src="https://i.loli.net/2019/10/10/SYxDM157C4pGNou.png" alt="TIM截图20191010224316.png"></p><p>每次上pixiv都要打开nginx，如果觉得麻烦可以运行pixiv-nginx-1.15.3下的nginx添加开机启动.bat</p><h3 id="答疑：无法打开Nginx怎么办"><a href="#答疑：无法打开Nginx怎么办" class="headerlink" title="答疑：无法打开Nginx怎么办"></a>答疑：无法打开Nginx怎么办</h3><ul><li><p>1 确保你上面的步骤都正确</p></li><li><p>2 打开pixiv-nginx-1.15.3下的logs文件夹，打开error.log，复制里面的错误信息到度娘。</p></li></ul><p>如果你的错误日志里的信息是类似</p><blockquote><p>2019/10/02 09:06:17 [emerg] 6244#12448: bind() to 127.0.0.1:443 failed (10013: An attempt was made to access a socket in a way forbidden by its access permissions)</p></blockquote><p>这样的，那么这个错误信息是指你的端口被占用了。占用的端口是443（看第一行127.0.0.1:443）</p><p><a href="https://blog.csdn.net/bad_yixiong/article/details/70267140" target="_blank" rel="noopener">端口占用解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Pixiv，是一个主要由日本艺术家所组成的虚拟社群，主体为由pixiv股份制有限公司所运营的为插画艺术特化的社交网络服务网站。新兴的日本同人画、插画作品分享站点。采用了web2.0的方式，每个参与者都有自己的主页并可以对作品评价打分。——百度百科&lt;
      
    
    </summary>
    
    
      <category term="工具" scheme="http://zyx02.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>题解 P1578【奶牛浴场】</title>
    <link href="http://zyx02.github.io/blog/2019/10/08/%E9%A2%98%E8%A7%A3-P1578%E3%80%90%E5%A5%B6%E7%89%9B%E6%B5%B4%E5%9C%BA%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/10/08/题解-P1578【奶牛浴场】/</id>
    <published>2019-10-08T15:12:20.000Z</published>
    <updated>2019-10-08T15:13:55.100Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-问题类型"><a href="#0-问题类型" class="headerlink" title="0.问题类型"></a>0.问题类型</h3><p>这是一道经典的最大子矩形问题，本人的思路参考了国家队wzk大佬的论文《浅谈用极大化思想解决最大子矩形问题》</p><p>这篇论文介绍了两种求最大子矩形的思路，分别是通过障碍点找子矩形和通过悬线找子矩形，本题的数据范围适合使用第一种方法</p><h3 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1.算法思路"></a>1.算法思路</h3><p>定义极大子矩形为$4$条边都不能向外拓展的有效子矩形（这里的有效即子矩形内不包括障碍点)。</p><p>可以得到最大子矩形是所有极大子矩形中最大的，所以只要枚举最大的子矩形，求出其中最大的即可</p><h3 id="2-算法实现"><a href="#2-算法实现" class="headerlink" title="2.算法实现"></a>2.算法实现</h3><p>怎么找极大子矩形？根据极大子矩形的定义，我们可以得出极大子矩形的$4$条边一定覆盖障碍点（或边界）</p><p>为了方便讨论，我们先将整个牛场的4个顶点设为障碍点。</p><p>例如</p><p>10 10</p><p>4</p><p>1 1</p><p>3 4 </p><p>6 3</p><p>9 8</p><h3 id="1-从左往右搜"><a href="#1-从左往右搜" class="headerlink" title="1.从左往右搜"></a>1.从左往右搜</h3><p>将障碍点按横坐标排序（左右顺序）后得到如下编号。</p><p>(作者画画不是那么好qwq)</p><p><img src="https://i.loli.net/2019/10/08/MTs4woRkLn2DqP3.png" alt="TIM截图20191008223603.png"></p><p>一开始从$1$号障碍点开始，从左往右找极大子矩形。</p><p>一开始的极大子矩形上下边界$up,low$为整个牛场的上下边界</p><p>$1$号障碍点往右找，到$2$号障碍点，如图</p><p><img src="https://i.loli.net/2019/10/08/3KxzmUQvLoM8keN.png" alt="1.png"></p><p>可以得到一个极大子矩形，它的面积就是障碍点$2$的横坐标减去障碍点$1$的横坐标乘以上边界减去下边界。</p><p>接下来需要对上下边界做一些修改，否则之后的极大子矩形可能会包括障碍点。因为$2$的纵坐标大于$1$的纵坐标，所以修改上边界，修改为$2$的纵坐标。</p><p>接下来到$3$，同理可以得到如下极大子矩形</p><p><img src="https://i.loli.net/2019/10/08/yLZbSluAH1JU3aw.png" alt="2.png"></p><p>它的面积就是$3$的横坐标减去$1$的横坐标乘以上边界（$2$的纵坐标）减去下边界</p><p>之后的$4$也同理。</p><p>然后从$2$开始往右找，从$3$开始往右找,从$4$开始往右找，跟从$1$开始找都是一样的。</p><h3 id="2-从右往左搜"><a href="#2-从右往左搜" class="headerlink" title="2.从右往左搜"></a>2.从右往左搜</h3><p>从左往右搜后我们会发现有一些遗漏的情况，就是极大子矩形的左边界是牛场的左边界，右边界覆盖一个障碍点的情况，如图</p><p><img src="https://i.loli.net/2019/10/08/CIW8PVt9zjrKyOX.png" alt="3.png"></p><p>解决方法很简单，把从左往右搜倒过来从右往左搜一遍即可</p><h3 id="3-特殊情况"><a href="#3-特殊情况" class="headerlink" title="3.特殊情况"></a>3.特殊情况</h3><p>在从左往右搜和从右往左搜后我们发现还有一种情况没有考虑到，就是极大子矩形的左右边界分别是牛场的左右边界，如图</p><p><img src="https://i.loli.net/2019/10/08/OxDvByJqsWYUiTw.png" alt="4.png"></p><p>解决方法是，再将障碍点按纵坐标排序，如图</p><p><img src="https://i.loli.net/2019/10/08/i8UIqVrj5BEhCFT.png" alt="5.png"></p><p>可以得到这类极大子矩形的面积就是相邻两个障碍点（按纵坐标排序后）纵坐标之差乘以牛场的长</p><p>时间复杂度$O(N^2)$，$N$为障碍点数</p><h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span><span class="comment">//快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span> , f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = getchar();</span><br><span class="line"><span class="keyword">while</span>(c &lt; <span class="string">'0'</span> <span class="keyword">or</span> c &gt; <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> <span class="keyword">and</span> c &lt;= <span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = (sum &lt;&lt; <span class="number">1</span>) + (sum &lt;&lt; <span class="number">3</span>) + c - <span class="string">'0'</span>;</span><br><span class="line">c = getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span><span class="comment">//存放障碍点信息</span></span><br><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line">&#125;s[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(S a , S b)</span><span class="comment">//按横坐标排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.x != b.x) <span class="keyword">return</span> a.x &lt; b.x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.y &lt; b.y; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(S a , S b)</span><span class="comment">//按纵坐标排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.y != b.y) <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.x &lt; b.x ; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l , w , n , ans; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l = read() , w = read() , n = read();   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) s[i].x = read() , s[i].y = read();</span><br><span class="line">    s[++ n].x = <span class="number">0</span> , s[n].y = <span class="number">0</span>;<span class="comment">//将四个顶点设为障碍点</span></span><br><span class="line">s[++ n].x = <span class="number">0</span> , s[n].y = w;</span><br><span class="line">s[++ n].x = l , s[n].y = <span class="number">0</span>;</span><br><span class="line">s[++ n].x = l , s[n].y = w;</span><br><span class="line">    <span class="keyword">int</span> x1 , x2 , y1 , y2;<span class="comment">//x1为左边界，x2为右边界,y1为下边界，y2为上边界</span></span><br><span class="line">    <span class="comment">//从左往右搜</span></span><br><span class="line">    sort(s + <span class="number">1</span> , s + n + <span class="number">1</span> , cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">    x1 = s[i].x , y1 = <span class="number">0</span> , y2 = w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">    &#123;</span><br><span class="line">x2 = s[j].x;</span><br><span class="line">ans = max(ans , (x2 - x1) * (y2 - y1));</span><br><span class="line">    <span class="keyword">if</span>(s[j].y &lt; s[i].y) y1 = max(y1 , s[j].y);<span class="comment">//更新上下边界</span></span><br><span class="line">        <span class="keyword">else</span> y2 = min(y2 , s[j].y); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//从右往左搜  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">    x1 = s[i].x , y1 = <span class="number">0</span> , y2 = w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line">    &#123;</span><br><span class="line">    x2 = s[j].x;</span><br><span class="line">ans = max(ans , (x1 - x2) * (y2 - y1));</span><br><span class="line"><span class="keyword">if</span>(s[j].y &lt; s[i].y) y1 = max(y1 , s[j].y);</span><br><span class="line">        <span class="keyword">else</span> y2 = min(y2 , s[j].y); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理特殊情况</span></span><br><span class="line">sort(s + <span class="number">1</span> , s + n + <span class="number">1</span> , cmp2); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line">ans = max(ans , l * (s[i + <span class="number">1</span>].y - s[i].y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span> , ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-问题类型&quot;&gt;&lt;a href=&quot;#0-问题类型&quot; class=&quot;headerlink&quot; title=&quot;0.问题类型&quot;&gt;&lt;/a&gt;0.问题类型&lt;/h3&gt;&lt;p&gt;这是一道经典的最大子矩形问题，本人的思路参考了国家队wzk大佬的论文《浅谈用极大化思想解决最大子矩形问题》&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="动态规划（dp）" scheme="http://zyx02.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89/"/>
    
      <category term="最大子矩形" scheme="http://zyx02.github.io/blog/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E5%BD%A2/"/>
    
  </entry>
  
  <entry>
    <title>倍增LCA学习笔记</title>
    <link href="http://zyx02.github.io/blog/2019/10/06/%E5%80%8D%E5%A2%9ELCA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyx02.github.io/blog/2019/10/06/倍增LCA学习笔记/</id>
    <published>2019-10-05T17:22:52.000Z</published>
    <updated>2019-12-11T11:59:49.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是LCA"><a href="#1-什么是LCA" class="headerlink" title="1.什么是LCA"></a>1.什么是LCA</h2><blockquote><p>LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。——百度百科</p></blockquote><p>这么说可能不直观，我们通过一张图来理解一下</p><p><img src="https://i.loli.net/2019/10/06/vJHnpk1oi2VPAqE.jpg" alt="64380cd7912397dd751c23bb5082b2b7d0a2872c.jpg"></p><p>（图片来源百度百科）</p><p>在这棵树中，点$3$和点$6$的最近公共祖先是$2$，因为3的祖先是{1,2}，6的祖先是{4,2,1}。它们的公共祖先是{2,1}，而其中深度最大的是$2$</p><h2 id="2-怎么求LCA"><a href="#2-怎么求LCA" class="headerlink" title="2.怎么求LCA"></a>2.怎么求LCA</h2><h3 id="1-朴素算法"><a href="#1-朴素算法" class="headerlink" title="1.朴素算法"></a>1.朴素算法</h3><p>了解了$LCA$的定义，不难得出一种暴力算法，即对于$u,v$两个点，我们让它们不断地一步一步往上跳，直到第一次相遇。</p><p>算法时间复杂度：$O(N)$</p><h3 id="2-倍增算法"><a href="#2-倍增算法" class="headerlink" title="2.倍增算法"></a>2.倍增算法</h3><p>既然一步一步跳太慢，我们可以考虑设计一种倍增算法，让它一次跳$2^{0},2^{1},···.2^{n}$次方步。</p><h4 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h4><p>定义$fa[i][j]$为第$i$个点跳$2^{j}$步后达到的点，$deep[i]$为第$i$个点的深度。</p><h4 id="1-建树，计算深度，预处理-fa-i-0"><a href="#1-建树，计算深度，预处理-fa-i-0" class="headerlink" title="1.建树，计算深度，预处理$fa[i][0]$"></a>1.建树，计算深度，预处理$fa[i][0]$</h4><p>这一部分可以用$dfs$实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t , <span class="keyword">int</span> father)</span> <span class="comment">//t表示当前点编号，father表示它的父亲结点编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deep[t] = deep[father] + <span class="number">1</span>;<span class="comment">//深度是父亲深度+1</span></span><br><span class="line">fa[t][<span class="number">0</span>] = father;<span class="comment">//t跳一步正好到father</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[t]; i ; i = edge[i].Next)<span class="comment">//链式前向星</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to != father)<span class="comment">//避免出现死循环</span></span><br><span class="line">  dfs(edge[i].to , t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-预处理-fa-i-j"><a href="#2-预处理-fa-i-j" class="headerlink" title="2.预处理$fa[i][j]$"></a>2.预处理$fa[i][j]$</h4><p>因为$2^{j}=2^{j-1}+2^{j-1}$，所以我们可以得到转移方程</p><p>$fa[i][j]=fa[fa[i][j-1]][j-1]$</p><p>即先跳$2^{j-1}$到达$fa[i][j-1]$,再跳$2^{j-1}$步到达$fa[fa[i][j-1][j-1]]$</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)<span class="comment">//为了保险开到2^20，一般超过2^20的数据都会超时了</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-求-LCA"><a href="#3-求-LCA" class="headerlink" title="3.求$LCA$"></a>3.求$LCA$</h4><p>假设求$x,y$的$LCA$</p><p>为了方便讨论，假设$deep[x]&gt;deep[y]$，即$x$的深度大于$y$的深度</p><p>先让$x$跳到与$y$同一深度，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i];<span class="comment">//只要x还比y深，就跳，否则不跳</span></span><br></pre></td></tr></table></figure><p>如果这时候如果$x$已经等于$y$了，直接输出即可。</p><p>到达同一深度后，我们开始让$x,y$一起跳，注意这里我们要跳到的是它们$LCA$的下一层（因为我们跳到的是满足$x$和$y$不相等的最浅的一层，而它们的上层即为$LCA$）。</p><p>还是看最开始的例子，$3,6$,调整至同一高度后为$3,4$，，循环过后$x$和$y$的值并没有改变，因为我们跳到的是$LCA$的下一层。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) </span><br><span class="line">   <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i] , y = fa[y][i];<span class="comment">//如果它们跳2^i后不相等，那么肯定不是LCA的上面，所以跳</span></span><br></pre></td></tr></table></figure><p>最后的答案就是$f[x][0]$了</p><p>完整代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n , m , s , cnt;</span><br><span class="line"><span class="keyword">int</span> deep[<span class="number">500100</span>];</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">500010</span>][<span class="number">31</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">G</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to , Next;</span><br><span class="line">&#125;edge[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">500010</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> from , <span class="keyword">int</span> to)</span><span class="comment">//建边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++ cnt].Next = head[from];</span><br><span class="line">edge[cnt].to = to;</span><br><span class="line">head[from] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> t , <span class="keyword">int</span> father)</span><span class="comment">//预处理深度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deep[t] = deep[father] + <span class="number">1</span>;</span><br><span class="line">fa[t][<span class="number">0</span>] = father;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[t]; i ; i = edge[i].Next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].to != father)</span><br><span class="line">  dfs(edge[i].to , t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prework</span><span class="params">()</span><span class="comment">//预处理fa数组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line">fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x , <span class="keyword">int</span> y)</span><span class="comment">//求LCA</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(deep[x] &lt; deep[y]) swap(x , y);<span class="comment">//令x的深度大于y的深度</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i];<span class="comment">//让x,y跳到同一深度</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i --) <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i] , y = fa[y][i];<span class="comment">//让x,y一起跳</span></span><br><span class="line">     <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x; </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span> , &amp;n , &amp;m , &amp;s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x , y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;x , &amp;y);</span><br><span class="line">add(y , x);</span><br><span class="line">add(x , y);</span><br><span class="line">&#125;</span><br><span class="line">dfs(s , <span class="number">0</span>);</span><br><span class="line">prework();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> a , b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span> , &amp;a , &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span> , query(a , b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>时间复杂度$O(logn)$</p><h3 id="4-一些思考"><a href="#4-一些思考" class="headerlink" title="4.一些思考"></a>4.一些思考</h3><p>为什么求LCA中$j$要从大到小枚举。</p><p>这个和天平称重时从大到小放砝码有点类似，举个例子，比如跳9步，如果按从小到大枚举是$1+2+4+8$,而$9 \ne1+2+4+8$,还需要回去重新找，而从大到小的话直接求出$9=8+1$</p><h3 id="5-例题"><a href="#5-例题" class="headerlink" title="5.例题"></a>5.例题</h3><p><a href="https://www.luogu.org/problem/P3379" target="_blank" rel="noopener">P3379 【模板】最近公共祖先（LCA）</a></p><p><a href="http://noip.qz1z.com:2000/contest/45/problem/1" target="_blank" rel="noopener">泉州市信息技术基地校OJ 密室逃脱</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是LCA&quot;&gt;&lt;a href=&quot;#1-什么是LCA&quot; class=&quot;headerlink&quot; title=&quot;1.什么是LCA&quot;&gt;&lt;/a&gt;1.什么是LCA&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;LCA（Least Common Ancestors），即最近公共
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="学习笔记" scheme="http://zyx02.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="倍增" scheme="http://zyx02.github.io/blog/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="LCA,最近公共祖先" scheme="http://zyx02.github.io/blog/tags/LCA-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
    
  </entry>
  
  <entry>
    <title>康托展开学习笔记</title>
    <link href="http://zyx02.github.io/blog/2019/09/29/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyx02.github.io/blog/2019/09/29/康托展开学习笔记/</id>
    <published>2019-09-29T15:41:01.000Z</published>
    <updated>2019-10-05T17:23:54.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是康托展开"><a href="#1-什么是康托展开" class="headerlink" title="1.什么是康托展开"></a>1.什么是康托展开</h2><blockquote><p>康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。——摘自百度百科</p></blockquote><p>简单来说，康托展开就是对于任意一个全排列，求一个自然数与它对应，即一个全排列到一个自然数的映射，这种映射是唯一的。</p><h2 id="2-怎么实现康托展开"><a href="#2-怎么实现康托展开" class="headerlink" title="2.怎么实现康托展开"></a>2.怎么实现康托展开</h2><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>$ X=\sum_{i=1}^n a_{i}(i-1)! $</p><p>其中，$a_{i}$代表在这个排列中的第$i$个数后面有多少个数比它小。</p><p>这个公式求的是当前排列前面有多少个排列</p><p>例如，对于排列$14325$，它的康托展开是</p><p>$X=0\times(5-1)!+2\times(4-1)!+1\times(3-1)!+0\times(2-1)!+0\times(1-1)!=0+12+2+0+0=14$</p><p>所以$14325$前面还有$14$个排列，所以$14325$是第$14+1=15$个排列</p><h4 id="本蒟蒻对于这个公式的一些浅显理解"><a href="#本蒟蒻对于这个公式的一些浅显理解" class="headerlink" title="本蒟蒻对于这个公式的一些浅显理解:"></a>本蒟蒻对于这个公式的一些浅显理解:</h4><p>假设有一个排列$a_{1},a_{2},···,a_{n}$</p><p>如果其满足$a_{1} &lt; a_{2}&lt;···&lt; a_{n}$,那么它是第一个排列。所以答案为$1$，计算公式之后不难发现公式正确</p><p>如果$a_{2},a_{3},···,a_{n}$中有比$a_{1}$小的数，以这些数为开头的排列必定在$a_{1}$为开头的排列前面，所以要加上这些排列数。确定了开头了之后，其后面还有$(n-1)$个数，可以构成$(n-1)!$种序列，所以公式第一项为比$a_{1}$小的数的个数乘以$(n-1)!$</p><p>以此类推，可以得到该序列的排位。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">int</span> a[N] , n , Min[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">(<span class="keyword">int</span> n)</span><span class="comment">//预处理阶乘</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">  sum[i] = i * sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos)</span><span class="comment">//预处理ai</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = pos + <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  <span class="keyword">if</span>(a[i] &lt; a[pos]) Min[pos] ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cantor</span><span class="params">()</span><span class="comment">//康托展开</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  ans += Min[i] * sum[n - i];</span><br><span class="line"><span class="keyword">return</span> ans; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">   fc(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) get(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span> , cantor() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-逆康托展开"><a href="#3-逆康托展开" class="headerlink" title="3.逆康托展开"></a>3.逆康托展开</h3><p>知道了如何给定排列求序号，因为排列与序号一一对应，所以自然可以用序号求排列。</p><p>逆康托展开其实就是把康托展开反向计算。</p><p>假设字典序号为$pos$，共有$n$个数</p><p>首先用$pos\div(n-1)!$，余数自然就是$\sum_{i=2}^n a_{i}(n-i)! $,商就是 $a_{1}$</p><p>如此反复，可求得$a_{1},a_{2},···,a_{n}$</p><p>例如：给定$pos=15,n=5$，所以有$pos-1=14$个比它小的序列</p><p>$14\div(5-1)!=0······14,a_{1}=0$</p><p>$14\div(4-1)!=2······2,a_{2}=2$</p><p>$2\div(3-1)!=1······0,a_{3}=1$</p><p>$0\div(2-1)!=0······0,a_{4}=0$</p><p>$0\div(1-1)!=0,a_{5}=0$</p><p>接下来，在$1,2,3,4,5$中，有$0$个比它小的数的数是$1$，所以第一位为$1$</p><p>在$2,3,4,5$中，有$2$个比它小的数的数是$4$，所以第二位为$4$</p><p>在$2,3,5$中，有$1$个比它小的数的数是$3$，所以第三位为$3$</p><p>在$2,5$中，有$0$个比它小的数的数是$2$,所以第四位为$2$</p><p>第五位为$5$</p><p>综上，原序列为$14325$</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"><span class="keyword">int</span> a[N] , n , pos , Min[N];</span><br><span class="line"><span class="keyword">bool</span> use[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">  sum[i] = i * sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recantor</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">Min[n - i] = pos / sum[i] , pos = pos % sum[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(! use[j])</span><br><span class="line">  s ++;</span><br><span class="line"><span class="keyword">if</span>(s == Min[n - i] + <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> a[n - i] = j;</span><br><span class="line"> use[j] = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; pos;</span><br><span class="line">    fc(n);</span><br><span class="line">recantor(pos - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-例题"><a href="#4-例题" class="headerlink" title="4.例题"></a>4.例题</h4><p><a href="https://www.luogu.org/problem/P3014" target="_blank" rel="noopener">P3014[USACO11FEB]牛线Cow Line</a></p><p><a href="https://www.luogu.org/problem/P5367" target="_blank" rel="noopener">P5367【模板】康托展开</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是康托展开&quot;&gt;&lt;a href=&quot;#1-什么是康托展开&quot; class=&quot;headerlink&quot; title=&quot;1.什么是康托展开&quot;&gt;&lt;/a&gt;1.什么是康托展开&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="学习笔记" scheme="http://zyx02.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="康托展开" scheme="http://zyx02.github.io/blog/tags/%E5%BA%B7%E6%89%98%E5%B1%95%E5%BC%80/"/>
    
      <category term="组合数" scheme="http://zyx02.github.io/blog/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>广州中山纪念中学游记</title>
    <link href="http://zyx02.github.io/blog/2019/07/14/%E5%B9%BF%E5%B7%9E%E4%B8%AD%E5%B1%B1%E7%BA%AA%E5%BF%B5%E4%B8%AD%E5%AD%A6%E6%B8%B8%E8%AE%B0/"/>
    <id>http://zyx02.github.io/blog/2019/07/14/广州中山纪念中学游记/</id>
    <published>2019-07-14T15:51:44.000Z</published>
    <updated>2019-07-15T10:31:46.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="$Day 1$"></a>$Day 1$</h2><p>坐动车，去学校。<del>顺便去腾讯公司上了个厕所</del></p><p>（<del>这学校比我们学校大多了啊！！</del>）</p><p>本来还想吃完晚饭<del>颓狼人杀</del>的，结果莫名其妙跟着老师去看机房，然后讲注意事项，OJ网址，接着莫名其妙地打了一晚上的题（<del>我还要打狼人杀啊！</del>）</p><h2 id="Day-2"><a href="#Day-2" class="headerlink" title="$Day 2$"></a>$Day 2$</h2><p>早上打模拟赛，被神仙们虐爆了，$100+80+30+60=270rk12$，我好菜啊$QwQ$</p><p>第一题简单暴力模拟，第二题本来想暴力拆字符串结果爆空间了，还好拿了$80$，第三题写了一个自以为正确的贪心<del>结果WAWA大哭了</del>，第四题数位dp只能拿$60$暴力分（出题人良心！）了。</p><p>顺便膜一下我校大佬$lmk$，$100+100+100+70=370rk1$太强了！吊打我！</p><p>然后讲题，改题。</p><p>顺便讲了一下数位dp，学完之后当晚肝了一题<a href="https://www.luogu.org/problemnew/show/P2657" target="_blank" rel="noopener">windy数</a>，感觉良好</p><h2 id="Day-3"><a href="#Day-3" class="headerlink" title="$Day 3$"></a>$Day 3$</h2><p>还是模拟赛，继续被神仙们狂虐，$50+20+0+20=90rk5$，太菜了吧$qwq$</p><p>第一题被讲题人誉为本次比赛中最难的一题(<del>那为什么还要放在第一题啊</del>)，主要原因是题目很难理解(<del>可以当阅读理解了吧（雾）</del>)，但不知道为什么我暴搜骗了50，第二题讲题人言简意赅地点出了核心思想——<del>乱搞</del>，第三题是道dp但完全看不出来，第四题旁边的$gy$一直跟我说不是最小生成树，不是最小生成树，结果正解就是最小生成树+虚点连边。。。。。。</p><p>再次膜拜我校大佬$lmk$,$10+90+0+100=200rk1$魔鬼！</p><p>最后发现第三题要用压位高精，不然会爆空间，不得不感叹一下出题人的<del>毒瘤</del></p><h2 id="Day-4"><a href="#Day-4" class="headerlink" title="$Day 4$"></a>$Day 4$</h2><p>今天没有模拟赛，<del>甚好</del>，去听了一早上的dp，然后下午一直在肝dp</p><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="$Day 5$"></a>$Day 5$</h2><p>又是模拟赛，继续划水，$100+85+10+10=205rk12$菜死了。</p><p>第一题签到题简单模拟，第二题毒瘤数据制造者居然让dfs爆栈了，换成bfs才过，第三题数学题，可惜没看出答案是卡特兰数，而且还要加上高精，最后一题dp打了个暴搜水分。。。</p><p>话说某位老师居然参加了这场比赛而且居然没有AK（笑）</p><p>膜拜我校大佬$xzx$,$100+100+0+100=300rk2$（$rk1$老师）太可怕了。</p><h2 id="Day-6"><a href="#Day-6" class="headerlink" title="$Day 6$"></a>$Day 6$</h2><p>一场异常简单的模拟赛，一堆神仙AK，然而我第一题爆零因为没特判换行符….，该死的OJ，该死的Linux。。。</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="$Day7$"></a>$Day7$</h2><p>没有打比赛而是去听了一下堆，下午找了几题练练，感觉良好。。。</p><p>（priority_queue大法好啊）</p><h2 id="Day8"><a href="#Day8" class="headerlink" title="$Day8$"></a>$Day8$</h2><p>又是被神仙们虐的一天，$100+0+37.5+12.5=150rk5$(<del>希望这是我数学期末考的分数</del>)</p><p>第一题数论，数据范围$O(\sqrt{n})$明显会TLE但竟然让我水过了！第二题二维离散化，又是什么神仙算法。。。第三题Floyd+匈牙利算法，第四题玄学算法（我也不知道我后面是怎么改对的）</p><h2 id="Day-9"><a href="#Day-9" class="headerlink" title="$Day 9$"></a>$Day 9$</h2><p>最后的一场比赛了，然而我还是考炸了，$20+0+0+92.3=112.3rk7$。</p><p>第一题还是恶心数论，不过这次数据只让我的$O(n)$拿了20qwq，第二题听说是状压dp（但我不会呀），第三题dp以为是贪心。。。第四题二分边界设错emmm，还是太粗心了$QwQ$</p><h2 id="Day-10"><a href="#Day-10" class="headerlink" title="$Day 10$"></a>$Day 10$</h2><p>在纪中机房的最后一天了，老师为我们分享了他的OI心得，分别时还是有点不舍。</p><p>晚上放假，和大佬们一起去学校里的公园走了走，回到宿舍开始完成一直未能完成的事业——<del>狼人杀</del>，<del>我们在晚上睡觉时间后跑到别的宿舍玩狼人杀与查房的斗智斗勇超刺激的</del></p><h2 id="Day-11"><a href="#Day-11" class="headerlink" title="$Day 11$"></a>$Day 11$</h2><p>回家。</p><h2 id="the-end"><a href="#the-end" class="headerlink" title="the end."></a>the end.</h2><p>是不可能的</p><h2 id="吐槽区"><a href="#吐槽区" class="headerlink" title="吐槽区"></a>吐槽区</h2><ul><li><p><del>不知道什么时候开始一到机房大家几乎都点开了<a href="https://slay.one/" target="_blank" rel="noopener">slay.one</a>或者<a href="http://2048game.com/" target="_blank" rel="noopener">2048</a></del></p></li><li><p>纪中的食堂的饭菜挺好吃的啊（每天中午第一行第三列孜然鸡腿（只有一天在第二行第四列））</p></li><li><p>fch老师经典语录：我会很烦躁的</p></li><li><p>直到倒数第2（3？）天我们才知道食堂有夜宵，而且是烧烤！然后一下课一堆人(包括我)像sb一样冲了出去（<del>众所周知sb=smart boy</del>）</p></li><li><p>听说纪中好像还是个5A级景区？？？</p></li><li><p>舍监经典语录：你们待在纪中一天就是一天纪中人 / 有没有一点纪律观念时间观念</p></li><li><p>特意去买了一本纪中的草稿纸当纪念，<del>下学期就用它了</del></p></li><li><p>fch老师OJ上的头像</p></li></ul><p><img src="https://i.loli.net/2019/07/14/5d2b4db5e3d7f99738.jpg" alt></p><ul><li><p>一本通的编者之一宋老师竟然来给我们讲课了！而且讲的很好啊（宋老师：让学生听不懂才是一堂好课）</p></li><li><p>等我想到了再补吧······</p></li></ul><h2 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h2><p>第一次去外省培训，一次次被小学生和神仙们虐到自闭。菜死了的我深深地感受到了人外有人。被虐的同时我也学到了许多，数位dp,匈牙利算法,rmq问题,倍增求LCA······也收获了许多友谊。</p><p>在一天纪中，就做一天纪中人。有缘再见，纪中！</p><p>最后引用fch老师的一句话</p><blockquote><p>程序员之所以犯错误，不是因为他们不懂，而是因为他们自以为什么都懂。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Day-1&quot;&gt;&lt;a href=&quot;#Day-1&quot; class=&quot;headerlink&quot; title=&quot;$Day 1$&quot;&gt;&lt;/a&gt;$Day 1$&lt;/h2&gt;&lt;p&gt;坐动车，去学校。&lt;del&gt;顺便去腾讯公司上了个厕所&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;（&lt;del&gt;这学校比我们学校大
      
    
    </summary>
    
    
      <category term="游记" scheme="http://zyx02.github.io/blog/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF581B 【Luxurious Houses】</title>
    <link href="http://zyx02.github.io/blog/2019/06/24/%E9%A2%98%E8%A7%A3-CF581B-%E3%80%90Luxurious-Houses%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/06/24/题解-CF581B-【Luxurious-Houses】/</id>
    <published>2019-06-24T01:56:55.000Z</published>
    <updated>2019-06-25T14:25:15.070Z</updated>
    
    <content type="html"><![CDATA[<p>不难看出，题目要求的是每一个房子后面最高的房子与它的高度差$+1$，（如果比它矮输出$0$）</p><p>我们定义</p><ul><li><p>$maxn[i]$表示第$i$到第$n$个房子高度的最大值（$n$为房子数）</p></li><li><p>$h[i]$表示第$i$个房子的高度</p></li></ul><p>因为$maxn[i+1]$存放的已经是第$i+1$到第$n$个房子的最大值了，所以第$i$到第$n$个房子的最大值只要让当前房子的高度与$maxn[i+1]$进行比较即可</p><p>即$maxn[i]=max(h[i],maxn[i+1])$</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> h[MAXN] , maxn[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; h[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">2</span>; i --)</span><br><span class="line">   maxn[i] = max(h[i] , maxn[i + <span class="number">1</span>]); <span class="comment">//预处理最大值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i ++)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; max(maxn[i + <span class="number">1</span>] - h[i] + <span class="number">1</span> , <span class="number">0</span>) &lt;&lt; <span class="string">" "</span>;<span class="comment">//如果没比它高要输出0！</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;<span class="comment">//最后一个后面已经没有房子了当然是0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不难看出，题目要求的是每一个房子后面最高的房子与它的高度差$+1$，（如果比它矮输出$0$）&lt;/p&gt;
&lt;p&gt;我们定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$maxn[i]$表示第$i$到第$n$个房子高度的最大值（$n$为房子数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;$h[i]$
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/blog/tags/CodeForces/"/>
    
      <category term="动态规划（dp）" scheme="http://zyx02.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1152A 【Neko Finds Grapes】</title>
    <link href="http://zyx02.github.io/blog/2019/05/19/%E9%A2%98%E8%A7%A3-CF1152A-%E3%80%90Neko-Finds-Grapes%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/05/19/题解-CF1152A-【Neko-Finds-Grapes】/</id>
    <published>2019-05-19T09:03:30.000Z</published>
    <updated>2019-06-25T14:26:08.799Z</updated>
    
    <content type="html"><![CDATA[<p>题目大意：</p><p>给出两组数，求两组中的两数之和为奇数的组数（不可重复选取）</p><p>思路：</p><p>我们知道奇数+偶数=奇数</p><p>所以先统计两组中奇数出现的个数和偶数出现的个数</p><p>将第一组数中奇数出现的个数与第二组中偶数进行配对，即取$min(lenji1,lenou2)$ </p><p>再将将第一组数中偶数出现的个数与第二组中奇数进行配对，即取$min(lenou1,lenji2)$</p><p>两个结果相加即可</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> lenji1,lenji2,lenou1,lenou2;<span class="comment">//分别表示第一组数中奇数个数、第二组数中奇数个数、第一组数中偶数个数、第二组中偶数个数</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//统计</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">a%<span class="number">2</span>==<span class="number">1</span>?lenji1++:lenou1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">b%<span class="number">2</span>==<span class="number">1</span>?lenji2++:lenou2++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(lenji1,lenou2)+min(lenji2,lenou1);<span class="comment">//取min相加</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目大意：&lt;/p&gt;
&lt;p&gt;给出两组数，求两组中的两数之和为奇数的组数（不可重复选取）&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;我们知道奇数+偶数=奇数&lt;/p&gt;
&lt;p&gt;所以先统计两组中奇数出现的个数和偶数出现的个数&lt;/p&gt;
&lt;p&gt;将第一组数中奇数出现的个数与第二组中偶数进行配对，
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/blog/tags/CodeForces/"/>
    
      <category term="数论,数学" scheme="http://zyx02.github.io/blog/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF17A 【Noldbach problem】</title>
    <link href="http://zyx02.github.io/blog/2019/04/18/%E9%A2%98%E8%A7%A3-CF17A-%E3%80%90Noldbach-problem%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/04/18/题解-CF17A-【Noldbach-problem】/</id>
    <published>2019-04-18T15:26:25.000Z</published>
    <updated>2019-06-25T14:24:39.358Z</updated>
    
    <content type="html"><![CDATA[<p>题目要求的是一个素数与它相邻的素数之和$+1$为素数（注意这个素数要$\le n$）</p><p>思路：</p><ul><li><p>预处理$2$~$n$的素数</p></li><li><p>暴力枚举</p></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">1010</span>],len,n,sum,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> num)</span><span class="comment">//素数判断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">2</span> <span class="keyword">or</span> num==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num%<span class="number">6</span>!=<span class="number">5</span> <span class="keyword">and</span> num%<span class="number">6</span>!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i*i&lt;=num;i+=<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span> <span class="keyword">or</span> num%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//预处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime(i))</span><br><span class="line">          p[++len]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len;i++)<span class="comment">//枚举</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime(p[i<span class="number">-1</span>]+p[i]+<span class="number">1</span>) <span class="keyword">and</span> p[i<span class="number">-1</span>]+p[i]+<span class="number">1</span>&lt;=n)</span><br><span class="line">            sum++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(sum&gt;=k?<span class="string">"YES"</span>:<span class="string">"NO"</span>);<span class="comment">//相当于if(sum&gt;=k) cout&lt;&lt;"YES";else cout&lt;&lt;"NO";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用时：$1024ms$</p><p>我们可以在原来的程序做一些小小的优化</p><p>对枚举部分，我们加入一个边界条件</p><p>$p[i-1]+p[i] \le n$（$p[i]$为素数）</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> p[<span class="number">1010</span>],len,n,sum,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(num==<span class="number">2</span> <span class="keyword">or</span> num==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(num%<span class="number">6</span>!=<span class="number">5</span> <span class="keyword">and</span> num%<span class="number">6</span>!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i*i&lt;=num;i+=<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num%i==<span class="number">0</span> <span class="keyword">or</span> num%(i+<span class="number">2</span>)==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime(i))</span><br><span class="line">          p[++len]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=len <span class="keyword">and</span> p[i<span class="number">-1</span>]+p[i]+<span class="number">1</span>&lt;=n;i++)<span class="comment">//边界条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prime(p[i<span class="number">-1</span>]+p[i]+<span class="number">1</span>))</span><br><span class="line">            sum++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(sum&gt;=k?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用时：$994ms$ （$emmm$才快了$30ms$）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目要求的是一个素数与它相邻的素数之和$+1$为素数（注意这个素数要$\le n$）&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;预处理$2$~$n$的素数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;暴力枚举&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Code&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/blog/tags/CodeForces/"/>
    
      <category term="数论,数学" scheme="http://zyx02.github.io/blog/tags/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"/>
    
      <category term="素数" scheme="http://zyx02.github.io/blog/tags/%E7%B4%A0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1133A 【Middle of the Contest】</title>
    <link href="http://zyx02.github.io/blog/2019/04/16/%E9%A2%98%E8%A7%A3-CF1133A-%E3%80%90Middle-of-the-Contest%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/04/16/题解-CF1133A-【Middle-of-the-Contest】/</id>
    <published>2019-04-15T16:02:48.000Z</published>
    <updated>2019-06-25T14:26:11.795Z</updated>
    
    <content type="html"><![CDATA[<p>一道字符串模拟题，思路如下：</p><ul><li><p>1 输入时将两个时间存储</p></li><li><p>2 将两个时间化为以分钟做单位</p></li><li><p>3 得到中间时间与第一个时间的差</p></li><li><p>4 输出</p></li></ul><p>注意：当时间或分钟数$&lt;=9$时，要用$0$补齐位数</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2; </span><br><span class="line"><span class="keyword">int</span> h1,h2,m1,m2;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)<span class="comment">//将时间存储</span></span><br><span class="line">  h1+=(s1[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">1</span>-i),h2+=(s2[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">1</span>-i);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">  m1+=(s1[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">4</span>-i),m2+=(s2[i]-<span class="string">'0'</span>)*<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">4</span>-i);</span><br><span class="line"><span class="keyword">int</span> ans=((h2*<span class="number">60</span>+m2)-(h1*<span class="number">60</span>+m1))/<span class="number">2</span>;<span class="comment">//求得中间时间与第一个时间的差</span></span><br><span class="line">h1+=ans/<span class="number">60</span>;<span class="comment">//加上时间差</span></span><br><span class="line">m1+=ans%<span class="number">60</span>;</span><br><span class="line"><span class="keyword">if</span>(m1&gt;=<span class="number">60</span>)<span class="comment">//如果分钟&gt;=60要进位</span></span><br><span class="line">&#123;</span><br><span class="line">h1++;</span><br><span class="line">m1%=<span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(h1&lt;=<span class="number">9</span>)<span class="comment">//输出，&lt;=9的用0补齐</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;h1&lt;&lt;<span class="string">":"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;h1&lt;&lt;<span class="string">":"</span>;</span><br><span class="line">   <span class="keyword">if</span>(m1&lt;=<span class="number">9</span>)</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;m1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;m1; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道字符串模拟题，思路如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1 输入时将两个时间存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2 将两个时间化为以分钟做单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3 得到中间时间与第一个时间的差&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4 输出&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="字符串" scheme="http://zyx02.github.io/blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="http://zyx02.github.io/blog/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/blog/tags/CodeForces/"/>
    
  </entry>
  
  <entry>
    <title>一些好用的网站</title>
    <link href="http://zyx02.github.io/blog/2019/04/14/%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>http://zyx02.github.io/blog/2019/04/14/一些好用的网站/</id>
    <published>2019-04-14T08:54:10.000Z</published>
    <updated>2019-09-29T14:26:37.915Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="https://www.luogu.org/blog/IowaBattleship/latex-gong-shi-tai-quan" target="_blank" rel="noopener">Latex公式大全</a></p></li><li><p><a href="https://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">Latex在线编辑器</a></p></li><li><p><a href="https://www.desmos.com/calculator" target="_blank" rel="noopener">函数图像绘制</a></p></li><li><p><a href="https://oi-wiki.org/" target="_blank" rel="noopener">OI Wiki</a></p></li><li><p><a href="https://csacademy.com/app/graph_editor/" target="_blank" rel="noopener">图论作图工具</a></p></li><li><p><a href="http://oeis.org/" target="_blank" rel="noopener">数列查询网站</a></p></li><li><p><a href="https://zh.numberempire.com/" target="_blank" rel="noopener">数学工具</a></p></li><li><p><a href="https://yutong.site/sam/" target="_blank" rel="noopener">画SAM</a></p></li><li><p><a href="http://bigjpg.com" target="_blank" rel="noopener">放大图片</a></p></li><li><p><a href="https://visualgo.net/zh" target="_blank" rel="noopener">数据结构与算法可视化</a></p></li><li><p><a href="https://vjudge.net/" target="_blank" rel="noopener">Virtual Judge</a></p></li><li><p><a href="https://bzoj.netlify.com/" target="_blank" rel="noopener">BZOJ离线</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/blog/IowaBattleship/latex-gong-shi-tai-quan&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Latex公式大全&lt;/a&gt;&lt;/p&gt;
&lt;/l
      
    
    </summary>
    
    
      <category term="工具" scheme="http://zyx02.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1118A 【Water Buying】</title>
    <link href="http://zyx02.github.io/blog/2019/04/11/%E9%A2%98%E8%A7%A3-CF1118A-%E3%80%90Water-Buying%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/04/11/题解-CF1118A-【Water-Buying】/</id>
    <published>2019-04-11T13:43:57.000Z</published>
    <updated>2019-06-25T14:25:31.636Z</updated>
    
    <content type="html"><![CDATA[<p>题目大意：</p><p>你需要买$n$升水，现在有两种规格的水瓶：1升水的和2升水的，现给出1升水和2升水水瓶的单价，求最少需要花费多少钱。有$q$个询问。</p><p>思路：贪心</p><p>要使总花费最小，我们需要尽量多选取性价比高的规格。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n,a,b;<span class="comment">//注意要开long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a*<span class="number">2</span>&lt;=b)<span class="comment">//买1升的性价比高于买2升的性价比</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n*a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;n/<span class="number">2</span>*b+(n-n/<span class="number">2</span>*<span class="number">2</span>)*a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//题目要求的是刚好购买n升，所以不足2升的要买1升的补齐</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目大意：&lt;/p&gt;
&lt;p&gt;你需要买$n$升水，现在有两种规格的水瓶：1升水的和2升水的，现给出1升水和2升水水瓶的单价，求最少需要花费多少钱。有$q$个询问。&lt;/p&gt;
&lt;p&gt;思路：贪心&lt;/p&gt;
&lt;p&gt;要使总花费最小，我们需要尽量多选取性价比高的规格。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/blog/tags/CodeForces/"/>
    
      <category term="贪心" scheme="http://zyx02.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1092B 【Teams Forming】</title>
    <link href="http://zyx02.github.io/blog/2019/04/10/%E9%A2%98%E8%A7%A3-CF1092B-%E3%80%90Teams-Forming%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/04/10/题解-CF1092B-【Teams-Forming】/</id>
    <published>2019-04-10T14:08:21.000Z</published>
    <updated>2019-06-25T14:25:25.543Z</updated>
    
    <content type="html"><![CDATA[<p>这题的基本思想就是贪心吧</p><p>题目就是让你两两分组，使得每组能力值的差值最小</p><p>设$a_{1},a_{2},···,a_{n}$表示每个学生的能力值</p><p>且满足：$a_{1} \le a_{2} \le ··· \le a_{n}$</p><p>则对于任意一个能力值$a_{i}$，它的最优匹配为$a_{i+1}$（$i$为奇数）</p><p>考虑到$a_{1}$，我们不取$a_{i-1}$（你想想$a_{1-1}$是什么）</p><p>假设存在一个能力值$a_{k}$ ($k&gt; i+1$)，使得$a_{k}-a_{i}&lt; a_{i+1}-a_{i}$</p><p>即: $a_{k}&lt;a_{i+1}$</p><p>∵ $a_{i+1}&lt;a_{k}$</p><p>∴ 不存在这样的$k$</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>],ans; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);<span class="comment">//要先排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>) <span class="comment">//i要为奇数</span></span><br><span class="line">&#123;    </span><br><span class="line">ans+=a[i+<span class="number">1</span>]-a[i];<span class="comment">//答案加上两个能力值的差</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这题的基本思想就是贪心吧&lt;/p&gt;
&lt;p&gt;题目就是让你两两分组，使得每组能力值的差值最小&lt;/p&gt;
&lt;p&gt;设$a_{1},a_{2},···,a_{n}$表示每个学生的能力值&lt;/p&gt;
&lt;p&gt;且满足：$a_{1} \le a_{2} \le ··· \le a_{n}$&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/blog/tags/CodeForces/"/>
    
      <category term="贪心" scheme="http://zyx02.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1145F 【Neat Words】</title>
    <link href="http://zyx02.github.io/blog/2019/04/08/%E9%A2%98%E8%A7%A3-CF1145F-%E3%80%90Neat-Words%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/04/08/题解-CF1145F-【Neat-Words】/</id>
    <published>2019-04-08T13:30:27.000Z</published>
    <updated>2019-06-25T14:26:10.485Z</updated>
    
    <content type="html"><![CDATA[<p>这题其实是一道很水的字符串模拟，不要被难度骗了</p><p><del>CF恶意评分又不是一两天了（雾）</del></p><p>注意题目中说到的</p><blockquote><p>由直线或都是由曲线构成的</p></blockquote><p>是指该字母的笔画（我理解题目理解了半天$qwq$）</p><p>具体思路：</p><ul><li>1 应用$map$将由直线（或者曲线）构成的字母的映射值设为1</li></ul><ul><li>2 计算该字符串的所有对应的映射值之和，因为题目要求全为直线或全为曲线，所以当总和为$len$($len$为字符串长度)或$0$时，输出$YES$，否则输出$NO$</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">bool</span>&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">p[<span class="string">'A'</span>]=<span class="number">1</span>;<span class="comment">//打表</span></span><br><span class="line">p[<span class="string">'E'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'F'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'H'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'I'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'K'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'L'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'M'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'N'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'T'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'V'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'W'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'X'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'Y'</span>]=<span class="number">1</span>;</span><br><span class="line">p[<span class="string">'Z'</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++) sum+=p[s[i]];<span class="comment">//统计映射值之和</span></span><br><span class="line"><span class="keyword">if</span>(sum==s.size() <span class="keyword">or</span> sum==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>;<span class="comment">//判断</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这题其实是一道很水的字符串模拟，不要被难度骗了&lt;/p&gt;
&lt;p&gt;&lt;del&gt;CF恶意评分又不是一两天了（雾）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;注意题目中说到的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由直线或都是由曲线构成的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是指该字母的笔画
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="字符串" scheme="http://zyx02.github.io/blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="http://zyx02.github.io/blog/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/blog/tags/CodeForces/"/>
    
  </entry>
  
  <entry>
    <title>题解 P1794 【装备运输_NOI导刊2010提高（04）】</title>
    <link href="http://zyx02.github.io/blog/2019/04/06/%E9%A2%98%E8%A7%A3-P1794-%E3%80%90%E8%A3%85%E5%A4%87%E8%BF%90%E8%BE%93-NOI%E5%AF%BC%E5%88%8A2010%E6%8F%90%E9%AB%98%EF%BC%8804%EF%BC%89%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/04/06/题解-P1794-【装备运输-NOI导刊2010提高（04）】/</id>
    <published>2019-04-06T06:15:59.000Z</published>
    <updated>2019-06-25T14:26:01.197Z</updated>
    
    <content type="html"><![CDATA[<p>一道01背包模板题吧。。。其实就是再增加了一个体积参数</p><p>状态转移方程：</p><p>$F_{j,k}=max(F_{j-v_{i},k-g_{i}}+t_{i},F_{j,k})$</p><p>Code</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> V,G,n;<span class="comment">//V和G为最大体积和重量</span></span><br><span class="line"><span class="keyword">int</span> t[<span class="number">510</span>],v[<span class="number">510</span>],g[<span class="number">510</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;V&gt;&gt;G;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;t[i]&gt;&gt;v[i]&gt;&gt;g[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=v[i];j--)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=G;k&gt;=g[i];k--) </span><br><span class="line">      f[j][k]=max(f[j-v[i]][k-g[i]]+t[i],f[j][k]);<span class="comment">//状态转移方程</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[V][G];<span class="comment">//f[V][G]即为答案</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道01背包模板题吧。。。其实就是再增加了一个体积参数&lt;/p&gt;
&lt;p&gt;状态转移方程：&lt;/p&gt;
&lt;p&gt;$F_{j,k}=max(F_{j-v_{i},k-g_{i}}+t_{i},F_{j,k})$&lt;/p&gt;
&lt;p&gt;Code&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="动态规划（dp）" scheme="http://zyx02.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89/"/>
    
      <category term="背包" scheme="http://zyx02.github.io/blog/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>题解 CF1043A 【Elections】</title>
    <link href="http://zyx02.github.io/blog/2019/04/01/%E9%A2%98%E8%A7%A3-CF1043A-%E3%80%90Elections%E3%80%91/"/>
    <id>http://zyx02.github.io/blog/2019/04/01/题解-CF1043A-【Elections】/</id>
    <published>2019-04-01T15:41:41.000Z</published>
    <updated>2019-06-25T14:25:20.001Z</updated>
    
    <content type="html"><![CDATA[<p>一看数据范围， $1 \le n \le 100 $，此时不枚举更待何时？（雾）</p><p>注意获胜是指小$A$的票数大于小$B$的票数，而不是大于等于。（原谅作者语文不好$qwq$）</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> sum1,sum2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//自定义排序函数，从大到小排</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],sum1+=a[i];<span class="comment">//预处理小B的票数</span></span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,comp);<span class="comment">//因为k&gt;=max&#123;ai&#125;，所以考虑先排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=a[<span class="number">1</span>];;k++)</span><br><span class="line">&#123;</span><br><span class="line">sum2=<span class="number">0</span>;<span class="comment">//一定要初始化！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  sum2+=k-a[i];<span class="comment">//每个人投给小A的票数就是每个人可以投的票数减去每个人投给小B的票数</span></span><br><span class="line"><span class="keyword">if</span>(sum2&gt;sum1)<span class="comment">//是&gt;不是&gt;=</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察一下代码，我们发现可以在求小$A$的票数部分做一些小小的优化</p><p>观察可以发现，$sum2$=$\sum_{i=1}^{n}(k-a_{i})$</p><p>原式</p><p>$=$ $k\times n-\sum_{i=1}^{n}a_{i}$ </p><p>$=$ $k\times n-sum1$</p><p>于是在求小$A$的票数部分可以优化到$O(1)$复杂度</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> sum1,sum2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],sum1+=a[i];</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,comp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=a[<span class="number">1</span>];;k++)</span><br><span class="line">&#123;</span><br><span class="line">sum2=k*n-sum1;<span class="comment">//求小A的票数，当然你也可以不用再设一个变量直接比较</span></span><br><span class="line"><span class="keyword">if</span>(sum2&gt;sum1)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再观察一下这个程序，我们发现，这个程序其实就要求最小的$k$，使得$k$满足$k\times n-sum1&gt;sum1$</p><p>这不就是一个不等式吗</p><p>移项： $k\times n&gt;2\times sum1$</p><p>系数化一: $k&gt;2\times sum1 /n$</p><p>于是在求答案的部分就可以优化到$O(1)$复杂度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> sum1;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i],sum1+=a[i];</span><br><span class="line">sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,comp);</span><br><span class="line"><span class="keyword">if</span>(<span class="number">2</span>*sum1/n+<span class="number">1</span>&lt;a[<span class="number">1</span>]) <span class="built_in">cout</span>&lt;&lt;a[<span class="number">1</span>];<span class="comment">//因为k要&gt;=max a[i]，所以如果2*sum/n+1&lt;a[1]要输出a[1]</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="number">2</span>*sum1/n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一看数据范围， $1 \le n \le 100 $，此时不枚举更待何时？（雾）&lt;/p&gt;
&lt;p&gt;注意获胜是指小$A$的票数大于小$B$的票数，而不是大于等于。（原谅作者语文不好$qwq$）&lt;/p&gt;
&lt;h3 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="洛谷" scheme="http://zyx02.github.io/blog/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="题解" scheme="http://zyx02.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="CodeForces" scheme="http://zyx02.github.io/blog/tags/CodeForces/"/>
    
      <category term="枚举" scheme="http://zyx02.github.io/blog/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>set学习笔记</title>
    <link href="http://zyx02.github.io/blog/2019/03/31/set%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://zyx02.github.io/blog/2019/03/31/set学习笔记/</id>
    <published>2019-03-30T17:25:40.000Z</published>
    <updated>2019-06-25T14:24:07.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是set-和-set的好处"><a href="#1-什么是set-和-set的好处" class="headerlink" title="1.什么是set 和 set的好处"></a>1.什么是set 和 set的好处</h2><p>$set$的翻译为集合，是一个内部自动有序且不含重复元素(即满足集合的互异性)的$STL$容器，其内部采用“红黑树”实现。</p><p>什么是集合？<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117?fr=aladdin" target="_blank" rel="noopener">点这</a></p><p>$set$的好处在于自动完成去重和按升序排序</p><h2 id="2-举个栗子"><a href="#2-举个栗子" class="headerlink" title="2.举个栗子"></a>2.举个栗子</h2><p>比如<a href="https://www.luogu.org/problemnew/show/P1059" target="_blank" rel="noopener">这题</a></p><h4 id="1-普通作法"><a href="#1-普通作法" class="headerlink" title="1.普通作法"></a>1.普通作法</h4><p>看到数据范围这么水肯定想到用桶排</p><p>Code<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">1001</span>],n,i,j,m=<span class="number">0</span>,x;</span><br><span class="line">    <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(b[x]==<span class="number">0</span>) m++;</span><br><span class="line">        b[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)</span><br><span class="line">      <span class="keyword">if</span>(b[i]&gt;<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-set"><a href="#2-set" class="headerlink" title="2.set"></a>2.set</h4><p>如果你会了$set$，这道题就可以这么打</p><p>Code<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        st.insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,st.size()); </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it= st.begin(); it!=st.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果数据范围大了话，明显不能用桶排解决，这时候$set$的好处就可以体现出来。</p><p>领会了$set$的好处之后，接下来让我们了解</p><h2 id="3-set的定义"><a href="#3-set的定义" class="headerlink" title="3.set的定义"></a>3.set的定义</h2><p>使用$set$之前，必须添加$set$头文件，即<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>也可以打好我们的$bits/stdc++.h$</p><p>同时必须要有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><p>定义一个$set$的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></table></figure><p>其中$typename$为任何基本类型或者容器，$name$为这个集合的名字</p><p>同时$set$也支持定义数组，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set&lt;typename&gt; name[MAXN]</span><br></pre></td></tr></table></figure><p>即定义了$MAXN$个$set$容器</p><h2 id="4-set的访问"><a href="#4-set的访问" class="headerlink" title="4.set的访问"></a>4.set的访问</h2><p>一大坑点是$set$只能通过迭代器访问</p><h3 id="1-定义一个迭代器"><a href="#1-定义一个迭代器" class="headerlink" title="1.定义一个迭代器"></a>1.定义一个迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br></pre></td></tr></table></figure><p>即定义一个名为$it$的迭代器</p><h3 id="2-通过迭代器访问"><a href="#2-通过迭代器访问" class="headerlink" title="2.通过迭代器访问"></a>2.通过迭代器访问</h3><p>注意事项：</p><ul><li><p>1 $set$不支持类似*$(it+i)$的访问</p></li><li><p>2 $set$也不支持$it&lt;name.end()$这种访问</p></li></ul><p>我们需要使用*$it$来访问$set$中的元素</p><h2 id="5-set的常用函数"><a href="#5-set的常用函数" class="headerlink" title="5.set的常用函数"></a>5.set的常用函数</h2><h3 id="1-insert"><a href="#1-insert" class="headerlink" title="1.insert()"></a>1.insert()</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><p>$insert()$用来插入一个数到$set$中，并自动排序+去重</p><h4 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(log_{2}n)$</p><h4 id="3-用法"><a href="#3-用法" class="headerlink" title="3.用法"></a>3.用法</h4><p>例如，以下一段代码输出$1$ $2$ $3 $</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.insert(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-begin-和end"><a href="#2-begin-和end" class="headerlink" title="2.begin()和end()"></a>2.begin()和end()</h3><h4 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1.作用"></a>1.作用</h4><p>分别用来获取$set$容器的首地址和尾地址</p><p>用法跟其他$STL$容器一样这里不再赘述</p><h3 id="3-size"><a href="#3-size" class="headerlink" title="3.size()"></a>3.size()</h3><h4 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用"></a>1.作用</h4><p>用于获取$set$容器中元素的个数</p><h4 id="2-时间复杂度-1"><a href="#2-时间复杂度-1" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(1)$</p><h4 id="3-用法-1"><a href="#3-用法-1" class="headerlink" title="3.用法"></a>3.用法</h4><p>例如，以下一段代码输出$3$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.insert(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size();</span><br></pre></td></tr></table></figure><h3 id="4-clear"><a href="#4-clear" class="headerlink" title="4.clear()"></a>4.clear()</h3><h4 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用"></a>1.作用</h4><p>用于清空$set$容器中的所有元素</p><h4 id="2-时间复杂度-2"><a href="#2-时间复杂度-2" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(n)$ ($n$为$set$中的元素个数)</p><h4 id="3-用法-2"><a href="#3-用法-2" class="headerlink" title="3.用法"></a>3.用法</h4><p>例如，以下一段代码输出$1$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.clear();</span><br><span class="line">a.insert(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size();</span><br></pre></td></tr></table></figure><h3 id="5-erase"><a href="#5-erase" class="headerlink" title="5.erase()"></a>5.erase()</h3><h4 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用"></a>1.作用</h4><p>可以用来删除单个元素也可以用来删除一段区间的元素</p><p>1.删除单个元素</p><h5 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h5><p>$O(1)$ (使用迭代器)</p><p>$O(log_{2}n)$ (使用欲删除元素的值)</p><h5 id="2-用法"><a href="#2-用法" class="headerlink" title="2.用法"></a>2.用法</h5><p>1.$erase(it)$</p><p>$it$为欲删除的元素的迭代器</p><p>例如，以下一段代码输出$2$ $3$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.erase(a.begin());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.$erase(value)$</p><p>$value$为欲删除元素的值</p><p>例如以下一段代码输出$1$ $3$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line">a.erase(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.删除一个区间的元素</p><h5 id="1-时间复杂度-1"><a href="#1-时间复杂度-1" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h5><p>$O(right-left)$ $(左闭右开区间[left,right))$</p><h5 id="2-用法-1"><a href="#2-用法-1" class="headerlink" title="2.用法"></a>2.用法</h5><p>$erase(left,right)$用来删除左闭右开区间[$left$,$right$)之间的元素</p><p>例如，以下一段代码输出$1$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.find(<span class="number">2</span>);</span><br><span class="line">a.erase(it,a.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=a.begin();it!=a.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-find"><a href="#6-find" class="headerlink" title="6.find()"></a>6.find()</h3><h4 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1.作用"></a>1.作用</h4><p>返回元素在$set$中的迭代器</p><h4 id="2-时间复杂度-3"><a href="#2-时间复杂度-3" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><p>$O(log_{2}n)$ ($n$为$set$中的元素个数)</p><h4 id="3-用法-3"><a href="#3-用法-3" class="headerlink" title="3.用法"></a>3.用法</h4><p>例如，以下一段代码输出$2$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&gt;=<span class="number">1</span>;i--) a.insert(i);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*a.find(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="6-推荐例题"><a href="#6-推荐例题" class="headerlink" title="6.推荐例题"></a>6.推荐例题</h2><ul><li>1 <a href="https://www.luogu.org/problemnew/show/P1059" target="_blank" rel="noopener">洛谷P1059 明明的随机数</a></li></ul><p>之后还会继续放上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是set-和-set的好处&quot;&gt;&lt;a href=&quot;#1-什么是set-和-set的好处&quot; class=&quot;headerlink&quot; title=&quot;1.什么是set 和 set的好处&quot;&gt;&lt;/a&gt;1.什么是set 和 set的好处&lt;/h2&gt;&lt;p&gt;$set$的翻译为集
      
    
    </summary>
    
    
      <category term="C++" scheme="http://zyx02.github.io/blog/tags/C/"/>
    
      <category term="学习笔记" scheme="http://zyx02.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="set" scheme="http://zyx02.github.io/blog/tags/set/"/>
    
  </entry>
  
</feed>
